/**
 * @brief Constructs a new Simple Parser object
 *
 * Reads the given file, tokenizes it and prepares for parsing.
 *
 * @param filename The name of the file to parse.
 */
SimpleParser::SimpleParser(std::vector<LexicalToken> tokenStream) {
	this->tokenStream = tokenStream;
	this->tokenIndex = 0;
}

/**
 * @brief Parses the entire program and returns a tree representing it.
 *
 * @return std::shared_ptr<ASTNode> A pointer to the root of the parse tree.
 */
std::shared_ptr<ASTNode> SimpleParser::parseProgram() {
	std::vector<std::shared_ptr<ASTNode>> procedures;
	const int START_OF_PROGRAM = 1;

	while (this->hasTokensLeft()) {
		procedures.push_back(this->parseProcedure());
	}

	std::shared_ptr<ASTNode> root = std::make_shared<ASTNode>(
		ASTNodeType::PROGRAMS, START_OF_PROGRAM, ASTUtility::getASTNodeType(ASTNodeType::PROGRAMS)
	);

	root->lineNumber = PROGRAM_LINE_NUMBER;
	int maxLineNumber = 0;
	for (auto& procedure : procedures) {
		int temp = ASTTraverser::setLineNumbers(procedure, maxLineNumber);
		root->addChild(procedure);
		maxLineNumber = temp;
	}

	return root;
}

/**
 * @brief Assert Token to check if the token's type matches the expected one.
 *
 * @param token A lexical token in the stream.
 * @param type A expected lexical token type.
 * @throws Retrieves a runtime_error if the token's type doesn't match the expected type.
 */
void SimpleParser::assertToken(LexicalToken token, LexicalTokenType type) const {
	if (!token.isType(type)) {
		throw std::runtime_error("Error: Expected " + LexicalTokenTypeMapper::printType(type) + " but got " + LexicalTokenTypeMapper::printType(token.getTokenType()) +
			" At Line " + std::to_string(token.getLine()) + " Position " + std::to_string(token.getLinePosition()));
	}
}

/**
 * @brief Check if there are more tokens to parse.
 *
 * @return bool Returns true if there are more tokens in the token stream otherwise false.
 */
bool SimpleParser::hasTokensLeft() const {
	return this->tokenIndex < this->tokenStream.size();
}

/**
 * @brief Gets the token from the stream without advancing the index.
 *
 * @return LexicalToken The next token in the stream without advancing the index.
 */
LexicalToken SimpleParser::peekNextToken() {
	if (this->hasTokensLeft()) {
		LexicalToken token = this->tokenStream[this->tokenIndex];

		if (token.isType(LexicalTokenType::WHITESPACE)) {
			this->tokenIndex++;
			return peekNextToken();
		}

		return token;
	}
	else {
		return LexicalToken(LexicalTokenType::NULL_TOKEN);
	}
}

/**
 * @brief Gets the token from the stream and advances the index by 1.
 *
 * @return LexicalToken The next token in the stream.
 */
LexicalToken SimpleParser::getNextToken() {
	if (this->hasTokensLeft()) {
		LexicalToken token = this->tokenStream[this->tokenIndex];
		this->tokenIndex++;

		if (token.isType(LexicalTokenType::WHITESPACE)) {
			return getNextToken();
		}

		return token;
	}
	else {
		return LexicalToken(LexicalTokenType::NULL_TOKEN);
	}
}
