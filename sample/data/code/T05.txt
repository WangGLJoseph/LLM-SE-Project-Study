RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/spa/src/QPS/QueryEvaluator/PKBStub.h
Generator: gpt
Intervention: 0
Language: e
Prompt: https://platform.openai.com/playground/p/ErjJuev6dMUJWh9xtwKTTNXx?model=gpt-4&mode=chat
ChatId: ErjJuev6dMUJWh9xtwKTTNXx
Code:
class PKBStub {
private:
    std::shared_ptr<QueryResult> result;
public:
    PKBStub() = default;
    PKBStub(std::vector<std::string>& stringList)
            : result(std::make_shared<StringResult>(stringList)) {}

    std::shared_ptr<QueryResult> getResult(Returnable& r, Constraint& c){
        return result;
    }
};
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/unit/qps/query_evaluator/IntResultTestAI.cpp
Generator: gpt
Intervention: 0
Language: e
Prompt: https://platform.openai.com/playground/p/oplThAEITLAK0fBCIylSnHDm?model=gpt-4&mode=chat
ChatId: oplThAEITLAK0fBCIylSnHDm
Code:
TEST_CASE("intResult-intersect_emptyResult_returnsEmpty") {
    std::vector<int> res1{};
    std::shared_ptr<IntResult> intRes1 = std::make_shared<IntResult>(res1);

    std::vector<int> res2{};
    std::shared_ptr<IntResult> intRes2 = std::make_shared<IntResult>(res2);

    std::vector<int> expectedRes{};

    REQUIRE(intRes1->intersect(intRes2) == expectedRes);
}

TEST_CASE("intResult-intersect_emptyAndNonempty_returnsEmpty") {
    std::vector<int> res1{1, 2, 3, 4, 5};
    std::shared_ptr<IntResult> intRes1 = std::make_shared<IntResult>(res1);

    std::vector<int> res2{};
    std::shared_ptr<IntResult> intRes2 = std::make_shared<IntResult>(res2);

    std::vector<int> expectedRes{};

    REQUIRE(intRes1->intersect(intRes2) == expectedRes);
}

TEST_CASE("intResult-intersect_nonemptyOverlap_returnsIntersection") {
    std::vector<int> res1{1, 2, 3, 4, 5};
    std::shared_ptr<IntResult> intRes1 = std::make_shared<IntResult>(res1);

    std::vector<int> res2{3, 4, 5, 6, 7};
    std::shared_ptr<IntResult> intRes2 = std::make_shared<IntResult>(res2);

    std::vector<int> expectedRes{3, 4, 5};

    REQUIRE(intRes1->intersect(intRes2) == expectedRes);
}
//ai-end
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/unit/qps/query_elements/QueryObjectTestAI.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://chat.openai.com/share/ab543156-156c-4880-9673-2ea97ffd9182
ChatId: ab543156-156c-4880-9673-2ea97ffd9182
Code:
TEST_CASE("QueryObject_GetReturnType_ReturnsCorrectValue") {
    QueryObject queryObj;
    auto returnType = std::make_shared<PrintEntity>("g");
    queryObj.setReturnType(returnType);
    REQUIRE(queryObj.getReturnType() == returnType);
}

TEST_CASE("QueryObject_Set/GetReturnType_SetsCorrectValue") {
    QueryObject queryObj;
    std::shared_ptr<Returnable> returnType = std::make_shared<PrintEntity>("c");
    queryObj.setReturnType(returnType);
    REQUIRE(queryObj.getReturnType() == returnType);
}

TEST_CASE("QueryObject_Get/AddConstraints_ReturnsCorrectVector") {
    QueryObject queryObj;
    auto s = std::make_shared<StatementEntity>("a");
    auto r = std::make_shared<ReadEntity>("z");
//    FollowsConstraint follows_constraint(s, r);
    auto follows_constraint = std::make_shared<FollowsConstraint>(s, r);
    queryObj.addConstraint(follows_constraint);
    std::vector<std::shared_ptr<Constraint>> constraints = queryObj.getConstraints();
    REQUIRE(constraints.size() == 1);
    // Check if the stored pointer is of type FollowsConstraint
    std::shared_ptr<FollowsConstraint> storedConstraint = dynamic_pointer_cast<FollowsConstraint>(constraints[0]);
    REQUIRE(storedConstraint != nullptr); // Ensure dynamic_cast succeeded
    REQUIRE(storedConstraint == follows_constraint); // Address comparison
}

TEST_CASE("QueryObject_Add/GetConstraint_ReturnsCorrectValues") {
    QueryObject queryObj;
    auto s = std::make_shared<StatementEntity>("a");
    auto r = std::make_shared<ReadEntity>("z");
    //FollowsConstraint follows_constraint(s, r);
    auto follows_constraint = std::make_shared<FollowsConstraint>(s, r);

    queryObj.addConstraint(follows_constraint);
    std::vector<std::shared_ptr<Constraint>> constraints = queryObj.getConstraints();
    REQUIRE(constraints[0] == follows_constraint); // Address comparison
}

TEST_CASE("QueryObject_Get/AddDeclarations_ReturnsCorrectValues") {
    QueryObject queryObj;
//    PrintEntity declaration1("q"); // Using PrintEntity instead of Entity
//    PrintEntity declaration2("h"); // Using PrintEntity instead of Entity
    auto declaration1 = std::make_shared<PrintEntity>("q");
    auto declaration2 = std::make_shared<PrintEntity>("h");
    queryObj.addDeclaration(declaration1);
    queryObj.addDeclaration(declaration2);
    std::vector<std::shared_ptr<Entity>> declarations = queryObj.getDeclarations();
    REQUIRE(declarations.size() == 2);
    // Check if the stored pointers are of type PrintEntity

    std::shared_ptr<PrintEntity> storedDeclaration1 = dynamic_pointer_cast<PrintEntity>(declarations[0]);
    std::shared_ptr<PrintEntity> storedDeclaration2 = dynamic_pointer_cast<PrintEntity>(declarations[1]);

    REQUIRE(storedDeclaration1 != nullptr); // Ensure dynamic_cast succeeded
    REQUIRE(storedDeclaration2 != nullptr); // Ensure dynamic_cast succeeded
    // Address comparison
    REQUIRE(storedDeclaration1 == declaration1);
    REQUIRE(storedDeclaration2 == declaration2);
}
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/unit/qps/query_elements/StatementReferenceTestAI.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/9SCJ5Iuz6Qhdknrd17M6Eh8k?model=gpt-3.5-turbo&mode=chat
ChatId: 9SCJ5Iuz6Qhdknrd17M6Eh8k
Code:
TEST_CASE("entity_statementEntityIsTypeStatement_stringStatement") {
    StatementEntity en = StatementEntity("q");
    REQUIRE(en.getEntityType() == TYPE_STATEMENT);
}

TEST_CASE("entity_readEntityIsTypeStatement_stringRead") {
    ReadEntity en = ReadEntity("o");
    REQUIRE(en.getEntityType() == TYPE_READ);
}

TEST_CASE("entity_printEntityIsTypePrint_stringPrint") {
    PrintEntity en = PrintEntity("r");
    REQUIRE(en.getEntityType() == TYPE_PRINT);
}

TEST_CASE("entity_assignEntityIsTypeAssign_stringAssign") {
    AssignEntity en = AssignEntity("a");
    REQUIRE(en.getEntityType() == TYPE_ASSIGN);
}

TEST_CASE("entity_callEntityIsTypeCall_stringCall") {
    CallEntity en = CallEntity("b");
    REQUIRE(en.getEntityType() == TYPE_CALL);
}

TEST_CASE("entity_ifEntityIsTypeIf_stringIf") {
    IfEntity en = IfEntity("c");
    REQUIRE(en.getEntityType() == TYPE_IF);
}

TEST_CASE("entity_whileEntityIsTypeWhile_stringWhile") {
    WhileEntity en = WhileEntity("d");
    REQUIRE(en.getEntityType() == TYPE_WHILE);
}

TEST_CASE("entity_integerArgumentIsTypeInteger_stringInteger") {
    IntegerArgument en = IntegerArgument();
    REQUIRE(en.getEntityType() == TYPE_INTEGER);
}

TEST_CASE("entity_wildCardIsTypeWildcard_stringWildcard") {
    StatementRefWildCard en = StatementRefWildCard();
    REQUIRE(en.getEntityType() == TYPE_WILDCARD);
}

TEST_CASE("Entity_GetIdentifier_Success") {
    // Arrange
    std::string identifier = "test_identifier";
    AssignEntity entity(identifier);

    // Act
    std::string retrievedIdentifier = entity.getIdentifier();

    // Assert
    REQUIRE(retrievedIdentifier == identifier);
}

TEST_CASE("inheritance_check_statementReference_ReadEntity") {
    ReadEntity readEntity("v");
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&readEntity) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("inheritance_check_statementReference_PrintEntity") {
    PrintEntity printEntity("p");
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&printEntity) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("inheritance_check_statementReference_AssignEntity") {
    AssignEntity assignEntity("f");
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&assignEntity) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("inheritance_check_statementReference_CallEntity") {
    CallEntity callEntity("c");
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&callEntity) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("inheritance_check_statementReference_IfEntity") {
    IfEntity ifEntity("d");
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&ifEntity) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("inheritance_check_statementReference_WhileEntity") {
    WhileEntity whileEntity("e");
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&whileEntity) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("inheritance_check_statementReference_IntegerArgument") {
    IntegerArgument integerArgument;
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&integerArgument) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("inheritance_check_statementReference_WildCard") {
    StatementRefWildCard wildCard;
    bool isInstanceOfStatementReference = dynamic_cast<StatementReference*>(&wildCard) != nullptr;
    REQUIRE(isInstanceOfStatementReference);
}

TEST_CASE("StatementEntity_inheritanceCheck_isTrue") {
    REQUIRE(std::is_base_of<Entity, StatementEntity>::value);
}

TEST_CASE("ReadEntity_inheritanceCheck_isTrue") {
    REQUIRE(std::is_base_of<Entity, ReadEntity>::value);
}

TEST_CASE("PrintEntity_inheritanceCheck_isTrue") {
    REQUIRE(std::is_base_of<Entity, PrintEntity>::value);
}

TEST_CASE("AssignEntity_inheritanceCheck_isTrue") {
    REQUIRE(std::is_base_of<Entity, AssignEntity>::value);
}

TEST_CASE("CallEntity_inheritanceCheck_isTrue") {
    REQUIRE(std::is_base_of<Entity, CallEntity>::value);
}

TEST_CASE("IfEntity_inheritanceCheck_isTrue") {
    REQUIRE(std::is_base_of<Entity, IfEntity>::value);
}

TEST_CASE("WhileEntity_inheritanceCheck_isTrue") {
    REQUIRE(std::is_base_of<Entity, WhileEntity>::value);
}

TEST_CASE("IntegerArgument_inheritanceCheck_isFalse") {
    REQUIRE_FALSE(std::is_base_of<Entity, IntegerArgument>::value);
}

TEST_CASE("WildCard_inheritanceCheck_isFalse") {
    REQUIRE_FALSE(std::is_base_of<Entity, StatementRefWildCard>::value);
}
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/unit/qps/query_elements/ConstraintArgumentTestAI.cpp
Generator: gpt
Intervention: 0
Language: e
Prompt: https://platform.openai.com/playground/p/iUhV1Vs18pHIoJq0lDbowAOl?model=gpt-3.5-turbo&mode=chat
ChatId: iUhV1Vs18pHIoJq0lDbowAOl
Code:
TEST_CASE("StatementEntity_inherits_from_ConstraintArgument") {
    StatementEntity statement("z");
    REQUIRE(dynamic_cast<ConstraintArgument*>(&statement) != nullptr);
}

TEST_CASE("ReadEntity_inherits_from_ConstraintArgument") {
    ReadEntity read("a");
    REQUIRE(dynamic_cast<ConstraintArgument*>(&read) != nullptr);
}

TEST_CASE("PrintEntity_inherits_from_ConstraintArgument") {
    PrintEntity print("b");
    REQUIRE(dynamic_cast<ConstraintArgument*>(&print) != nullptr);
}

TEST_CASE("AssignEntity_inherits_from_ConstraintArgument") {
    AssignEntity assign("c");
    REQUIRE(dynamic_cast<ConstraintArgument*>(&assign) != nullptr);
}

TEST_CASE("CallEntity_inherits_from_ConstraintArgument") {
    CallEntity call("f");
    REQUIRE(dynamic_cast<ConstraintArgument*>(&call) != nullptr);
}

TEST_CASE("IfEntity_inherits_from_ConstraintArgument") {
    IfEntity ifEntity("a");
    REQUIRE(dynamic_cast<ConstraintArgument*>(&ifEntity) != nullptr);
}

TEST_CASE("WhileEntity_inherits_from_ConstraintArgument") {
    WhileEntity whileEntity("q");
    REQUIRE(dynamic_cast<ConstraintArgument*>(&whileEntity) != nullptr);
}

TEST_CASE("IntegerArgument_inherits_from_ConstraintArgument") {
    IntegerArgument integerArg;
    REQUIRE(dynamic_cast<ConstraintArgument*>(&integerArg) != nullptr);
}

TEST_CASE("StatementEntity_ReferenceType_StatementReference") {
    StatementEntity s("q");
    REQUIRE(s.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("ReadEntity_ReferenceType_StatementReference") {
    ReadEntity r("p");
    REQUIRE(r.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("PrintEntity_ReferenceType_StatementReference") {
    PrintEntity p("Q");
    REQUIRE(p.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("AssignEntity_ReferenceType_StatementReference") {
    AssignEntity a("p");
    REQUIRE(a.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("CallEntity_ReferenceType_StatementReference") {
    CallEntity c("i");
    REQUIRE(c.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("IfEntity_ReferenceType_StatementReference") {
    IfEntity i("g");
    REQUIRE(i.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("WhileEntity_ReferenceType_StatementReference") {
    WhileEntity w("v");
    REQUIRE(w.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("IntegerArgument_ReferenceType_StatementReference") {
    IntegerArgument ia;
    REQUIRE(ia.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}

TEST_CASE("WildCard_ReferenceType_StatementReference") {
    StatementRefWildCard wc;
    REQUIRE(wc.getReferenceType() == REFERENCE_TYPE_STATEMENT);
}
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/unit/qps/query_elements/ConstraintTestAI.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/kRR1UQyUxzRLr95Mnxz0MCoG?model=gpt-3.5-turbo&mode=chat
ChatId: kRR1UQyUxzRLr95Mnxz0MCoG
Code:
TEST_CASE("dynamic_cast_inheritance_relationship_constraint") {
    std::shared_ptr<StatementEntity> s = std::make_shared<StatementEntity>("q");
    std::shared_ptr<ReadEntity> r = std::make_shared<ReadEntity>("f");
    std::shared_ptr<ProcedureEntity> a = std::make_shared<ProcedureEntity>("k");
    FollowsConstraint follows_constraint(s, r);
    FollowsTConstraint follows_t_constraint(s, r);
    ParentConstraint parent_constraint(s, r);
    ParentTConstraint parent_t_constraint(s, r);
    UsesPConstraint uses_p_constraint(a, a);
    UsesSConstraint uses_s_constraint(s, a);
    ModifiesPConstraint modifies_p_constraint(a, a);
    ModifiesSConstraint modifies_s_constraint(r, a);

    SECTION("UsesPConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &uses_p_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);
    }

    SECTION("UsesSConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &uses_s_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);

    SECTION("FollowsConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &follows_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);
    }

    SECTION("FollowsTConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &follows_t_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);
    }

    SECTION("ParentConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &parent_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);
    }

    SECTION("ParentTConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &parent_t_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);
    }

    SECTION("ModifiesPConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &modifies_p_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);
    }

    SECTION("ModifiesSConstraint is a RelationshipConstraint") {
        Constraint* constraint_ptr = &modifies_s_constraint;
        REQUIRE(dynamic_cast<RelationshipConstraint*>(constraint_ptr) != nullptr);
    }
}
}


TEST_CASE("getConstraintClass_returns_CONSTRAINT_CLASS_RELATIONSHIP") {
    std::shared_ptr<StatementEntity> s = std::make_shared<StatementEntity>("o");
    std::shared_ptr<ReadEntity> r = std::make_shared<ReadEntity>("p");

    SECTION("FollowsConstraint") {
    FollowsConstraint follows_constraint(s, r);
    REQUIRE(follows_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

    SECTION("FollowsTConstraint") {
    FollowsTConstraint follows_t_constraint(s, r);
    REQUIRE(follows_t_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

    SECTION("ParentConstraint") {
    ParentConstraint parent_constraint(s, r);
    REQUIRE(parent_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

    SECTION("ParentTConstraint") {
    ParentTConstraint parent_t_constraint(s, r);
    REQUIRE(parent_t_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

    std::shared_ptr<ProcedureEntity> a = std::make_shared<ProcedureEntity>("k");

    SECTION("UsesPConstraint") {
        UsesPConstraint uses_p_constraint(a, a);
        REQUIRE(uses_p_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

    SECTION("UsesSConstraint") {
        UsesSConstraint uses_s_constraint(s, a);
        REQUIRE(uses_s_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

    SECTION("ModifiesPConstraint") {
        ModifiesPConstraint modifies_p_constraint(a, a);
        REQUIRE(modifies_p_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

    SECTION("ModifiesSConstraint") {
        ModifiesSConstraint modifies_s_constraint(r, a);
        REQUIRE(modifies_s_constraint.getConstraintClass() == CONSTRAINT_CLASS_RELATIONSHIP);
    }

}


TEST_CASE("InitializeConstraint_with_StatementReference_subclasses") {
    // All possible StatementReference subclasses
    std::vector<std::shared_ptr<StatementReference>> statementRefEntities;

    statementRefEntities.push_back(std::make_shared<StatementEntity>("q"));
    statementRefEntities.push_back(std::make_shared<ReadEntity>("w"));
    statementRefEntities.push_back(std::make_shared<PrintEntity>("e"));
    statementRefEntities.push_back(std::make_shared<AssignEntity>("r"));
    statementRefEntities.push_back(std::make_shared<CallEntity>("t"));
    statementRefEntities.push_back(std::make_shared<IfEntity>("y"));
    statementRefEntities.push_back(std::make_shared<WhileEntity>("u"));
    statementRefEntities.push_back(std::make_shared<IntegerArgument>(12));
    statementRefEntities.push_back(std::make_shared<StatementRefWildCard>());

    // All possible EntityReference subclasses
    std::vector<std::shared_ptr<EntityReference>> entRefEntities;
    entRefEntities.push_back(std::make_shared<ProcedureEntity>("p"));
    entRefEntities.push_back(std::make_shared<VariableEntity>("v"));
    entRefEntities.push_back(std::make_shared<ConstantEntity>("c"));
    entRefEntities.push_back(std::make_shared<EntityRefWildCard>());

    SECTION("FollowsConstraint") {
        // Pairwise testing for FollowsConstraint initialization
        for (auto it1 = std::begin(statementRefEntities); it1 != std::end(statementRefEntities); ++it1) {
            for (auto it2 = it1 + 1; it2 != std::end(statementRefEntities); ++it2) {
                REQUIRE_NOTHROW(FollowsConstraint(*it1, *it2));
            }
        }
    }

    SECTION("FollowsTConstraint") {
        // Pairwise testing for FollowsTConstraint initialization
        for (auto it1 = std::begin(statementRefEntities); it1 != std::end(statementRefEntities); ++it1) {
            for (auto it2 = it1 + 1; it2 != std::end(statementRefEntities); ++it2) {
                REQUIRE_NOTHROW(FollowsTConstraint(*it1, *it2));
            }
        }
    }

    SECTION("ParentConstraint") {
        // Pairwise testing for ParentConstraint initialization
        for (auto it1 = std::begin(statementRefEntities); it1 != std::end(statementRefEntities); ++it1) {
            for (auto it2 = it1 + 1; it2 != std::end(statementRefEntities); ++it2) {
                REQUIRE_NOTHROW(ParentConstraint(*it1, *it2));
            }
        }
    }

    SECTION("ParentTConstraint") {
        // Pairwise testing for ParentTConstraint initialization
        for (auto it1 = std::begin(statementRefEntities); it1 != std::end(statementRefEntities); ++it1) {
            for (auto it2 = it1 + 1; it2 != std::end(statementRefEntities); ++it2) {
                REQUIRE_NOTHROW(ParentTConstraint(*it1, *it2));
            }
        }
    }

    SECTION("UsesSConstraint") {
        for (const auto& statementRef : statementRefEntities) {
            for (const auto& entityRef : entRefEntities) {
                REQUIRE_NOTHROW(UsesSConstraint(statementRef, entityRef));
            }
        }
    }

    SECTION("UsesPConstraint") {
        for (const auto& entityRef1 : entRefEntities) {
            for (const auto& entityRef : entRefEntities) {
                REQUIRE_NOTHROW(UsesPConstraint(entityRef1, entityRef));
            }
        }
    }

    SECTION("ModifiesSConstraint") {
        for (const auto& statementRef : statementRefEntities) {
            for (const auto& entityRef : entRefEntities) {
                REQUIRE_NOTHROW(ModifiesSConstraint(statementRef, entityRef));
            }
        }
    }

    SECTION("ModifiesPConstraint") {
        for (const auto& entityRef1 : entRefEntities) {
            for (const auto& entityRef : entRefEntities) {
                REQUIRE_NOTHROW(ModifiesPConstraint(entityRef1, entityRef));
            }
        }
    }


}
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/unit/sp/helper/AstFactory.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://chat.openai.com/share/367b948e-5198-4955-ab4d-f81ff1b1f3c8
ChatId: 367b948e-5198-4955-ab4d-f81ff1b1f3c8
Code:
#include <memory>
#include <string>
#include <algorithm>
#include "sp/Expr.h"
#include "sp/Stmt.h"
#include "sp/Token.h"

class AstFactory {
public:

    static std::shared_ptr<Token> createTokens(TokenType tokenType, std::string lexeme) {
        return std::make_shared<Token>(tokenType, lexeme);
    }

    // Expression creators
    static std::shared_ptr<Binary> createBinary(std::shared_ptr<Expr> left, std::shared_ptr<Token> op, std::shared_ptr<Expr> right) {
        return std::make_shared<Binary>(std::move(left), std::move(op), std::move(right));
    }

    static std::shared_ptr<Variable> createVariable(const std::string& name) {
        return std::make_shared<Variable>(name);
    }

    static std::shared_ptr<Literal> createLiteral(int value) {
        return std::make_shared<Literal>(value);
    }

    static std::shared_ptr<Unary> createUnary(std::shared_ptr<Token> op, std::shared_ptr<Expr> right) {
        return std::make_shared<Unary>(std::move(op), std::move(right));
    }

    // Statement creators
    static std::shared_ptr<Read> createRead(StmtNo stmtNo, std::shared_ptr<Variable> variable) {
        return std::make_shared<Read>(stmtNo, std::move(variable));
    }

    static std::shared_ptr<Print> createPrint(StmtNo stmtNo, std::shared_ptr<Variable> variable) {
        return std::make_shared<Print>(stmtNo, std::move(variable));
    }

    static std::shared_ptr<Call> createCall(StmtNo stmtNo, const std::string& procName) {
        return std::make_shared<Call>(stmtNo, procName);
    }

    static std::shared_ptr<While> createWhile(StmtNo stmtNo, std::shared_ptr<Expr> condition, std::shared_ptr<StmtList> body) {
        return std::make_shared<While>(stmtNo, std::move(condition), std::move(body));
    }

    static std::shared_ptr<If> createIf(StmtNo stmtNo, std::shared_ptr<Expr> condition, std::shared_ptr<StmtList> thenBranch, std::shared_ptr<StmtList> elseBranch) {
        return std::make_shared<If>(stmtNo, std::move(condition), std::move(thenBranch), std::move(elseBranch));
    }

    static std::shared_ptr<Assign> createAssign(StmtNo stmtNo, std::shared_ptr<Expr> variable, std::shared_ptr<Expr> value) {
        return std::make_shared<Assign>(stmtNo, std::move(variable), std::move(value));
    }

    // Create a StmtList from a vector of shared_ptr to Stmt
    static std::shared_ptr<StmtList> createStmtList(std::vector<std::shared_ptr<Stmt>> stmts) {
        auto stmtList = std::make_shared<StmtList>();
        for (auto& stmt : stmts) {
            stmtList->push_back(std::move(stmt));
        }
        return stmtList;
    }

    // Create a Procedure
    static std::shared_ptr<Procedure> createProcedure(const std::string& name, std::shared_ptr<StmtList> body) {
        return std::make_shared<Procedure>(name, std::move(body));
    }

    // Create a Program from a vector of shared_ptr to Procedure
    static Program createProgram(std::vector<std::shared_ptr<Procedure>> procedures) {
        auto program = std::make_shared<std::vector<std::shared_ptr<Procedure>>>();
        for (auto& procedure : procedures) {
            program->push_back(std::move(procedure));
        }
        return program;
    }
};
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/QueryValidatorTestAI.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://chat.openai.com/share/b79012a9-d6db-4272-a8f5-d4e4e167dd91
ChatId: b79012a9-d6db-4272-a8f5-d4e4e167dd91
Code:
TEST_CASE("QueryValidator_ValidateQuery_NoErrors") {
    // Create a QueryObject with valid unique declarations and no constraint violations
    IntermediateQuery qo;
    auto assignEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto printEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    printEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "y");

    qo.addClause(assignEntity);
    qo.addClause(printEntity);

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "x");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "y");
    auto parentConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t1, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);

    qo.addClause(parentConstraint);

    // Apply QueryValidator to validate the QueryObject
    QueryValidator validator;
    std::vector<std::string> failedRules = validator.validateQuery(qo);

    // Ensure no failed rules are returned
    REQUIRE(failedRules.empty());
}

TEST_CASE("QueryValidator_ValidateQuery_SingleDeclarationRuleViolation") {
    // Create a QueryObject violating the SingleDeclarationRule
    IntermediateQuery qo;

    auto assignEntity1 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto assignEntity2 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");

    qo.addClause(assignEntity1);
    qo.addClause(assignEntity2);

    // Apply QueryValidator to validate the QueryObject
    QueryValidator validator;
    std::vector<std::string> failedRules = validator.validateQuery(qo);

    // Ensure SingleDeclarationRule violation is detected
    REQUIRE(failedRules.size() == 1);
    REQUIRE(failedRules[0] == VALIDATION_RULE_SINGLE_DECLARATION);
}

TEST_CASE("QueryValidator_ValidateQuery_NoDeclarationRuleViolation") {
    // Create a QueryObject violating the NoDeclarationRule
    IntermediateQuery qo;

    auto assignEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto printEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    printEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "y");

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "x");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "y");
    auto pConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t1, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);

    qo.addClause(pConstraint);

    // Apply QueryValidator to validate the QueryObject
    QueryValidator validator;
    std::vector<std::string> failedRules = validator.validateQuery(qo);

    // Ensure NoDeclarationRule violation is detected
    REQUIRE(failedRules.size() == 1);
    REQUIRE(failedRules[0] == VALIDATION_RULE_NO_DECLARATION);
}

TEST_CASE("QueryValidator_ValidateQuery_MultipleRuleViolations") {
    // Create a QueryObject violating both SingleDeclarationRule and NoDeclarationRule
    IntermediateQuery qo;

    auto assignEntity1 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto assignEntity2 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto printEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    printEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "y");

    qo.addClause(assignEntity1);
    qo.addClause(assignEntity2);

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "x");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "y");

    auto pConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t1, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);
    qo.addClause(pConstraint);

    // Apply QueryValidator to validate the QueryObject
    QueryValidator validator;
    std::vector<std::string> failedRules = validator.validateQuery(qo);

    // Ensure both SingleDeclarationRule and NoDeclarationRule violations are detected
    REQUIRE(failedRules.size() == 2);
    REQUIRE(std::find(failedRules.begin(), failedRules.end(), VALIDATION_RULE_SINGLE_DECLARATION) != failedRules.end());
    REQUIRE(std::find(failedRules.begin(), failedRules.end(), VALIDATION_RULE_NO_DECLARATION) != failedRules.end());
}

TEST_CASE("QueryValidator_ValidateQuery_EmptyQueryObject") {
    // Create an empty QueryObject
    IntermediateQuery qo;

    // Apply QueryValidator to validate the QueryObject
    QueryValidator validator;
    std::vector<std::string> failedRules = validator.validateQuery(qo);

    // Ensure no failed rules are returned for an empty QueryObject
    REQUIRE(failedRules.empty());
}
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/SingleDeclarationRuleTestAI.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://chat.openai.com/share/dccb94c8-d4d6-4310-b2f1-2306849865cf
ChatId: dccb94c8-d4d6-4310-b2f1-2306849865cf
Code:
TEST_CASE("SingleDeclarationRule_ValidDeclarations_NoError") {
    // Create a QueryObject with valid unique declarations
    IntermediateQuery qo;

    auto assignEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto printEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    printEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "p");
    auto statementEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    statementEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::STMT1), "s");

    qo.addClause(assignEntity);
    qo.addClause(printEntity);
    qo.addClause(statementEntity);

    // Apply the SingleDeclarationRule
    SingleDeclarationRule rule;
    std::string result = rule.validate(qo);

    // Ensure no error message is returned
    REQUIRE(result.empty());
}

TEST_CASE("SingleDeclarationRule_DuplicateDeclarations_Error") {
    // Create a QueryObject with duplicate declarations
    IntermediateQuery qo;
    auto assignEntity1 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto assignEntity2 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");

    qo.addClause(assignEntity1);
    qo.addClause(assignEntity2);

    // Apply the SingleDeclarationRule
    SingleDeclarationRule rule;
    std::string result = rule.validate(qo);

    // Ensure error message is returned
    REQUIRE(result == VALIDATION_RULE_SINGLE_DECLARATION);
}

TEST_CASE("SingleDeclarationRule_MixedDeclarations_Error") {
    // Create a QueryObject with a mix of unique and duplicate declarations
    IntermediateQuery qo;

    auto assignEntity1 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");
    auto printEntity = std::make_shared<DeclarationClause>(DeclarationClause());
    printEntity->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "y");
    auto assignEntity2 = std::make_shared<DeclarationClause>(DeclarationClause());
    assignEntity2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::ASSIGN), "x");

    qo.addClause(assignEntity1);
    qo.addClause(printEntity);
    qo.addClause(assignEntity2);

    // Apply the SingleDeclarationRule
    SingleDeclarationRule rule;
    std::string result = rule.validate(qo);

    // Ensure error message is returned as soon as a duplicate is encountered
    REQUIRE(result == VALIDATION_RULE_SINGLE_DECLARATION);
}

TEST_CASE("SingleDeclarationRule_NoDeclarations_NoError") {
    // Create a QueryObject with no declarations
    IntermediateQuery qo;

    // Apply the SingleDeclarationRule
    SingleDeclarationRule rule;
    std::string result = rule.validate(qo);

    // Ensure no error message is returned
    REQUIRE(result.empty());
}
--------------------
RepoName: 23s2-cp-spa-team-05
File: Team05/Code05/src/unit_testing/src/NoDeclarationRuleTestAI.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://chat.openai.com/share/58cc37a5-02ca-46fb-8029-ff79056aad6c
ChatId: 58cc37a5-02ca-46fb-8029-ff79056aad6c
Code:
TEST_CASE("noDeclarationRule_AllEntitiesDeclaredOnce_returnsNoString") {
    // Create a QueryObject with all entities declared exactly once
    IntermediateQuery qo;
    // Add entity declarations

    auto e1 = std::make_shared<DeclarationClause>(DeclarationClause());
    e1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::STMT1), "p");
    auto e2 = std::make_shared<DeclarationClause>(DeclarationClause());
    e2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "s");


    qo.addClause(e1);
    qo.addClause(e2);

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "p");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "s");
    auto pConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t1, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);

    qo.addClause(pConstraint);
    NoDeclarationRule rule;
    REQUIRE(rule.validate(qo).empty());
}

TEST_CASE("noDeclarationRule_Missing2EntityDeclaration_returnsString") {
    // Create a QueryObject with a missing entity declaration
    IntermediateQuery qo;
    // Add entity declaration

    auto e1 = std::make_shared<DeclarationClause>(DeclarationClause());
    e1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::STMT1), "j");
    auto e2 = std::make_shared<DeclarationClause>(DeclarationClause());
    e2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "h");

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "j");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "h");
    auto pConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t1, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);

    // Add a constraint with an undeclared entity as an argument
    qo.addClause(pConstraint); // e1, e2 is not declared in qo
    NoDeclarationRule rule;

    REQUIRE(rule.validate(qo) == VALIDATION_RULE_NO_DECLARATION);
}

TEST_CASE("noDeclarationRule_Missing1EntityDeclaration_returnsString") {
    // Create a QueryObject with a missing entity declaration
    IntermediateQuery qo;
    // Add entity declaration

    auto e1= std::make_shared<DeclarationClause>(DeclarationClause());
    e1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::STMT1), "g");
    auto e2 = std::make_shared<DeclarationClause>(DeclarationClause());
    e2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "f");


    qo.addClause(e1);

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "g");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "f");
    auto pConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t1, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);


    // Add a constraint with an undeclared entity as an argument
    qo.addClause(pConstraint);
    NoDeclarationRule rule;

    REQUIRE(rule.validate(qo) == VALIDATION_RULE_NO_DECLARATION);
}



TEST_CASE("noDeclarationRule_MultipleUsageOfMissingEntity_returnsString") {
    // Create a QueryObject with multiple usage of the same entity
    IntermediateQuery qo;
    // Add entity declaration
    auto e1 = std::make_shared<DeclarationClause>(DeclarationClause());
    e1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::STMT1), "e");
    auto e2 = std::make_shared<DeclarationClause>(DeclarationClause());
    e2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "e2");

    qo.addClause(e1);

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "e");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "e2");

    auto pConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t2, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);
    qo.addClause(pConstraint);

    // Add a constraint with multiple occurrences of the same entity as arguments
    //auto* p = new ParentConstraint(e2, e2); // e1 is assigned again
    NoDeclarationRule rule;
    REQUIRE(rule.validate(qo) == VALIDATION_RULE_NO_DECLARATION);
}

TEST_CASE("noDeclarationRule_EmptyQueryObjectPass_returnsNoString") {
    // Create an empty QueryObject
    IntermediateQuery qo;
    NoDeclarationRule rule;
    REQUIRE(rule.validate(qo).empty());
}

TEST_CASE("noDeclarationRule_EntitiesUsedAsArgumentsNotDeclared_returnsString") {
    // Create a QueryObject with entities used as arguments but not declared
    IntermediateQuery qo;
    // Add a constraint with an entity as an argument without declaration
    auto e1 = std::make_shared<DeclarationClause>(DeclarationClause());
    e1->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::STMT1), "q");
    auto e2 = std::make_shared<DeclarationClause>(DeclarationClause());
    e2->addDeclaration(QPSTokenType(QPSTokenType::QPSTypeInfo::PRINT), "s");

    auto t1 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "q");
    auto t2 = QPSToken(QPSTokenType(QPSTokenType::QPSTypeInfo::SYNONYM), "s");
    auto pConstraint = std::make_shared<RelationshipClause>(QPSTokenType::QPSTypeInfo::PARENT, t1, QPSTokenType::QPSTypeInfo::STMT_REF, t2, QPSTokenType::QPSTypeInfo::STMT_REF);
    qo.addClause(pConstraint); // e1 and e2 is not declared in qo
    NoDeclarationRule rule;
    REQUIRE(rule.validate(qo) == VALIDATION_RULE_NO_DECLARATION);
}
--------------------
Directory:../sample/repo/23s2-cp-spa-team-05
Total Snippets: 10
Total lines: 922
SP Snippets: 1
SP lines: 82
PKB Snippets: 0
PKB lines: 0
QPS Snippets: 6
QPS lines: 533
