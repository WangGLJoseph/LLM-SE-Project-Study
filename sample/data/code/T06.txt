RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/integration_testing/src/SP/DesignExtractor/Util/MockDesignExtractors.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "MockStore.h"
#include "PKB/API/Store.h"

#include "SP/DesignExtractor/DesignExtractorFacade.h"
#include "SP/DesignExtractor/Extractors/Entities/AssignExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/CallExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/ConstantExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/IfExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/PrintExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/ProcedureExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/ReadExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/StmtExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/VariableExtractor.h"
#include "SP/DesignExtractor/Extractors/Entities/WhileExtractor.h"

#include "SP/DesignExtractor/EntityDesignExtractor.h"
#include "SP/DesignExtractor/Extractors/Relationships/FollowsExtractor.h"
#include "SP/DesignExtractor/Extractors/Relationships/ModifiesExtractor.h"
#include "SP/DesignExtractor/Extractors/Relationships/ParentExtractor.h"
#include "SP/DesignExtractor/Extractors/Relationships/UsesExtractor.h"
#include "SP/DesignExtractor/RelationshipDesignExtractor.h"

#include "SP/DesignExtractor/Extractors/Patterns/AssignPatternExtractor.h"

// Mock design extractor facade to test design extractors individually instead of all of them as per implementation
template <typename T>
class MockDesignExtractorFacade : public DesignExtractorFacade {
public:
    MockDesignExtractorFacade(std::weak_ptr<MockStore> writer) : DesignExtractorFacade(writer) {
        mockExtractor = std::make_shared<T>(writer.lock());
    }

    void extractDesigns(std::shared_ptr<ASTNodeProgram> programNode) { programNode->acceptVisitor(mockExtractor); }

protected:
    std::shared_ptr<T> mockExtractor;
    std::weak_ptr<MockStore> pkb;
};

class MockEntityDesignExtractor : public EntityDesignExtractor {
public:
    MockEntityDesignExtractor(std::weak_ptr<MockStore> writer)
        : EntityDesignExtractor(std::static_pointer_cast<Store>(writer.lock())) {
        clearAllNodeExtractors();
    }

    void clearAllNodeExtractors() {
        endOfProgramNodeSubscribers.clear();
        procedureNodeExtractors.clear();
        stmtLstNodeExtractors.clear();
        stmtNodeExtractors.clear();
        readNodeExtractors.clear();
        printNodeExtractors.clear();
        assignNodeExtractors.clear();
        callNodeExtractors.clear();
        whileNodeExtractors.clear();
        ifNodeExtractors.clear();
        oprExprNodeExtractors.clear();
        termExprNodeExtractors.clear();
        relCondExprNodeExtractors.clear();
        unaryCondExprNodeExtractors.clear();
        binaryCondExprNodeExtractors.clear();
    }
};

class MockRelationshipDesignExtractor : public RelationshipDesignExtractor {
public:
    MockRelationshipDesignExtractor(std::weak_ptr<MockStore> writer)
        : RelationshipDesignExtractor(std::static_pointer_cast<Store>(writer.lock())) {
        clearAllNodeExtractors();
    }

    void clearAllNodeExtractors() {
        endOfProgramNodeSubscribers.clear();
        procedureNodeExtractors.clear();
        stmtLstNodeExtractors.clear();
        stmtNodeExtractors.clear();
        readNodeExtractors.clear();
        printNodeExtractors.clear();
        assignNodeExtractors.clear();
        callNodeExtractors.clear();
        whileNodeExtractors.clear();
        ifNodeExtractors.clear();
        oprExprNodeExtractors.clear();
        termExprNodeExtractors.clear();
        relCondExprNodeExtractors.clear();
        unaryCondExprNodeExtractors.clear();
        binaryCondExprNodeExtractors.clear();
    }
};

class MockPatternDesignExtractor : public PatternDesignExtractor {
public:
    MockPatternDesignExtractor(std::weak_ptr<MockStore> writer)
        : PatternDesignExtractor(std::static_pointer_cast<Store>(writer.lock())) {
        clearAllNodeExtractors();
    }

    void clearAllNodeExtractors() {
        endOfProgramNodeSubscribers.clear();
        procedureNodeExtractors.clear();
        stmtLstNodeExtractors.clear();
        stmtNodeExtractors.clear();
        readNodeExtractors.clear();
        printNodeExtractors.clear();
        assignNodeExtractors.clear();
        callNodeExtractors.clear();
        whileNodeExtractors.clear();
        ifNodeExtractors.clear();
        oprExprNodeExtractors.clear();
        termExprNodeExtractors.clear();
        relCondExprNodeExtractors.clear();
        unaryCondExprNodeExtractors.clear();
        binaryCondExprNodeExtractors.clear();
    }
};

class MockProcedureEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockProcedureEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto procedureExtractor = std::make_shared<ProcedureExtractor>(writer);
        procedureNodeExtractors.emplace_back(procedureExtractor);
    }
};

class MockStmtEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockStmtEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto stmtExtractor = std::make_shared<StmtExtractor>(writer);
        stmtNodeExtractors.emplace_back(stmtExtractor);
    }
};

class MockAssignEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockAssignEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto assignExtractor = std::make_shared<AssignExtractor>(writer);
        assignNodeExtractors.emplace_back(assignExtractor);
    }
};

class MockCallEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockCallEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto callExtractor = std::make_shared<CallExtractor>(writer);
        callNodeExtractors.emplace_back(callExtractor);
    }
};

class MockIfEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockIfEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto ifExtractor = std::make_shared<IfExtractor>(writer);
        ifNodeExtractors.emplace_back(ifExtractor);
    }
};

class MockPrintEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockPrintEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto printExtractor = std::make_shared<PrintExtractor>(writer);
        printNodeExtractors.emplace_back(printExtractor);
    }
};

class MockReadEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockReadEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto readExtractor = std::make_shared<ReadExtractor>(writer);
        readNodeExtractors.emplace_back(readExtractor);
    }
};

class MockWhileEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockWhileEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto whileExtractor = std::make_shared<WhileExtractor>(writer);
        whileNodeExtractors.emplace_back(whileExtractor);
    }
};

class MockVariableEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockVariableEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto variableExtractor = std::make_shared<VariableExtractor>(writer);
        readNodeExtractors.emplace_back(variableExtractor);
        assignNodeExtractors.emplace_back(variableExtractor);
        printNodeExtractors.emplace_back(variableExtractor);
        termExprNodeExtractors.emplace_back(variableExtractor);
    }
};

class MockConstantEntityDesignExtractor : public MockEntityDesignExtractor {
public:
    MockConstantEntityDesignExtractor(std::weak_ptr<MockStore> writer) : MockEntityDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto constantExtractor = std::make_shared<ConstantExtractor>(writer);
        termExprNodeExtractors.emplace_back(constantExtractor);
    }
};

class MockFollowsRelationshipDesignExtractor : public MockRelationshipDesignExtractor {
public:
    MockFollowsRelationshipDesignExtractor(std::weak_ptr<MockStore> writer) : MockRelationshipDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto followsExtractor = std::make_shared<FollowsExtractor>(writer);
        stmtLstNodeExtractors.emplace_back(followsExtractor);
        endOfProgramNodeSubscribers.emplace_back(followsExtractor);
    }
};

class MockParentRelationshipDesignExtractor : public MockRelationshipDesignExtractor {
public:
    MockParentRelationshipDesignExtractor(std::weak_ptr<MockStore> writer) : MockRelationshipDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto parentExtractor = std::make_shared<ParentExtractor>(writer);
        ifNodeExtractors.emplace_back(parentExtractor);
        whileNodeExtractors.emplace_back(parentExtractor);
        endOfProgramNodeSubscribers.emplace_back(parentExtractor);
    }
};

class MockModifiesRelationshipDesignExtractor : public MockRelationshipDesignExtractor {
public:
    MockModifiesRelationshipDesignExtractor(std::weak_ptr<MockStore> writer) : MockRelationshipDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto modifiesExtractor = std::make_shared<ModifiesExtractor>(writer);
        procedureNodeExtractors.emplace_back(modifiesExtractor);
        assignNodeExtractors.emplace_back(modifiesExtractor);
        readNodeExtractors.emplace_back(modifiesExtractor);
        ifNodeExtractors.emplace_back(modifiesExtractor);
        whileNodeExtractors.emplace_back(modifiesExtractor);
        callNodeExtractors.emplace_back(modifiesExtractor);
        endOfProgramNodeSubscribers.emplace_back(modifiesExtractor);
    }
};

class MockUsesRelationshipDesignExtractor : public MockRelationshipDesignExtractor {
public:
    MockUsesRelationshipDesignExtractor(std::weak_ptr<MockStore> writer) : MockRelationshipDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto usesExtractor = std::make_shared<UsesExtractor>(writer);
        procedureNodeExtractors.emplace_back(usesExtractor);
        assignNodeExtractors.emplace_back(usesExtractor);
        printNodeExtractors.emplace_back(usesExtractor);
        ifNodeExtractors.emplace_back(usesExtractor);
        whileNodeExtractors.emplace_back(usesExtractor);
        callNodeExtractors.emplace_back(usesExtractor);
        termExprNodeExtractors.emplace_back(usesExtractor);
        endOfProgramNodeSubscribers.emplace_back(usesExtractor);
    }
};

class MockAssignPatternDesignExtractor : public MockPatternDesignExtractor {
public:
    MockAssignPatternDesignExtractor(std::weak_ptr<MockStore> writer) : MockPatternDesignExtractor(writer) {
        // Reset all extractors, we only want specific ones for testing
        clearAllNodeExtractors();
        auto assignPatternExtractor = std::make_shared<AssignPatternExtractor>(writer);
        assignNodeExtractors.emplace_back(assignPatternExtractor);
    }
};

#endif // SP_DESIGNEXTRACTOR_UTIL_MOCKDESIGNEXTRACTORS_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/integration_testing/src/SP/DesignExtractor/TestDesignExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
// Note: These tests for the design extractor and its extractors are technically integration tests. Their functionality
// depends on the AST and DE visitor pattern implementation and the DE and extractors can only be tested assuming that
// the visitor pattern works (which is tested in AST unit testing). As such, these tests for design extractor and its
// extracors are placed here in the integration_testing folder.

TEST_CASE("Design Extractor: SampleAST Extraction", "[DesignExtractor]") {
    auto mockStore = std::make_shared<MockStore>();

    if (mockStore) {
        // Perform traversal
        // Relies on all nodes being traversed (TestASTFull.cpp test)

        SECTION("Procedure Entities Extraction 1 procedure", "[ProcedureExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockProcedureEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->procedureEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"procedureName"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("Procedure Entities Extraction 2 procedures", "[ProcedureExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2(); // Note: Different tests use different ASTs
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockProcedureEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->procedureEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"procedureName", "otherProcedure"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("All Stmt Entities Extraction", "[StmtExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockStmtEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->statementEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"1", "2", "3", "4", "5", "6", "7", "8", "9"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("Assign Entities Extraction", "[AssignExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockAssignEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->assignEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"4", "8", "9"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("Call Entities Extraction", "[CallExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockCallEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->callEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"6"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("If Entities Extraction", "[IfExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockIfEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->ifEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"2"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("Print Entities Extraction", "[PrintExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockPrintEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->printEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"3"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("Read Entities Extraction", "[ReadExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockReadEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->readEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"1", "7"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("While Entities Extraction", "[WhileExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockWhileEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->whileEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"5"};
            REQUIRE(entities == expectedEntities);
        }

        SECTION("Constant Entities Extraction", "[ConstantExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockConstantEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->constantEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"10", "11", "12"};

            REQUIRE(entities == expectedEntities);
        }

        SECTION("Variable Entities Extraction", "[VariableExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto entityDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockVariableEntityDesignExtractor>>(mockStore);
            entityDesignExtractorFacade->extractDesigns(programNode);

            const auto& entities = mockStore->variableEntitySet;

            // Check set of all extracted entities
            std::unordered_set<std::string> expectedEntities = {"x", "y", "z", "i", "variableName"};

            REQUIRE(entities == expectedEntities);
        }

        SECTION("Follows and FollowsStar Relationship Extraction 1", "[MockRelationOnlyDesignExtractorFacade]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockFollowsRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& relationships = mockStore->followsRelationshipMap;
            const auto& starRelationships = mockStore->followsStarRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedRelationships;
            expectedRelationships["1"].insert("2");
            expectedRelationships["2"].insert("5");

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedStarRelationships;
            expectedStarRelationships["1"].insert("5");

            // Insert all expectedRelationships into expectedStarRelationships
            for (const auto& relationship : expectedRelationships) {
                const auto& key = relationship.first;
                const auto& values = relationship.second;
                expectedStarRelationships[key].insert(values.begin(), values.end());
            }

            REQUIRE(relationships == expectedRelationships);
            REQUIRE(starRelationships == expectedStarRelationships);
        }

        SECTION("Follows and FollowsStar Relationship Extraction 2", "[MockRelationOnlyDesignExtractorFacade]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockFollowsRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& relationships = mockStore->followsRelationshipMap;
            const auto& starRelationships = mockStore->followsStarRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedRelationships;
            expectedRelationships["1"].insert("2");
            expectedRelationships["2"].insert("5");
            expectedRelationships["7"].insert("8");
            expectedRelationships["8"].insert("9");

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedStarRelationships;
            expectedStarRelationships["1"].insert("5");
            expectedStarRelationships["7"].insert("9");

            // Insert all expectedRelationships into expectedStarRelationships
            for (const auto& relationship : expectedRelationships) {
                const auto& key = relationship.first;
                const auto& values = relationship.second;
                expectedStarRelationships[key].insert(values.begin(), values.end());
            }

            REQUIRE(relationships == expectedRelationships);
            REQUIRE(starRelationships == expectedStarRelationships);
        }

        SECTION("Parent and ParentStar Relationship Extraction", "[MockRelationOnlyDesignExtractorFacade]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockParentRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& relationships = mockStore->parentRelationshipMap;
            const auto& starRelationships = mockStore->parentStarRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedRelationships;
            expectedRelationships["2"].insert("3");
            expectedRelationships["2"].insert("4");
            expectedRelationships["5"].insert("6");

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedStarRelationships;

            // Insert all expectedRelationships into expectedStarRelationships
            for (const auto& relationship : expectedRelationships) {
                const auto& key = relationship.first;
                const auto& values = relationship.second;
                expectedStarRelationships[key].insert(values.begin(), values.end());
            }

            REQUIRE(relationships == expectedRelationships);
            REQUIRE(starRelationships == expectedStarRelationships);
        }

        SECTION("Parent and ParentStar Relationship Extraction with nested if and nested while statements",
                "[MockRelationOnlyDesignExtractorFacade]") {
            auto programNode = MockNodeFactory::createSampleAST3();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockParentRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& relationships = mockStore->parentRelationshipMap;
            const auto& starRelationships = mockStore->parentStarRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedRelationships;
            expectedRelationships["2"].insert("3");
            expectedRelationships["2"].insert("4");
            expectedRelationships["4"].insert("5");
            expectedRelationships["4"].insert("6");
            expectedRelationships["2"].insert("7");
            expectedRelationships["8"].insert("9");
            expectedRelationships["10"].insert("11");
            expectedRelationships["10"].insert("12");
            expectedRelationships["8"].insert("10");

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedStarRelationships;
            expectedStarRelationships["2"].insert("5");
            expectedStarRelationships["2"].insert("6");
            expectedStarRelationships["8"].insert("10");
            expectedStarRelationships["8"].insert("11");
            expectedStarRelationships["8"].insert("12");

            // Insert all expectedRelationships into expectedStarRelationships
            for (const auto& relationship : expectedRelationships) {
                const auto& key = relationship.first;
                const auto& values = relationship.second;
                expectedStarRelationships[key].insert(values.begin(), values.end());
            }

            REQUIRE(relationships == expectedRelationships);
            REQUIRE(starRelationships == expectedStarRelationships);
        }

        SECTION("Modifies Relationship Extraction with 1 procedure", "[MockModifiesRelationshipDesignExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockModifiesRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& pRelationships = mockStore->modifiesPRelationshipMap;
            const auto& sRelationships = mockStore->modifiesSRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedPRelationshipMap;
            expectedPRelationshipMap["procedureName"].insert("x");            // from line 1
            expectedPRelationshipMap["procedureName"].insert("y");            // from line 2
            expectedPRelationshipMap["procedureName"].insert("variableName"); // from line 5

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedSRelationshipMap;
            expectedSRelationshipMap["6"].insert("variableName"); // read stmt
            expectedSRelationshipMap["5"].insert("variableName"); // 6 inside while stmt
            expectedSRelationshipMap["4"].insert("y");            // assign
            expectedSRelationshipMap["2"].insert("y");            // 4 inside if else clause
            expectedSRelationshipMap["1"].insert("x");            // read stmt

            REQUIRE(pRelationships == expectedPRelationshipMap);
            REQUIRE(sRelationships == expectedSRelationshipMap);
        }

        SECTION("Modifies Relationship Extraction with 2 procedures", "[MockModifiesRelationshipDesignExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockModifiesRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& pRelationships = mockStore->modifiesPRelationshipMap;
            const auto& sRelationships = mockStore->modifiesSRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedPRelationshipMap;
            expectedPRelationshipMap["otherProcedure"].insert("aa"); // read
            expectedPRelationshipMap["otherProcedure"].insert("bb"); // assign
            expectedPRelationshipMap["otherProcedure"].insert("cc"); // assign
            expectedPRelationshipMap["procedureName"].insert("x");   // from line 1
            expectedPRelationshipMap["procedureName"].insert("y");   // from line 2
            expectedPRelationshipMap["procedureName"].insert("aa");  // from line 5
            expectedPRelationshipMap["procedureName"].insert("bb");  // from line 5
            expectedPRelationshipMap["procedureName"].insert("cc");  // from line 5

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedSRelationshipMap;
            expectedSRelationshipMap["7"].insert("aa"); // read
            expectedSRelationshipMap["8"].insert("bb"); // assign
            expectedSRelationshipMap["9"].insert("cc"); // assign
            expectedSRelationshipMap["6"].insert("aa"); // call otherProcedure
            expectedSRelationshipMap["6"].insert("bb"); // call otherProcedure
            expectedSRelationshipMap["6"].insert("cc"); // call otherProcedure
            expectedSRelationshipMap["5"].insert("aa"); // 6 inside while stmt
            expectedSRelationshipMap["5"].insert("bb"); // 6 inside while stmt
            expectedSRelationshipMap["5"].insert("cc"); // 6 inside while stmt
            expectedSRelationshipMap["4"].insert("y");  // assign
            expectedSRelationshipMap["2"].insert("y");  // 4 inside if else clause
            expectedSRelationshipMap["1"].insert("x");  // read stmt

            REQUIRE(pRelationships == expectedPRelationshipMap);
            REQUIRE(sRelationships == expectedSRelationshipMap);
        }

        SECTION("Uses Relationship Extraction with 1 procedure,"
                "[MockUsesRelationshipDesignExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST1();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockUsesRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& pRelationships = mockStore->usesPRelationshipMap;
            const auto& sRelationships = mockStore->usesSRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedPRelationshipMap;
            expectedPRelationshipMap["procedureName"].insert("x"); // from line 2
            expectedPRelationshipMap["procedureName"].insert("i"); // from line 2

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedSRelationshipMap;
            expectedSRelationshipMap["3"].insert("x"); // print
            expectedSRelationshipMap["2"].insert("x"); // 3 inside if then clause
            expectedSRelationshipMap["4"].insert("i"); // assign
            expectedSRelationshipMap["2"].insert("i"); // 4 inside if else clause

            REQUIRE(pRelationships == expectedPRelationshipMap);
            REQUIRE(sRelationships == expectedSRelationshipMap);
        }

        SECTION("Uses Relationship Extraction with 2 procedures,"
                "[MockUsesRelationshipDesignExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto relationshipDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockUsesRelationshipDesignExtractor>>(mockStore);
            relationshipDesignExtractorFacade->extractDesigns(programNode);

            const auto& pRelationships = mockStore->usesPRelationshipMap;
            const auto& sRelationships = mockStore->usesSRelationshipMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedPRelationshipMap;
            expectedPRelationshipMap["otherProcedure"].insert("dd"); // from line 9
            expectedPRelationshipMap["procedureName"].insert("x");   // from line 2
            expectedPRelationshipMap["procedureName"].insert("i");   // from line 2
            expectedPRelationshipMap["procedureName"].insert("dd");  // from line 5

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedSRelationshipMap;
            expectedSRelationshipMap["9"].insert("dd"); // assign
            expectedSRelationshipMap["6"].insert("dd"); // call otherProcedure
            expectedSRelationshipMap["5"].insert("dd"); // 6 inside while stmt
            expectedSRelationshipMap["3"].insert("x");  // print
            expectedSRelationshipMap["4"].insert("i");  // assign
            expectedSRelationshipMap["2"].insert("x");  // 3 inside if then clause
            expectedSRelationshipMap["2"].insert("i");  // 4 inside if else clause

            REQUIRE(pRelationships == expectedPRelationshipMap);
            REQUIRE(sRelationships == expectedSRelationshipMap);
        }

        SECTION("Assign Pattern Extraction", "[AssignPatternExtractor]") {
            auto programNode = MockNodeFactory::createSampleAST2();
            auto patternDesignExtractorFacade =
                std::make_shared<MockDesignExtractorFacade<MockAssignPatternDesignExtractor>>(mockStore);
            patternDesignExtractorFacade->extractDesigns(programNode);

            const auto& patterns = mockStore->assignPatternMap;

            std::unordered_map<std::string, std::unordered_set<std::string>> expectedPatterns;
            expectedPatterns["y"].insert("i 11 +");
            expectedPatterns["bb"].insert("14");
            expectedPatterns["cc"].insert("dd");

            REQUIRE(patterns == expectedPatterns);
        }
    } else {
        REQUIRE(false);
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/ClauseResultTable.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef CLAUSERESULTTABLE_H
#define CLAUSERESULTTABLE_H

#include <string>
#include <unordered_set>
#include <vector>

class ClauseResultTable
{
public:
    ClauseResultTable();
    void addHeaders(const std::vector<std::string> &synonyms);
    void addHeader(const std::string &synonym);
    void addRow(const std::vector<std::string> &row);
    std::vector<std::string> getColumn(const std::string &synonym);
    std::vector<std::string> getHeaders() const;
    std::vector<std::vector<std::string>> getRows() const;
    std::vector<std::string> getRow(int index) const;
    int getRowCount() const;
    int getSymnoymIndex(const std::string &synonym) const;
    bool isEmpty();
    void deleteRow(int index);
    void filterColumns(std::vector<std::string> &synonyms);
    void removeDuplicateRows();

private:
    std::vector<std::string> headers;
    std::vector<std::vector<std::string>> rows;
};
#endif // CLAUSERESULTTABLE_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QPSTokenizer/QPSTokenizer.cpp
Generator: gpt
Intervention: 2
Language: e
Prompt: https://platform.openai.com/playground/p/3ES4mP3HH332lpIQnm9ILzJe?model=gpt-4&mode=chat
ChatId: 3ES4mP3HH332lpIQnm9ILzJe
Code:
// Vector of tokens to be returned
    // std::vector<QPSToken> tokens;

    this->tokens.clear();
    this->currentIndex = 0;
    // Create a string stream from the input string
    std::istringstream iss(query);
    std::string token;
    QPSToken tempToken(QPSTokenType::NAME, "default");
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/ClauseResultTableManager.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ClauseResultTableManager.h"

void ClauseResultTableManager::addUngroupedTable(const ClauseResultTable &table)
{
    ungroupedTables.push_back(table);
}

void ClauseResultTableManager::mergeTables(std::vector<ClauseResultTable> &tables)
{
    if (tables.empty())
        return;

    ClauseResultTable mergedTable = tables[0];

    if (tables.size() == 1)
    {
        finalResultTable = mergedTable;
        return;
    }
    else
    {
        for (size_t i = 1; i < tables.size(); ++i)
        {
            if (tables[i].getHeaders().size() == 1 && mergedTable.getHeaders().size() == 1)
            {
                mergedTable = mergeTwoTablesWithOneHeader(mergedTable, tables[i]);
            }
            else
            {
                mergedTable = mergeTwoTables(mergedTable, tables[i]);
            }
        }

        // Store the merged table as the final result, to be changed for optimisation
        finalResultTable = mergedTable;
    }
}

void ClauseResultTableManager::generateFinalResultTable()
{
    // Implementation to generate the final result table, to be changed for optimisation
    // for (const auto &table : tables)
    // {
    //     finalResultTable.mergeTable(table);
    // }
    mergeTables(ungroupedTables);
}

std::shared_ptr<ClauseResultTable> ClauseResultTableManager::getFinalResultTable()
{
    return std::make_shared<ClauseResultTable>(finalResultTable);
}

// For testing only
std::shared_ptr<ClauseResultTable> ClauseResultTableManager::getUngroupedTable()
{
    return std::make_shared<ClauseResultTable>(ungroupedTables[0]);
}

void ClauseResultTableManager::createGroup()
{
    std::vector<ClauseResultTable> group;
    groups.push_back(group);
}

void ClauseResultTableManager::clearAllTables()
{
    ungroupedTables.clear();
    groups.clear();
    finalResultTable = ClauseResultTable();
}

bool ClauseResultTableManager::isUngroupedTableEmpty()
{
    return ungroupedTables.empty() || ungroupedTables[0].getRows().empty();
}

ClauseResultTable ClauseResultTableManager::mergeTwoTables(const ClauseResultTable &table1, const ClauseResultTable &table2)
{
    // Create a new table to store the merged results
    ClauseResultTable mergedTable;

    // Get headers from both tables
    auto headers1 = table1.getHeaders();
    auto headers2 = table2.getHeaders();

    // Create a set of common headers for the natural join
    std::unordered_set<std::string> commonHeaders;
    for (const auto &header : headers1)
    {
        if (std::find(headers2.begin(), headers2.end(), header) != headers2.end())
        {
            commonHeaders.insert(header);
        }
    }

    // Add all headers from the first table to the merged table
    for (const auto &header : headers1)
    {
        mergedTable.addHeader(header);
    }

    // Add headers from the second table that are not in the first table
    for (const auto &header : headers2)
    {
        if (commonHeaders.find(header) == commonHeaders.end())
        {
            mergedTable.addHeader(header);
        }
    }

    for (const auto &row1 : table1.getRows())
    {
        for (const auto &row2 : table2.getRows())
        {
            if (isJoinable(row1, row2, table1, table2, commonHeaders))
            {
                // If rows are joinable, merge them and add to the merged table
                std::vector<std::string> mergedRow = mergeRows(row1, row2, table1, table2, commonHeaders);
                mergedTable.addRow(mergedRow);
            }
            else if (commonHeaders.empty())
            {
                // If no common headers, perform a cross join
                std::vector<std::string> crossJoinedRow = crossJoinRows(row1, row2);
                mergedTable.addRow(crossJoinedRow);
            }
        }
    }

    return mergedTable;
}

bool ClauseResultTableManager::isJoinable(const std::vector<std::string> &row1, const std::vector<std::string> &row2, const ClauseResultTable &table1, const ClauseResultTable &table2, const std::unordered_set<std::string> &commonHeaders)
{
    // Check if the rows can be joined on common headers
    for (const auto &header : commonHeaders)
    {
        int index1 = table1.getSymnoymIndex(header);
        int index2 = table2.getSymnoymIndex(header);
        if (row1[index1] != row2[index2])
        {
            return false;
        }
    }
    return true;
}

std::vector<std::string> ClauseResultTableManager::mergeRows(const std::vector<std::string> &row1, const std::vector<std::string> &row2, const ClauseResultTable &table1, const ClauseResultTable &table2, const std::unordered_set<std::string> &commonHeaders)
{
    // Merge two rows based on common headers
    std::vector<std::string> mergedRow = row1;
    for (const auto &header : table2.getHeaders())
    {
        if (commonHeaders.find(header) == commonHeaders.end())
        {
            int index2 = table2.getSymnoymIndex(header);
            mergedRow.push_back(row2[index2]);
        }
    }
    return mergedRow;
}

std::vector<std::string> ClauseResultTableManager::crossJoinRows(const std::vector<std::string> &row1, const std::vector<std::string> &row2)
{
    // Combine two rows for a cross join
    std::vector<std::string> crossJoinedRow = row1;
    crossJoinedRow.insert(crossJoinedRow.end(), row2.begin(), row2.end());
    return crossJoinedRow;
}

ClauseResultTable ClauseResultTableManager::mergeTwoTablesWithOneHeader(const ClauseResultTable &table1, const ClauseResultTable &table2)
{
    ClauseResultTable mergedTable;
    // Get headers from both tables
    std::vector<std::string> headers1 = table1.getHeaders();
    std::vector<std::string> headers2 = table2.getHeaders();

    if (headers1[0] == headers2[0])
    {
        mergedTable.addHeader(headers1[0]);
        for (const auto &row : table1.getRows())
        {
            mergedTable.addRow(row);
        }

        for (const auto &row : table2.getRows())
        {
            mergedTable.addRow(row);
        }
        return mergedTable;
    }
    else
    {
        mergedTable.addHeader(headers1[0]);
        mergedTable.addHeader(headers2[0]);
        for (const auto &row1 : table1.getRows())
        {
            for (const auto &row2 : table2.getRows())
            {
                std::vector<std::string> crossJoinedRow = crossJoinRows(row1, row2);
                mergedTable.addRow(crossJoinedRow);
            }
        }
        return mergedTable;
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryValidator.cpp
Generator: copilot
Intervention: 2
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "QueryValidator.h"

QueryValidator::QueryValidator(std::shared_ptr<AbstractQuery> query) : query(query)
{

    designEntityTypeToRefTypeMap = {
        {DesignEntityType::ASSIGN, Ref::RefType::STMT_REF},
        {DesignEntityType::CALL, Ref::RefType::STMT_REF},
        {DesignEntityType::IF, Ref::RefType::STMT_REF},
        {DesignEntityType::PRINT, Ref::RefType::STMT_REF},
        {DesignEntityType::READ, Ref::RefType::STMT_REF},
        {DesignEntityType::STMT, Ref::RefType::STMT_REF},
        {DesignEntityType::WHILE, Ref::RefType::STMT_REF},
        {DesignEntityType::CONSTANT, Ref::RefType::ENT_REF},
        {DesignEntityType::VARIABLE, Ref::RefType::ENT_REF},
        {DesignEntityType::PROCEDURE, Ref::RefType::ENT_REF}

    };
}

void QueryValidator::validateQuery()
{
    // insert all the methods to validate here
    validateDeclarations();
    validateSelectProjections();
    validateSuchThatClauses();
    validatePatternClauses();
}

// Checks rule: "A synonym name can only be declared once"
void QueryValidator::validateDeclarations()
{

    // populate the declarationsMap to be used by the rest of the validation methods
    for (auto declaration : query->getDeclarations())
    {
        Synonym synonym = declaration.getSynonym();
        DesignEntityType entityType = declaration.getDesignEntityType();

        if (declarationsMap.count(synonym.getName()))
        {
            throw SemanticError("Duplicate declaration of synonym: " + synonym.getName());
        }

        // insert into declarationMap
        declarationsMap[synonym.getName()] = entityType;
    }
}

// Checks rule: "All the synonyms used in clauses must be declared exactly once."
void QueryValidator::validateSelectProjections()
{
    // if there is no select projection, throw error
    if (query->getSelectProjectionSynonyms().size() == 0)
    {
        throw SemanticError("There should be at least 1 Select Projection Synonym.");
    }

    // if the length of selectProjectionSynonyms is > 1, throw error
    if (query->getSelectProjectionSynonyms().size() > 1)
    {
        throw SemanticError("There should only be 1 Select Projection Synonym.");
    }

    for (auto selectProjectionSynonym : query->getSelectProjectionSynonyms())
    {
        if (declarationsMap.count(selectProjectionSynonym) == 0)
        {
            throw SemanticError("Select Projection Synonym: " + selectProjectionSynonym + " is not declared.");
        }

        // wrap synonym string into a SelectProjection and add to SelectProjection vector
        SelectProjection selectProjection(declarationsMap[selectProjectionSynonym], selectProjectionSynonym);
        query->addSelectProjection(selectProjection);
    }
}

// Checks rule: "All the synonyms used in clauses must be declared exactly once."
void QueryValidator::validateSuchThatClauses()
{
    for (auto suchThatClause : query->getSuchThatClauses())
    {
        Ref *leftRef = suchThatClause->getLeftRefPtr();
        Ref *rightRef = suchThatClause->getRightRefPtr();

        // Step 1: check synonyms are declared and decide the refType
        validateSuchThatClauseSynonyms(leftRef, rightRef);

        // Step 2: check if its Uses or Modifies clause and convert it to UsesP/S or ModifiesP/S based on leftRef
        validateDualTypeSuchThatClause(suchThatClause, leftRef);

        // Step 3: check if the refTypes are compatible with the relationship
        validateSuchThatClauseParameterTypes(suchThatClause, leftRef, rightRef);

        // skip checking the wildcard checking unless the QueryEvaluator requires it
    }
}

// Check that "syn-assign must be declared as a synonym of an assignment (design entity assign)."
void QueryValidator::validatePatternClauses()
{
    for (auto patternClause : query->getPatternClauseParameters())
    {
        std::string synonym = std::get<0>(patternClause);
        Ref leftRef = std::get<1>(patternClause);
        ExpressionSpec expressionSpec = std::get<2>(patternClause);

        if (declarationsMap.count(synonym) == 0)
        {
            throw SemanticError("Pattern Clause Synonym: " + synonym + " is not declared.");
        }

        switch (declarationsMap[synonym])
        {
        case DesignEntityType::ASSIGN:
            if (leftRef.getRefType() != Ref::RefType::ENT_REF)
            {
                throw SemanticError("The left parameter must be an entRef.");
            }
            // wrap it into a PatternClause and add to PatternClause vector
            query->addPatternClause("assign", synonym, leftRef, expressionSpec);
            break;
        default:
            throw SemanticError("Pattern Clause Synonym: " + synonym + " is not supported.");
        }
    }
}

void QueryValidator::validateSuchThatClauseSynonyms(Ref *leftRef, Ref *rightRef)
{
    if (leftRef->getRefSubType() == Ref::RefSubType::SYNONYM)
    {
        if (declarationsMap.count(leftRef->getValue()) == 0)
        {
            throw SemanticError("Left Ref Synonym: " + leftRef->getValue() + " is not declared.");
        }

        // if its a synonym, means it is an UNDECIDED_REF, we can now decide the actual refType
        if (leftRef->getRefType() == Ref::RefType::UNDECIDED_REF)
        {
            leftRef->setRefType(designEntityTypeToRefTypeMap[declarationsMap[leftRef->getValue()]]);
        }
    }

    if (rightRef->getRefSubType() == Ref::RefSubType::SYNONYM)
    {
        if (declarationsMap.count(rightRef->getValue()) == 0)
        {
            throw SemanticError("Right Ref Synonym: " + rightRef->getValue() + " is not declared.");
        }

        // if its a synonym, means it is an UNDECIDED_REF, we can now decide the actual refType
        if (rightRef->getRefType() == Ref::RefType::UNDECIDED_REF)
        {
            rightRef->setRefType(designEntityTypeToRefTypeMap[declarationsMap[rightRef->getValue()]]);
        }
    }
}

void QueryValidator::validateDualTypeSuchThatClause(SuchThatClause *suchThatClause, Ref *leftRef)
{
    if (suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::MODIFIES_UNDECIDED)
    {
        if (leftRef->getRefType() == Ref::RefType::ENT_REF)
        {
            suchThatClause->setSuchThatRelationship(SuchThatClause::SuchThatRelationship::MODIFIES_P);
            suchThatClause->setParamType(SuchThatClause::ParamType::ENTITY_AND_ENTITY);
        }
        if (leftRef->getRefType() == Ref::RefType::STMT_REF)
        {
            suchThatClause->setSuchThatRelationship(SuchThatClause::SuchThatRelationship::MODIFIES_S);
            suchThatClause->setParamType(SuchThatClause::ParamType::STMT_AND_ENTITY);
        }
    }

    if (suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::USES_UNDECIDED)
    {
        if (leftRef->getRefType() == Ref::RefType::ENT_REF)
        {
            suchThatClause->setSuchThatRelationship(SuchThatClause::SuchThatRelationship::USES_P);
            suchThatClause->setParamType(SuchThatClause::ParamType::ENTITY_AND_ENTITY);
        }
        if (leftRef->getRefType() == Ref::RefType::STMT_REF)
        {
            suchThatClause->setSuchThatRelationship(SuchThatClause::SuchThatRelationship::USES_S);
            suchThatClause->setParamType(SuchThatClause::ParamType::STMT_AND_ENTITY);
        }
    }
}

void QueryValidator::validateSuchThatClauseParameterTypes(SuchThatClause *suchThatClause, Ref *leftRef, Ref *rightRef)
{
    // if either of the ref is a wildcard, skip the validation since they do not have a refType
    if (leftRef->getRefSubType() == Ref::RefSubType::WILDCARD || rightRef->getRefSubType() == Ref::RefSubType::WILDCARD)
    {
        return;
    }

    switch (suchThatClause->getParamType())
    {
    case SuchThatClause::ParamType::STMT_AND_STMT:
        if (leftRef->getRefType() != Ref::RefType::STMT_REF || rightRef->getRefType() != Ref::RefType::STMT_REF)
        {
            throw SemanticError("Expected parameters of the form (stmtRef, stmtRef) but got: " + leftRef->getValue() + " and " + rightRef->getValue() + " for SuchThatClause: " + suchThatClause->toString());
        }
        break;
    case SuchThatClause::ParamType::STMT_AND_ENTITY:
        if (leftRef->getRefType() != Ref::RefType::STMT_REF || rightRef->getRefType() != Ref::RefType::ENT_REF)
        {

            throw SemanticError("Expected parameters of the form (stmtRef, entRef) but got: " + leftRef->getValue() + " and " + rightRef->getValue() + " for SuchThatClause: " + suchThatClause->toString());
        }
        break;

    case SuchThatClause::ParamType::ENTITY_AND_ENTITY:
        if (leftRef->getRefType() != Ref::RefType::ENT_REF || rightRef->getRefType() != Ref::RefType::ENT_REF)
        {
            throw SemanticError("Expected parameters of the form (entRef, entRef) but got: " + leftRef->getValue() + " and " + rightRef->getValue() + " for SuchThatClause: " + suchThatClause->toString());
        }
        break;
    default:
        throw SemanticError("Error validating SuchThatClause ParamType");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/ClauseResultTableManager.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef CLAUSERESULTTABLEMANAGER_H
#define CLAUSERESULTTABLEMANAGER_H

#include <list>
#include <vector>
#include "ClauseResultTable.h"
#include <memory>

class ClauseResultTable;
class ClauseResultTableManager
{
public:
    void addUngroupedTable(const ClauseResultTable &table);
    void mergeTables(std::vector<ClauseResultTable> &tables);
    void generateFinalResultTable();
    std::shared_ptr<ClauseResultTable> getFinalResultTable();
    std::shared_ptr<ClauseResultTable> getUngroupedTable();
    void createGroup();
    void clearAllTables();
    bool isUngroupedTableEmpty();

private:
    std::vector<ClauseResultTable> ungroupedTables;
    std::vector<std::vector<ClauseResultTable>> groups;
    ClauseResultTable finalResultTable;

    ClauseResultTable mergeTwoTables(const ClauseResultTable &table1, const ClauseResultTable &table2);
    ClauseResultTable mergeGroupedTables(const std::vector<ClauseResultTable> &group);
    bool isJoinable(const std::vector<std::string> &row1, const std::vector<std::string> &row2,
                    const ClauseResultTable &table1, const ClauseResultTable &table2,
                    const std::unordered_set<std::string> &commonHeaders);
    std::vector<std::string> mergeRows(const std::vector<std::string> &row1,
                                       const std::vector<std::string> &row2,
                                       const ClauseResultTable &table1,
                                       const ClauseResultTable &table2,
                                       const std::unordered_set<std::string> &commonHeaders);
    std::vector<std::string> crossJoinRows(const std::vector<std::string> &row1,
                                           const std::vector<std::string> &row2);
    ClauseResultTable mergeTwoTablesWithOneHeader(const ClauseResultTable &table1, const ClauseResultTable &table2);
};

#endif // CLAUSERESULTTABLEMANAGER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/AbstractQuery.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "AbstractQuery.h"

AbstractQuery::AbstractQuery()
{
    declarations = std::vector<Declaration>();
    selectProjections = std::vector<SelectProjection>();
    suchThatClauses = std::vector<SuchThatClause *>();
    patternClauses = std::vector<PatternClause *>();
}

// AbstractQuery::~AbstractQuery()
// {
//     for (auto &suchThatClause : suchThatClauses)
//     {
//         delete suchThatClause;
//     }
//     for (auto &patternClause : patternClauses)
//     {
//         delete patternClause;
//     }
// }

void AbstractQuery::addDeclaration(std::string entityType, std::string synonym)
{
    declarations.push_back(Declaration(entityType, synonym));
}

void AbstractQuery::addSelectProjectionSynonym(std::string synonym)
{
    selectProjectionSynonyms.push_back(synonym);
}

void AbstractQuery::addSuchThatClause(std::string relationshipType, Ref leftRef, Ref rightRef)
{
    SuchThatClause *suchThatClause = ClauseFactory::createSuchThatClause(relationshipType, leftRef, rightRef);
    suchThatClauses.push_back(suchThatClause);
}

void AbstractQuery::addPatternClause(std::string patternType, std::string synonym, Ref leftRef, ExpressionSpec expressionSpec)
{
    PatternClause *patternClause = ClauseFactory::createPatternClause(patternType, synonym, leftRef, expressionSpec);
    patternClauses.push_back(patternClause);
}

void AbstractQuery::addPatternClauseParameters(std::string synonym, Ref leftRef, ExpressionSpec expressionSpec)
{
    patternClauseParameters.push_back(std::make_tuple(synonym, leftRef, expressionSpec));
}

void AbstractQuery::addSelectProjection(SelectProjection selectProjection)
{
    selectProjections.push_back(selectProjection);
}

std::vector<Declaration> AbstractQuery::getDeclarations()
{
    return declarations;
}

std::vector<SelectProjection> AbstractQuery::getSelectProjections()
{
    return selectProjections;
}

std::vector<std::string> AbstractQuery::getSelectProjectionSynonyms()
{
    return selectProjectionSynonyms;
}

std::vector<SuchThatClause *> AbstractQuery::getSuchThatClauses()
{
    return suchThatClauses;
}

std::vector<PatternClause *> AbstractQuery::getPatternClauses()
{
    return patternClauses;
}

std::vector<std::tuple<std::string, Ref, ExpressionSpec>> AbstractQuery::getPatternClauseParameters()
{
    return patternClauseParameters;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/References/Ref.h
Generator: gpt
Intervention: 2
Language: e
Prompt: https://platform.openai.com/playground/p/Rj5IIfkACKYzHaOb7vCeR4xH?model=gpt-4&mode=chat
ChatId: Rj5IIfkACKYzHaOb7vCeR4xH
Code:
#ifndef QPS_ABSTRACTQUERY_REFERENCES_REF_H_
#define QPS_ABSTRACTQUERY_REFERENCES_REF_H_

#include <string>

// Abstract base class for a reference
class Ref
{

public:
    enum class RefType
    {
        STMT_REF,
        ENT_REF,
        UNDECIDED_REF // for the case of synonyms and wildcard as it can be either STMT_REF or ENT_REF until QueryValidator checks the declaration
    };

    enum class RefSubType
    {
        INTEGER,
        NAME, //ident
        SYNONYM,
        WILDCARD
    };

    Ref(RefType refType, RefSubType RefSubType, std::string value);
    std::string getValue() const;
    RefType getRefType() const;
    RefSubType getRefSubType() const;
    void setRefType(RefType refType); // For QueryValidator to set the refType of a synonym and wildcard after checking declaration

private:
    RefType refType;
    RefSubType refSubType;
    std::string value;
};

#endif // QPS_ABSTRACTQUERY_REFERENCES_REF_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/SelectProjection.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "SelectProjection.h"

SelectProjection::SelectProjection(DesignEntityType type, Synonym synonym) : type(type), synonym(synonym) {}
SelectProjection::SelectProjection(std::string typeString, std::string synonymString) : type(getDesignEntityTypeFromString(typeString)), synonym(Synonym(synonymString)) {}

DesignEntityType SelectProjection::getDesignEntityType() const
{
    return this->type;
}

Synonym SelectProjection::getSynonym() const
{
    return this->synonym;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/ClauseFactory.h
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/aIXnc3WUsrRpCjljinhn8ZEC?model=gpt-4&mode=chat
ChatId: aIXnc3WUsrRpCjljinhn8ZEC
Code:
#ifndef QPS_ABSTRACTQUERY_CLAUSEFACTORY_H_
#define QPS_ABSTRACTQUERY_CLAUSEFACTORY_H_

#include "Clauses/SuchThatClauses/ConcreteClauses/ParentClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/ParentTClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/FollowsClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/FollowsTClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/ModifiesPClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/ModifiesSClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/ModifiesUndecidedClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/UsesPClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/UsesSClause.h"
#include "Clauses/SuchThatClauses/ConcreteClauses/UsesUndecidedClause.h"
#include "Clauses/PatternClauses/ConcreteClauses/AssignPatternClause.h"
#include "References/Ref.h"
#include "Expression/ExpressionSpec.h"

class ClauseFactory
{
public:
    static SuchThatClause *createSuchThatClause(std::string relationType, Ref leftRef, Ref rightRef);
    static PatternClause *createPatternClause(std::string patternType, std::string synonym, Ref leftRef, ExpressionSpec expressionSpec);
};
#endif // QPS_ABSTRACTQUERY_CLAUSEFACTORY_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Synonym.h
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/Rj5IIfkACKYzHaOb7vCeR4xH?model=gpt-4&mode=chat
ChatId: Rj5IIfkACKYzHaOb7vCeR4xH
Code:
#ifndef SYNONYM_H
#define SYNONYM_H

#include <string>

class Synonym
{
protected:
    std::string name;

public:
    Synonym(std::string name);
    std::string getName() const;
    // Additional methods as necessary
};

#endif // SYNONYM_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Declaration.h
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/Rj5IIfkACKYzHaOb7vCeR4xH?model=gpt-4&mode=chat
ChatId: Rj5IIfkACKYzHaOb7vCeR4xH
Code:
#ifndef QPS_QPSPARSER_DECLARATION_H_
#define QPS_QPSPARSER_DECLARATION_H_
#include <string>
#include "DesignEntityType.h"
#include "Synonym.h"

class Declaration
{
private:
    DesignEntityType entityType;
    Synonym synonym;

public:
    // Supports different constructors for flexibility as not sure which version QPSParser will use
    Declaration(DesignEntityType type, Synonym synonym);
    Declaration(std::string typeString, std::string synonymString);

    DesignEntityType getDesignEntityType() const;
    Synonym getSynonym() const;
};

#endif // QPS_QPSPARSER_DECLARATION_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Declaration.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "Declaration.h"

Declaration::Declaration(DesignEntityType type, Synonym synonym) : entityType(type), synonym(synonym) {}
Declaration::Declaration(std::string typeString, std::string synonymString) : entityType(getDesignEntityTypeFromString(typeString)), synonym(Synonym(synonymString)) {}

DesignEntityType Declaration::getDesignEntityType() const
{
    return this->entityType;
}

Synonym Declaration::getSynonym() const
{
    return this->synonym;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/UsesPClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "UsesPClause.h"

UsesPClause::UsesPClause(Ref leftRef, Ref rightRef) : EntityAndEntityClause(leftRef, rightRef, SuchThatRelationship::USES_P) {}

std::string UsesPClause::toString() const
{
    return "UsesP(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/FollowsTClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "FollowsTClause.h"

FollowsTClause::FollowsTClause(Ref leftRef, Ref rightRef) : StmtAndStmtClause(leftRef, rightRef, SuchThatRelationship::FOLLOWS_T) {}

std::string FollowsTClause::toString() const
{
    return "FollowsT(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/ModifiesPClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ModifiesPClause.h"

ModifiesPClause::ModifiesPClause(Ref leftRef, Ref rightRef) : EntityAndEntityClause(leftRef, rightRef, SuchThatRelationship::MODIFIES_P) {}

std::string ModifiesPClause::toString() const
{
    return "ModifiesP(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/ParentTClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ParentTClause.h"

ParentTClause::ParentTClause(Ref leftRef, Ref rightRef) : StmtAndStmtClause(leftRef, rightRef, SuchThatRelationship::PARENT_T) {}

std::string ParentTClause::toString() const
{
    return "ParentT(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/ParentClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ParentClause.h"

ParentClause::ParentClause(Ref leftRef, Ref rightRef) : StmtAndStmtClause(leftRef, rightRef, SuchThatRelationship::PARENT) {}

std::string ParentClause::toString() const
{
    return "Parent(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/ModifiesSClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ModifiesSClause.h"

ModifiesSClause::ModifiesSClause(Ref leftRef, Ref rightRef) : StmtAndEntityClause(leftRef, rightRef, SuchThatRelationship::MODIFIES_S) {}

std::string ModifiesSClause::toString() const
{
    return "ModifiesS(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/FollowsClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "FollowsClause.h"

FollowsClause::FollowsClause(Ref leftRef, Ref rightRef) : StmtAndStmtClause(leftRef, rightRef, SuchThatRelationship::FOLLOWS) {}

std::string FollowsClause::toString() const
{
    return "Follows(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/UsesSClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "UsesSClause.h"

UsesSClause::UsesSClause(Ref leftRef, Ref rightRef) : StmtAndEntityClause(leftRef, rightRef, SuchThatRelationship::USES_S) {}

std::string UsesSClause::toString() const
{
    return "UsesS(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/ModifiesUndecidedClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ModifiesUndecidedClause.h"

ModifiesUndecidedClause::ModifiesUndecidedClause(Ref leftRef, Ref rightRef) : DualTypeClause(leftRef, rightRef, SuchThatRelationship::MODIFIES_UNDECIDED) {}

std::string ModifiesUndecidedClause::toString() const
{
    return "Modifies(" + leftRef.getValue() + ", " + rightRef.getValue() + ")";
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/DesignEntityType.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/Rj5IIfkACKYzHaOb7vCeR4xH?model=gpt-4&mode=chat
ChatId: Rj5IIfkACKYzHaOb7vCeR4xH
Code:
#include "DesignEntityType.h"
#include <stdexcept>

std::string getDesignEntityStringFromType(DesignEntityType type)
{
    switch (type)
    {
    case DesignEntityType::ASSIGN:
        return "assign";
    case DesignEntityType::VARIABLE:
        return "variable";
    case DesignEntityType::CALL:
        return "call";
    case DesignEntityType::CONSTANT:
        return "constant";
    case DesignEntityType::IF:
        return "if";
    case DesignEntityType::PRINT:
        return "print";
    case DesignEntityType::PROCEDURE:
        return "procedure";
    case DesignEntityType::READ:
        return "read";
    case DesignEntityType::STMT:
        return "stmt";
    case DesignEntityType::WHILE:
        return "while";

    // should not be possible, but just in case
    default:
        throw std::invalid_argument("Given Design Entity type is not supported.");
    }
}

DesignEntityType getDesignEntityTypeFromString(std::string name)
{
    if (name == "assign")
        return DesignEntityType::ASSIGN;
    if (name == "variable")
        return DesignEntityType::VARIABLE;
    if (name == "call")
        return DesignEntityType::CALL;
    if (name == "constant")
        return DesignEntityType::CONSTANT;
    if (name == "if")
        return DesignEntityType::IF;
    if (name == "print")
        return DesignEntityType::PRINT;
    if (name == "procedure")
        return DesignEntityType::PROCEDURE;
    if (name == "read")
        return DesignEntityType::READ;
    if (name == "stmt")
        return DesignEntityType::STMT;
    if (name == "while")
        return DesignEntityType::WHILE;

    // Handle more cases as necessary
    throw std::invalid_argument("Given Design Entity: " + name + " is not supported.");
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/DesignEntityType.h
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/Rj5IIfkACKYzHaOb7vCeR4xH?model=gpt-4&mode=chat
ChatId: Rj5IIfkACKYzHaOb7vCeR4xH
Code:
#ifndef QPS_ABSTRACTQUERY_DESIGNENTITY_H_
#define QPS_ABSTRACTQUERY_DESIGNENTITY_H_

#include <string>

enum class DesignEntityType
{
    ASSIGN,
    CALL,
    CONSTANT,
    IF,
    PRINT,
    PROCEDURE,
    READ,
    STMT,
    VARIABLE,
    WHILE
};

DesignEntityType getDesignEntityTypeFromString(std::string name);

std::string getDesignEntityStringFromType(DesignEntityType type);

#endif // QPS_ABSTRACTQUERY_DESIGNENTITY_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/Synonym.cpp
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "Synonym.h"

Synonym::Synonym(std::string name) : name(name) {}

std::string Synonym::getName() const
{
    return this->name;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/SelectProjection.h
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/Rj5IIfkACKYzHaOb7vCeR4xH?model=gpt-4&mode=chat
ChatId: Rj5IIfkACKYzHaOb7vCeR4xH
Code:
#ifndef QPS_ABSTRACTQUERY_SELECTPROJECTION_H_
#define QPS_ABSTRACTQUERY_SELECTPROJECTION_H_

#include "DesignEntityType.h"
#include "Synonym.h"
#include <string>

// This class will be populated only DURING VALIDATION, since the parser would now know the type of the synonym
class SelectProjection
{
private:
    DesignEntityType type;
    Synonym synonym;

public:
    SelectProjection(DesignEntityType type, Synonym synonym);
    SelectProjection(std::string typeString, std::string synonymString);

    DesignEntityType getDesignEntityType() const;
    Synonym getSynonym() const;
};

// TODO: in the future milestones, Select can select a boolean or tuple or others, so need to support it

#endif // QPS_ABSTRACTQUERY_SELECTPROJECTION_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/AbstractQuery/ClauseFactory.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ClauseFactory.h"

SuchThatClause *ClauseFactory::createSuchThatClause(std::string relationshipType, Ref leftRef, Ref rightRef)
{
    if (relationshipType == "Parent")
    {
        return new ParentClause(leftRef, rightRef);
    }
    else if (relationshipType == "Parent*")
    {
        return new ParentTClause(leftRef, rightRef);
    }
    else if (relationshipType == "Follows")
    {
        return new FollowsClause(leftRef, rightRef);
    }
    else if (relationshipType == "Follows*")
    {
        return new FollowsTClause(leftRef, rightRef);
    }
    else if (relationshipType == "Modifies")
    {
        return new ModifiesUndecidedClause(leftRef, rightRef);
    }

    else if (relationshipType == "Uses")
    {
        return new UsesUndecidedClause(leftRef, rightRef);
    }

    else
    {
        throw "Invalid relation for clause factory";
    }
}

PatternClause *ClauseFactory::createPatternClause(std::string patternType, std::string synonym, Ref leftRef, ExpressionSpec expressionSpec)
{
    if (patternType == "assign")
    {
        return new AssignPatternClause(synonym, leftRef, expressionSpec);
    }
    else
    {
        throw "Invalid pattern type for clause factory";
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/PatternProcessors/PatternProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PATTERN_CLAUSE_PROCESSOR_H
#define PATTERN_CLAUSE_PROCESSOR_H

#include "../QueryProcessorStrategy.h"
#include "QPS/AbstractQuery/References/Ref.h"
#include "QPS/AbstractQuery/Expression/ExpressionSpec.h"
#include "QPS/AbstractQuery/DesignEntityType.h"
#include "QPS/AbstractQuery/Declaration.h"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/ClauseResultTable.h"
#include "PKB/API/Retrieve.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/PatternDataRetrievers/PatternDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/EntityDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/AssignRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/CallRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ConstantRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/PrintRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ProcedureRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ReadRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/StatementRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/VariableRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/WhileRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/PatternDataRetrievers/PatternDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/PatternDataRetrievers/AssignPatternRetriever.h"

class Ref;
class PKB;
class ClauseResultTableManager;
class EntityDataRetriever;
class PatternDataRetriever;
class Declaration;
enum class DesignEntityType;
class PatternProcessor : public QueryProcessorStrategy
{
public:
    PatternProcessor(Ref leftRef, ExpressionSpec expressionSpec);
    bool processQuery(std::shared_ptr<ClauseResultTableManager> clauseResultTableManager, std::shared_ptr<Retrieve> retrieveInterfacePtr, std::vector<Declaration> declarations) override;
    virtual std::shared_ptr<PatternDataRetriever> createPatternRetriever() = 0;

private:
    Ref leftRef;
    ExpressionSpec expressionSpec;
    bool evaluateBooleanQuery(std::shared_ptr<Retrieve> retrieveInterfacePtr);
    std::unordered_set<std::string> getSynonymValues(std::shared_ptr<Retrieve> retrieveInterfacePtr, DesignEntityType entityType);
};
#endif // PATTERN_CLAUSE_PROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/PatternProcessors/AssignPatternProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef ASSIGNPATTERNPROCESSOR_H
#define ASSIGNPATTERNPROCESSOR_H

#include "PatternProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class AssignPatternRetriever;

class AssignPatternProcessor : public PatternProcessor
{
public:
    AssignPatternProcessor(Ref leftRef, ExpressionSpec expressionSpec);
    std::shared_ptr<PatternDataRetriever> createPatternRetriever() override;
};

#endif // ASSIGNPATTERNPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/QueryProcessorStrategy.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef QUERY_PROCESSOR_STRATEGY_H
#define QUERY_PROCESSOR_STRATEGY_H

#include <list>
#include <memory>
#include <string>
#include <unordered_set>
#include "PKB/API/Retrieve.h"

class ClauseResultTable;
class ClauseResultTableManager;

class PKB;
class AbstractQuery;
class Declaration;

class QueryProcessorStrategy
{
public:
    virtual ~QueryProcessorStrategy() = default;
    virtual bool processQuery(std::shared_ptr<ClauseResultTableManager> clauseResultTableManager, std::shared_ptr<Retrieve> retrieveInterfacePtr, std::vector<Declaration> declarations) = 0;
};

#endif // QUERY_PROCESSOR_STRATEGY_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/ModifiesPClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef MODIFIESPCLAUSEPROCESSOR_H
#define MODIFIESPCLAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class ModifiesPRetriever;

class ModifiesPClauseProcessor : public SuchThatClauseProcessor
{
public:
    ModifiesPClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // MODIFIESPCLAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/UsesSClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef USESSCLAUSEPROCESSOR_H
#define USESSCLAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class UsesSRetriever;

class UsesSClauseProcessor : public SuchThatClauseProcessor
{
public:
    UsesSClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // USESSCLAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/FollowsClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef FOLLOWSCLAUSEPROCESSOR_H
#define FOLLOWSCLAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class FollowsRetriever;

class FollowsClauseProcessor : public SuchThatClauseProcessor
{
public:
    FollowsClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // FOLLOWSCLAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/ParentClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PARENTCLAUSEPROCESSOR_H
#define PARENTCLAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class ParentRetriever;

class ParentClauseProcessor : public SuchThatClauseProcessor
{
public:
    ParentClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // PARENTCLAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/SuchThatClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SUCH_THAT_CLAUSE_PROCESSOR_H
#define SUCH_THAT_CLAUSE_PROCESSOR_H

#include "../QueryProcessorStrategy.h"
#include "QPS/AbstractQuery/References/Ref.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/RelationshipDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/EntityDataRetriever.h"
#include "PKB/PKB.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/AssignRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/CallRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ConstantRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/PrintRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ProcedureRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ReadRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/StatementRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/VariableRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/WhileRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ParentRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ParentTRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/FollowsRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/FollowsTRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/UsesSRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/UsesPRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ModifiesSRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ModifiesPRetriever.h"
#include "QPS/AbstractQuery/DesignEntityType.h"
#include "QPS/AbstractQuery/Declaration.h"
#include "QPS/ClauseResultTableManager.h"
#include "PKB/API/Retrieve.h"

class Ref;
class PKB;
class ClauseResultTableManager;
class EntityDataRetriever;
class RelationshipDataRetriever;
class Declaration;
enum class DesignEntityType;

class SuchThatClauseProcessor : public QueryProcessorStrategy
{
public:
    SuchThatClauseProcessor(Ref leftRef, Ref rightRef);
    bool processQuery(std::shared_ptr<ClauseResultTableManager> clauseResultTableManager, std::shared_ptr<Retrieve> retrieveInterfacePtr, std::vector<Declaration> declarations) override;
    virtual std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() = 0;

private:
    Ref leftRef;
    Ref rightRef;
    bool evaluateBooleanQuery(std::shared_ptr<Retrieve> retrieveInterfacePtr);
    std::unordered_set<std::string> getSynonymValues(std::shared_ptr<Retrieve> retrieveInterfacePtr, DesignEntityType entityType);
};

#endif // SUCH_THAT_CLAUSE_PROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/FollowsTClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef FOLLOWSTCLAUSEPROCESSOR_H
#define FOLLOWSTCLAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class FollowsTRetriever;

class FollowsTClauseProcessor : public SuchThatClauseProcessor
{
public:
    FollowsTClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // FOLLOWSTCLAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/ParentTClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PARENTTCLAUSEPROCESSOR_H
#define PARENTTCLAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class ParentTRetriever;

class ParentTClauseProcessor : public SuchThatClauseProcessor
{
public:
    ParentTClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // PARENTTCLAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/ModifiesSClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef MODIFIESSClAUSEPROCESSOR_H
#define MODIFIESSClAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class ModifiesSRetriever;

class ModifiesSClauseProcessor : public SuchThatClauseProcessor
{
public:
    ModifiesSClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // MODIFIESSClAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SuchThatProcessors/UsesPClauseProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef USESPCLAUSEPROCESSOR_H
#define USESPCLAUSEPROCESSOR_H

#include "SuchThatClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"

class PKB;
class Ref;
class ClauseResultTableManager;
class UsesPRetriever;

class UsesPClauseProcessor : public SuchThatClauseProcessor
{
public:
    UsesPClauseProcessor(Ref leftRef, Ref rightRef);
    std::shared_ptr<RelationshipDataRetriever> createRelationshipRetriever() override;
};

#endif // USESPCLAUSEPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/Processors/SelectProcessors/SelectProjectionProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SELECT_PROJECTION_PROCESSOR_H
#define SELECT_PROJECTION_PROCESSOR_H

#include "../QueryProcessorStrategy.h"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/EntityDataRetriever.h"
#include "QPS/AbstractQuery/Declaration.h"
#include "PKB/PKB.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/AssignRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/CallRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ConstantRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/PrintRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ProcedureRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ReadRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/StatementRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/VariableRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/WhileRetriever.h"

class Declaration;
class PKB;
class EntityDataRetriever;
enum class DesignEntityType;

class SelectProjectionProcessor : public QueryProcessorStrategy
{
public:
    SelectProjectionProcessor(std::string selectProjectionValue);
    bool processQuery(std::shared_ptr<ClauseResultTableManager> clauseResultTableManager, std::shared_ptr<Retrieve> retrieveInterfacePtr, std::vector<Declaration> declarations) override;
    virtual std::shared_ptr<EntityDataRetriever> createEntityRetriever() = 0;

private:
    std::string selectProjectionValue;
};

#endif // SELECT_PROJECTION_PROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/QueryProcessor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef QUERYPROCESSOR_H
#define QUERYPROCESSOR_H

#include "QPS/AbstractQuery/DesignEntityType.h"
#include "QPS/QueryProcessors/Processors/QueryProcessorStrategy.h"
#include <list>
#include <memory>
#include <string>
#include "QPS/AbstractQuery/References/Ref.h"
#include "QPS/AbstractQuery/Clauses/SuchThatClauses/SuchThatClause.h"
#include "PKB/PKB.h"
#include "../ClauseResultTable.h"
#include "QPS/AbstractQuery/AbstractQuery.h"
#include "../AbstractQuery/Clauses/SuchThatClauses/SuchThatClause.h"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ParentClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/FollowsClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/FollowsTClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ParentClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ParentTClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/UsesPClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/UsesSClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ModifiesPClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ModifiesSClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/AssignEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/CallEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/ConstantEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/IfEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/PrintEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/ProcedureEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/ReadEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/StatementEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/VariableEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/SelectProcessors/WhileEntityProcessor.h"
#include "QPS/QueryProcessors/Processors/PatternProcessors/AssignPatternProcessor.h"
#include "QPS/QueryProcessors/ClauseResultTableEvaluator.h"
#include "PKB/API/Retrieve.h"

class ClauseResultTable;
class ClauseResultTableManager;
class Query;
class SuchThatClause;
class PKB;
enum class SuchThatRelationship;

class QueryProcessor
{
public:
    QueryProcessor();
    void processQuery(std::list<std::string> &results, std::shared_ptr<ClauseResultTableManager> clauseResultTableManager,
                      std::shared_ptr<AbstractQuery> AbstractQuery, std::shared_ptr<Retrieve> retrieveInterfacePtr);

private:
    std::unique_ptr<QueryProcessorStrategy> strategy;
    void setSuchThatClauseStrategy(SuchThatClause::SuchThatRelationship suchThatType, Ref leftRef, Ref rightRef);
    void setPatternStrategy(DesignEntityType entityType, Ref leftRef, ExpressionSpec expressionSpec);
    void setSelectProjectionStrategy(DesignEntityType entityType, std::string selectProjectionValue);
};

#endif // QUERYPROCESSOR_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/QueryProcessor.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/trTu6onQe85Nz5XAO0LfcK7V?model=gpt-4&mode=chat
ChatId: trTu6onQe85Nz5XAO0LfcK7V
Code:
#include "QueryProcessor.h"

class Query;
class retrieveInterfacePtr;
class retrieveInterfacePtr;
class QueryProcessorStrategy;
class VariableQueryProcessor;
class ClauseResultTableManager;
class SelectProjection;
class SuchThatClause;
class PatternClause;
enum class SuchThatRelationship;

QueryProcessor::QueryProcessor() {}

void QueryProcessor::processQuery(std::list<std::string> &results, std::shared_ptr<ClauseResultTableManager> clauseResultTableManager,
                                  std::shared_ptr<AbstractQuery> AbstractQuery, std::shared_ptr<Retrieve> retrieveInterfacePtr)
{
    clauseResultTableManager->createGroup();
    std::vector<Declaration> declarations = AbstractQuery->getDeclarations();
    std::vector<SelectProjection> querySelectProjections = AbstractQuery->getSelectProjections();
    std::vector<SuchThatClause *> querySuchThatClauses = AbstractQuery->getSuchThatClauses();
    std::vector<PatternClause *> queryPatternClauses = AbstractQuery->getPatternClauses();

    for (auto querySuchThatClause : querySuchThatClauses)
    {
        // To be updated with SuchThatClause's entityType
        setSuchThatClauseStrategy(querySuchThatClause->getSuchThatRelationship(), querySuchThatClause->getLeftRef(), querySuchThatClause->getRightRef());
        bool retrieveInterfacePtrData = strategy->processQuery(clauseResultTableManager, retrieveInterfacePtr, declarations);
        // If retrieveInterfacePtrData is empty, means the query was invalid, clear results and return
        if (!retrieveInterfacePtrData)
        {
            results.clear();
            return;
        }
    }

    for (auto queryPatternClause : queryPatternClauses)
    {
        setPatternStrategy(queryPatternClause->getSynonymDesignEntityType(), queryPatternClause->getLeftRef(), queryPatternClause->getExpressionSpec());
        bool retrieveInterfacePtrData = strategy->processQuery(clauseResultTableManager, retrieveInterfacePtr, declarations);
        // If retrieveInterfacePtrData is empty, means the query was invalid, clear results and return
        if (!retrieveInterfacePtrData)
        {
            results.clear();
            return;
        }
    }

    for (auto querySelectProjection : querySelectProjections)
    {
        setSelectProjectionStrategy(querySelectProjection.getDesignEntityType(), querySelectProjection.getSynonym().getName());
        bool retrieveInterfacePtrData = strategy->processQuery(clauseResultTableManager, retrieveInterfacePtr, declarations);
        // If retrieveInterfacePtrData is empty, means the query was invalid, clear results and return
        if (!retrieveInterfacePtrData)
        {
            results.clear();
            return;
        }
    }

    ClauseResultTableEvaluator evaluator = ClauseResultTableEvaluator();
    std::vector<std::string> selectProjectionSynonyms;
    for (const auto &querySelectProjection : querySelectProjections)
    {
        std::string name = querySelectProjection.getSynonym().getName();
        selectProjectionSynonyms.push_back(name);
    }
    // Return the results
    evaluator.evaluateQuery(results, clauseResultTableManager, selectProjectionSynonyms);
}

void QueryProcessor::setSuchThatClauseStrategy(SuchThatClause::SuchThatRelationship suchThatType, Ref leftRef, Ref rightRef)
{
    switch (suchThatType)
    {
    case SuchThatClause::SuchThatRelationship::PARENT:
        strategy = std::make_unique<ParentClauseProcessor>(leftRef, rightRef);
        break;
    case SuchThatClause::SuchThatRelationship::PARENT_T:
        strategy = std::make_unique<ParentTClauseProcessor>(leftRef, rightRef);
        break;
    case SuchThatClause::SuchThatRelationship::FOLLOWS:
        strategy = std::make_unique<FollowsClauseProcessor>(leftRef, rightRef);
        break;
    case SuchThatClause::SuchThatRelationship::FOLLOWS_T:
        strategy = std::make_unique<FollowsTClauseProcessor>(leftRef, rightRef);
        break;
    case SuchThatClause::SuchThatRelationship::USES_S:
        strategy = std::make_unique<UsesSClauseProcessor>(leftRef, rightRef);
        break;
    case SuchThatClause::SuchThatRelationship::USES_P:
        strategy = std::make_unique<UsesPClauseProcessor>(leftRef, rightRef);
        break;
    case SuchThatClause::SuchThatRelationship::MODIFIES_S:
        strategy = std::make_unique<ModifiesSClauseProcessor>(leftRef, rightRef);
        break;
    case SuchThatClause::SuchThatRelationship::MODIFIES_P:
        strategy = std::make_unique<ModifiesPClauseProcessor>(leftRef, rightRef);
        break;
    default:
        throw std::invalid_argument("Invalid entity type found");
    }
}

void QueryProcessor::setPatternStrategy(DesignEntityType entityType, Ref leftRef, ExpressionSpec expressionSpec)
{
    switch (entityType)
    {
    case DesignEntityType::ASSIGN:
        strategy = std::make_unique<AssignPatternProcessor>(leftRef, expressionSpec);
        break;
    default:
        throw std::invalid_argument("Invalid entity type found");
    }
}

void QueryProcessor::setSelectProjectionStrategy(DesignEntityType entityType, std::string selectProjectionValue)
{
    switch (entityType)
    {
    case DesignEntityType::ASSIGN:
        strategy = std::make_unique<AssignEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::CALL:
        strategy = std::make_unique<CallEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::CONSTANT:
        strategy = std::make_unique<ConstantEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::IF:
        strategy = std::make_unique<IfEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::PRINT:
        strategy = std::make_unique<PrintEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::PROCEDURE:
        strategy = std::make_unique<ProcedureEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::READ:
        strategy = std::make_unique<ReadEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::STMT:
        strategy = std::make_unique<StatementEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::VARIABLE:
        strategy = std::make_unique<VariableEntityProcessor>(selectProjectionValue);
        break;
    case DesignEntityType::WHILE:
        strategy = std::make_unique<WhileEntityProcessor>(selectProjectionValue);
        break;
    default:
        throw std::invalid_argument("Invalid entity type found");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/PatternDataRetrievers/PatternDataRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PATTERN_DATA_RETRIEVER_H
#define PATTERN_DATA_RETRIEVER_H

#include <memory>
#include <unordered_map>
#include <unordered_set>
#include "PKB/API/Retrieve.h"

class ClauseResultTable;
class PKB;

class PatternDataRetriever
{
public:
    virtual ~PatternDataRetriever() = default;
    virtual std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) = 0;
    virtual std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) = 0;
};

#endif // PATTERN_DATA_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/PatternDataRetrievers/AssignPatternRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef ASSIGN_PATTERN_RETRIEVER_H
#define ASSIGN_PATTERN_RETRIEVER_H

#include "PatternDataRetriever.h"
#include "PKB/API/Retrieve.h"
#include "PKB/PKB.h"

class PatternStarRelationship;
class PKB;

class AssignPatternRetriever : public PatternDataRetriever
{
public:
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // ASSIGN_PATTERN_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/RelationshipDataRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef RELATIONSHIP_DATA_RETRIEVER_H
#define RELATIONSHIP_DATA_RETRIEVER_H

#include <memory>
#include <unordered_map>
#include <unordered_set>
#include "PKB/API/Retrieve.h"

class ClauseResultTable;
class PKB;

class RelationshipDataRetriever
{
public:
    virtual ~RelationshipDataRetriever() = default;
    virtual std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) = 0;
    virtual std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) = 0;
    virtual std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) = 0;
};

#endif // RELATIONSHIP_DATA_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/UsesPRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef USES_P_RETRIEVER_H
#define USES_P_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"

class ParentRelationship;
class PKB;

class UsesPRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // USES_P_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ModifiesPRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef MODIFIES_P_RETRIEVER_H
#define MODIFIES_P_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"
#include "PKB/API/Retrieve.h"

class ParentRelationship;
class PKB;

class ModifiesPRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // MODIFIES_P_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ModifiesSRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef MODIFIES_S_RETRIEVER_H
#define MODIFIES_S_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"

class ParentRelationship;
class PKB;

class ModifiesSRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // MODIFIES_S_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/FollowsTRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef FOLLOWS_T_RETRIEVER_H
#define FOLLOWS_T_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"

class FollowsTRelationship;
class PKB;

class FollowsTRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // FOLLOWS_T_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/UsesSRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef USES_S_RETRIEVER_H
#define USES_S_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"

class ParentRelationship;
class PKB;

class UsesSRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // USES_S_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ParentTRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PARENT_T_RETRIEVER_H
#define PARENT_T_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"

class ParentStarRelationship;
class PKB;

class ParentTRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // PARENT_T_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ParentRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PARENT_TABLE_RETRIEVER_H
#define PARENT_TABLE_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"

class ParentRelationship;
class PKB;

class ParentRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // PARENT_TABLE_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/FollowsRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef FOLLOWS_TABLE_RETRIEVER_H
#define FOLLOWS_TABLE_RETRIEVER_H

#include "RelationshipDataRetriever.h"
#include "PKB/PKB.h"

class FollowsRelationship;
class PKB;

class FollowsRetriever : public RelationshipDataRetriever
{
public:
    std::unordered_map<std::string, std::unordered_set<std::string>> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
    std::unordered_set<std::string> retrieveData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
    std::unordered_set<std::string> retrieveInverseData(std::shared_ptr<Retrieve> retrieveInterfacePtr, std::string key) override;
};

#endif // FOLLOWS_TABLE_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/AssignRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef ASSIGNRETRIEVER_H
#define ASSIGNRETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"
#include "PKB/API/Retrieve.h"

class AssignEntity;
class PKB;

class AssignRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // ASSIGNRETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ProcedureRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PROCEDURERETRIEVER_H
#define PROCEDURERETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class ProcedureEntity;
class PKB;

class ProcedureRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // PROCEDURERETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/StatementRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef STATEMENTRETRIEVER_H
#define STATEMENTRETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class StatementEntity;
class PKB;

class StatementRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // STATEMENTRETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/EntityDataRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef ENTITY_DATA_RETRIEVER_H
#define ENTITY_DATA_RETRIEVER_H

#include <memory>
#include <unordered_set>
#include "PKB/API/Retrieve.h"

class ClauseResultTable;
class AbstractQuery;
class PKB;

class EntityDataRetriever
{
public:
    virtual ~EntityDataRetriever() = default;
    virtual std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) = 0;
};

#endif // ENTITY_DATA_RETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ReadRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef READRETRIEVER_H
#define READRETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class ReadEntity;
class PKB;

class ReadRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // ASSIGNRETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/WhileRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef WHILERETRIEVER_H
#define WHILERETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class WhileEntity;
class PKB;

class WhileRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // WHILERETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/PrintRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef PRINTRETRIEVER_H
#define PRINTRETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class PrintEntity;
class PKB;

class PrintRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // PRINTRETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/CallRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef CALLRETRIEVER_H
#define CALLRETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/API/Retrieve.h"
#include "PKB/PKB.h"

class CallEntity;
class PKB;

class CallRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // CALLRETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ConstantRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef CONSTANTRETRIEVER_H
#define CONSTANTRETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class ConstantEntity;
class PKB;

class ConstantRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // CONSTANTRETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef IFRETRIEVER_H
#define IFRETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class IfEntity;
class PKB;

class IfRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // IFRETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/VariableRetriever.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef VARIABLERETRIEVER_H
#define VARIABLERETRIEVER_H

#include "EntityDataRetriever.h"
#include "PKB/PKB.h"

class VariableEntity;
class PKB;

class VariableRetriever : public EntityDataRetriever
{
public:
    std::unordered_set<std::string> retrieveTable(std::shared_ptr<Retrieve> retrieveInterfacePtr) override;
};

#endif // VARIABLERETRIEVER_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/QPS/ClauseResultTable.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ClauseResultTable.h"

ClauseResultTable::ClauseResultTable() = default;

void ClauseResultTable::addHeaders(const std::vector<std::string> &synonyms)
{
    headers = synonyms;
}

void ClauseResultTable::addHeader(const std::string &synonym)
{
    headers.push_back(synonym);
}

void ClauseResultTable::addRow(const std::vector<std::string> &row)
{
    rows.push_back(row);
}

std::vector<std::string> ClauseResultTable::getColumn(const std::string &synonym)
{
    std::vector<std::string> column;
    int columnIndex = getSymnoymIndex(synonym);
    if (columnIndex >= 0)
    {
        for (const auto &row : rows)
        {
            column.push_back(row[columnIndex]);
        }
    }
    return column;
}

std::vector<std::string> ClauseResultTable::getHeaders() const
{
    return headers;
}

std::vector<std::vector<std::string>> ClauseResultTable::getRows() const
{
    return rows;
}

std::vector<std::string> ClauseResultTable::getRow(int index) const
{
    if (index >= 0 && index < rows.size())
    {
        return rows[index];
    }
    return std::vector<std::string>();
}

int ClauseResultTable::getRowCount() const
{
    return rows.size();
}

int ClauseResultTable::getSymnoymIndex(const std::string &synonym) const
{
    for (int i = 0; i < headers.size(); ++i)
    {
        if (headers[i] == synonym)
        {
            return i;
        }
    }
    return -1;
}

bool ClauseResultTable::isEmpty()
{
    return rows.empty();
}

void ClauseResultTable::deleteRow(int index)
{
    if (index >= 0 && index < rows.size())
    {
        rows.erase(rows.begin() + index);
    }
}

// Filter the columns based on the synonyms
void ClauseResultTable::filterColumns(std::vector<std::string> &synonyms)
{
    std::vector<std::string> newHeaders;
    std::vector<std::vector<std::string>> newRows;
    for (int i = 0; i < headers.size(); ++i)
    {
        if (std::find(synonyms.begin(), synonyms.end(), headers[i]) != synonyms.end())
        {
            newHeaders.push_back(headers[i]);
        }
    }
    for (const auto &row : rows)
    {
        std::vector<std::string> newRow;
        for (int i = 0; i < headers.size(); ++i)
        {
            if (std::find(synonyms.begin(), synonyms.end(), headers[i]) != synonyms.end())
            {
                newRow.push_back(row[i]);
            }
        }
        newRows.push_back(newRow);
    }
    headers = newHeaders;
    rows = newRows;
}

void ClauseResultTable::removeDuplicateRows()
{
    std::vector<std::vector<std::string>> newRows;
    for (const auto &row : rows)
    {
        if (std::find(newRows.begin(), newRows.end(), row) == newRows.end())
        {
            newRows.push_back(row);
        }
    }
    rows = newRows;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseIfStrategy.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/Wu4kTaJvoxrAGl1aMv0t4jMF?model=gpt-3.5-turbo&mode=chat
ChatId: Wu4kTaJvoxrAGl1aMv0t4jMF
Code:
#include "ParseIfStrategy.h"
#include "../../ErrorHandling/ParseError.h"
#include "../../ErrorHandling/SemanticError.h"
#include "../../Tokens/SPToken.h"
#include "../../Tokens/TokenType.h"
#include "../SPParser.h"
#include "ParseCondExprStrategy.h"
#include "ParseStmtLstStrategy.h"
#include "SP/AST/ASTNode.h"
#include "SP/AST/ASTNodeStmtLst.h"
#include "SP/AST/Expr/ASTNodeCondExpr.h"
#include "SP/AST/Stmt/ASTNodeIfStmt.h"
#include <Common/SPAConstants/SPAConstants.h>
#include <memory>
#include <stdexcept>

std::unique_ptr<ASTNode> ParseIfStrategy::parse(SPParser& parser) {
    auto ifNode = std::make_unique<ASTNodeIfStmt>(
        to_string(parser.getCurrentStmtNo())); // since if statements do have a statement number

    // Extract 'if' token
    SPToken ifToken = parser.extract();
    if (ifToken.GetType() != TokenType::IF) {
        throw SemanticError("Expected 'if' keyword", ".");
    }

    // Parse conditional expression in if block
    SPToken currentToken = parser.extract();

    // Check for '(' token
    if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::OpenRoundParenthesis)) {
        throw SemanticError("Expected '(' at start of condition", " and after an `if` keyword.");
    }

    parser.setStrategy(std::make_unique<ParseCondExprStrategy>());
    std::shared_ptr<ASTNode> condExpr = parser.parse();
    std::shared_ptr<ASTNodeCondExpr> derivedSharedCond = std::dynamic_pointer_cast<ASTNodeCondExpr>(condExpr);

    if (derivedSharedCond) {
        ifNode->setCondExpr(derivedSharedCond);
    } else {
        // Handle the case where the dynamic cast fails
        throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeCondExpr");
    }

    currentToken = parser.extract();

    // Check for ')' token
    if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::CloseRoundParenthesis)) {
        throw SemanticError("Expected '(' at start of condition", " and after an `if` keyword.");
    }

    currentToken = parser.extract();

    // Check for 'then' token
    if (currentToken.GetType() != TokenType::THEN) { // will integrate fine.
        throw SemanticError("Expected 'then' keyword after condition", ".");
    }

    currentToken = parser.extract();

    // Check for '{' token for the then block
    if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::OpenCurlyParenthesis)) {
        throw SemanticError("Expected '{' at start of then block", ".");
    }

    parser.incrementCurrentStmtNo(); // Start of statement list

    // Parse the statements in the then block
    parser.setStrategy(std::make_unique<ParseStmtLstStrategy>());
    std::shared_ptr<ASTNode> thenStmtLst = parser.parse();
    std::shared_ptr<ASTNodeStmtLst> thenStmtLstDerived = std::dynamic_pointer_cast<ASTNodeStmtLst>(thenStmtLst);

    if (thenStmtLstDerived) {
        ifNode->setThenStmtLst(thenStmtLstDerived);
    } else {
        // Handle the case where the dynamic cast fails
        throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeStmtLst");
    }

    currentToken = parser.extract();

    // Check for 'else' token for the else block
    if (currentToken.GetType() == TokenType::ELSE) { // will integrate ok
        currentToken = parser.extract();

        // Check for '{' token for the else block
        if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::OpenCurlyParenthesis)) {
            throw SemanticError("Expected '{' at start of else block", ".");
        }

        // Parse the statements in the else block
        parser.setStrategy(std::make_unique<ParseStmtLstStrategy>());
        std::shared_ptr<ASTNode> elseStmtLst = parser.parse();
        std::shared_ptr<ASTNodeStmtLst> elseStmtLstDerived = std::dynamic_pointer_cast<ASTNodeStmtLst>(elseStmtLst);

        if (elseStmtLstDerived) {
            ifNode->setElseStmtLst(elseStmtLstDerived);
        } else {
            // Handle the case where the dynamic cast fails
            throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeStmtLst");
        }
    }

    return ifNode;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseProcedureStrategy.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
std::unique_ptr<ASTNode> ParseProcedureStrategy::parse(SPParser& parser) {

    // Verify that the next token is a procedure token
    SPToken& procedureToken = parser.extract();
    if (procedureToken.GetType() != TokenType::PROCEDURE) {
        throw std::runtime_error("Expected procedure");
    }

    // Extract procedure name
    SPToken& procedureNameToken = parser.extract();
    if (procedureNameToken.GetType() != TokenType::NAME) {
        throw SemanticError("Expected procedure name", ".");
    }

    auto procedureNode = std::make_unique<ASTNodeProcedure>(procedureNameToken, "-1");
    //-1 since procedure declarations are not supposed to have a statement number.

    // Extract statement list
    SPToken& openBraces = parser.extract();
    if (openBraces.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::OpenCurlyParenthesis)) {
        throw SemanticError("Expected { after procedure name", ".");
    }
    parser.setStrategy(std::make_shared<ParseStmtLstStrategy>());
    std::shared_ptr<ASTNode> baseShared = parser.parse();
    std::shared_ptr<ASTNodeStmtLst> derivedShared = std::dynamic_pointer_cast<ASTNodeStmtLst>(baseShared);

    if (derivedShared) {
        procedureNode->setStmtLst(derivedShared);
    } else {
        // Handle the case where the dynamic cast fails
        throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeStmtLst");
    }

    // The CLOSE_CURLY_PARENTHESIS acts as the end of loop token for stmtLstStrategy

    return procedureNode;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParsePrintStrategy.h
Generator: gpt
Intervention: 0
Language: e
Prompt: https://platform.openai.com/playground/p/a8b6Pk5rJazaWuD4erUyD6y5?model=gpt-3.5-turbo&mode=chat
ChatId: a8b6Pk5rJazaWuD4erUyD6y5
Code:
class ASTNode;
class SPParser;

class ParsePrintStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;

};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseWhileStrategy.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ParseWhileStrategy.h"
#include "../../ErrorHandling/ParseError.h"
#include "../../ErrorHandling/SemanticError.h"
#include "../../Tokens/SPToken.h"
#include "../../Tokens/TokenType.h"
#include "../SPParser.h"
#include "ParseCondExprStrategy.h"
#include "SP/AST/ASTNode.h"
#include "SP/AST/ASTNodeStmtLst.h"
#include "SP/AST/Expr/ASTNodeCondExpr.h"
#include "SP/AST/Stmt/ASTNodeWhileStmt.h"
#include <Common/SPAConstants/SPAConstants.h>
#include <memory>
#include <stdexcept>

std::unique_ptr<ASTNode> ParseWhileStrategy::parse(SPParser& parser) {
    auto whileNode = std::make_unique<ASTNodeWhileStmt>(to_string(parser.getCurrentStmtNo()));

    SPToken whileToken = parser.extract();
    if (whileToken.GetValue() != "while") {
        throw SemanticError("Expected 'while' keyword", ".");
    }

    SPToken currentToken = parser.extract();

    // Check for '(' token
    if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::OpenRoundParenthesis)) {
        throw SemanticError("Expected '(' at start of condition", " and after a `while` keyword.");
    }

    parser.setStrategy(std::make_unique<ParseCondExprStrategy>());
    std::shared_ptr<ASTNode> condExpr = parser.parse();
    std::shared_ptr<ASTNodeCondExpr> derivedShared = std::dynamic_pointer_cast<ASTNodeCondExpr>(condExpr);

    if (derivedShared) {
        whileNode->setCondExpr(derivedShared);
    } else {
        // Handle the case where the dynamic cast fails
        throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeCondExpr");
    }

    currentToken = parser.extract();

    // Check for ')' token
    if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::CloseRoundParenthesis)) {
        throw SemanticError("Expected ')' at end of condition", ".");
    }

    currentToken = parser.extract();

    // Check for '{' token
    if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::OpenCurlyParenthesis)) {
        throw SemanticError("Expected '{' at start of while statement", ".");
    }

    parser.incrementCurrentStmtNo(); // Start of statement list

    parser.setStrategy(std::make_unique<ParseStmtLstStrategy>());
    std::shared_ptr<ASTNode> stmtLst = parser.parse();
    std::shared_ptr<ASTNodeStmtLst> derivedSharedStmtLst = std::dynamic_pointer_cast<ASTNodeStmtLst>(stmtLst);

    if (derivedShared) {
        whileNode->setStmtLst(derivedSharedStmtLst);
    } else {
        // Handle the case where the dynamic cast fails
        throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeStmtLst");
    }

    return whileNode;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseReadStrategy.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
class ASTNode;
class SPParser;

class ParseReadStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseWhileStrategy.h
Generator: gpt4
Intervention: 0
Language: e
Prompt: https://platform.openai.com/playground/p/a8b6Pk5rJazaWuD4erUyD6y5?model=gpt-4&mode=chat
ChatId: a8b6Pk5rJazaWuD4erUyD6y5
Code:
#ifndef SP_PARSER_PARSESTRATEGY_PARSEWHILELOOPSTRATEGY_H_
#define SP_PARSER_PARSESTRATEGY_PARSEWHILELOOPSTRATEGY_H_

#include "ParseStrategy.h"
#include <SP/Parser/ParseStrategy/ParseUnaryCondExprStrategy.h>
#include <memory>

class ASTNode;
class SPParser;

class ParseWhileStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;
};

#endif // SP_PARSER_PARSESTRATEGY_PARSEWHILELOOPSTRATEGY_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseStrategy.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
class ParseStrategy {
public:
    virtual ~ParseStrategy() = default;
    virtual std::unique_ptr<ASTNode> parse(SPParser& parser) { return nullptr; };
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseCondExprStrategy.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ParseCondExprStrategy.h"
#include "../../Tokens/SPToken.h"
#include "../../Tokens/TokenType.h"
#include "../SPParser.h"
#include "ParseBinaryCondExprStrategy.h"
#include "ParseRelCondExprStrategy.h"
#include "ParseUnaryCondExprStrategy.h"
#include "SP/AST/ASTNode.h"
#include "SP/AST/Expr/ASTNodeCondExpr.h"
#include "../../ErrorHandling/ParseError.h"
#include <memory>
#include <stdexcept>

std::unique_ptr<ASTNode> ParseCondExprStrategy::parse(SPParser& parser) {
    TokenType currentTokenType = parser.peekExpressionOpr();
    SPToken currentToken = parser.peek();

    switch (currentTokenType) {
    case TokenType::UNARY_CONDITIONAL_EXPRESSION_OPERATORS: {
        parser.setStrategy(std::make_unique<ParseUnaryCondExprStrategy>());
        return parser.parse();
    }
    case TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS: {
        parser.setStrategy(std::make_unique<ParseBinaryCondExprStrategy>());
        return parser.parse();
    }
    case TokenType::RELATIONAL_EXPRESSION_OPERATORS: {
        parser.setStrategy(std::make_unique<ParseRelCondExprStrategy>());
        return parser.parse();
    }
    default:
        throw ParseError("Unexpected token type when parsing conditional expression: ", currentToken.GetValue());
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseCondExprStrategy.h
Generator: gpt4
Intervention: 0
Language: e
Prompt: https://platform.openai.com/playground/p/a8b6Pk5rJazaWuD4erUyD6y5?model=gpt-4&mode=chat
ChatId: a8b6Pk5rJazaWuD4erUyD6y5
Code:
#include "ParseStrategy.h"
#include <memory>

class ASTNodeCondExpr;
class SPParser;
class ParseUnaryCondExprStrategy;
class ParseBinaryCondExprStrategy;
class ParseRelCondExprStrategy;

class ParseCondExprStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseCallStrategy.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SPA_PARSECALLSTRATEGY_H
#define SPA_PARSECALLSTRATEGY_H

#include "../../ErrorHandling/SemanticError.h"
#include "../../ErrorHandling/ParseError.h"
#include "../../Tokens/SPToken.h"
#include "../../Tokens/TokenType.h"
#include "../SPParser.h"
#include "../../AST/ASTNode.h"
#include "../../AST/Stmt/ASTNodeCallStmt.h"
#include "ParseStrategy.h"
#include <memory>
#include <stdexcept>

class ASTNode;
class SPParser;

class ParseCallStrategy: public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;
};


#endif //SPA_PARSECALLSTRATEGY_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseCallStrategy.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
/*#include "ParseCallStrategy.h"

std::unique_ptr<ASTNode> ParseCallStrategy::parse(SPParser& parser) {
    auto callNode = std::make_unique<ASTNodeCallStmt>("0");

    SPToken& callToken = parser.extract();
    if (callToken.GetValue() != "call") {
        throw SemanticError("Expected 'call' keyword", ".");
    }

    SPToken& procedureNameToken = parser.extract();
    if (procedureNameToken.GetType() != TokenType::NAME) {
        throw SemanticError("Expected procedure name in the call statement", ".");
    }

    callNode->setProcedureName(procedureNameToken.GetValue());

    SPToken& semicolonToken = parser.extract();
    if (semicolonToken.GetType() != TokenType::SEMICOLON) {
        throw SemanticError("Expected ';' after procedure name in call statement", ".");
    }


    return callNode;
}*/
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseStmtLstStrategy.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
class ASTNode;
class SPParser;
class ParseReadStrategy;
class ParsePrintStrategy;
class ParseWhileStrategy;
class ParseIfStrategy;
class ParseAssignStrategy;

class ParseStmtLstStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseStmtLstStrategy.cpp
Generator: copilot
Intervention: 2
Language: e
Prompt: used copilot
ChatId: 
Code:
std::unique_ptr<ASTNode> ParseStmtLstStrategy::parse(SPParser& parser) {
    auto stmtLstNode = std::make_unique<ASTNodeStmtLst>(); // utilising default constructor

    // Extract statements until end of statement list
    SPToken& currentToken = parser.peek();

    while (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::CloseCurlyParenthesis)) {
        switch (currentToken.GetType()) {
        case TokenType::READ: {

            parser.setStrategy(std::make_unique<ParseReadStrategy>());
            std::shared_ptr<ASTNode> baseShared = parser.parse();
            std::shared_ptr<ASTNodeReadStmt> derivedShared = std::dynamic_pointer_cast<ASTNodeReadStmt>(baseShared);

            if (derivedShared) {
                stmtLstNode->addStmt(derivedShared);
                break;
            } else {
                // Handle the case where the dynamic cast fails
                throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeReadStmt");
            }
        }
        case TokenType::PRINT: {
            parser.setStrategy(std::make_unique<ParsePrintStrategy>());
            std::shared_ptr<ASTNode> baseShared = parser.parse();
            std::shared_ptr<ASTNodePrintStmt> derivedShared = std::dynamic_pointer_cast<ASTNodePrintStmt>(baseShared);

            if (derivedShared) {
                stmtLstNode->addStmt(derivedShared);
                break;
            } else {
                // Handle the case where the dynamic cast fails
                throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodePrintStmt");
            }
        }
        // out of scope for milestone 1

        /*case TokenType::CALL: {
            std::shared_ptr<ASTNode> baseShared = parser.parse();
            std::shared_ptr<ASTNodeCallStmt> derivedShared =
                std::dynamic_pointer_cast<ASTNodeCallStmt>(baseShared);

            if (derivedShared) {
                stmtLstNode->addStmt(derivedShared);
                break;
            }
            else {
                // Handle the case where the dynamic cast fails
                throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeCallStmt");
            }
        }*/
        case TokenType::WHILE: {
            parser.setStrategy(std::make_unique<ParseWhileStrategy>());
            std::shared_ptr<ASTNode> baseShared = parser.parse();
            std::shared_ptr<ASTNodeWhileStmt> derivedShared = std::dynamic_pointer_cast<ASTNodeWhileStmt>(baseShared);

            if (derivedShared) {
                stmtLstNode->addStmt(derivedShared);
                break;
            } else {
                // Handle the case where the dynamic cast fails
                throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeWhileStmt");
            }
        }
        case TokenType::IF: {
            parser.setStrategy(std::make_unique<ParseIfStrategy>());
            std::shared_ptr<ASTNode> baseShared = parser.parse();
            std::shared_ptr<ASTNodeIfStmt> derivedShared = std::dynamic_pointer_cast<ASTNodeIfStmt>(baseShared);

            if (derivedShared) {
                stmtLstNode->addStmt(derivedShared);
                break;
            } else {
                // Handle the case where the dynamic cast fails
                throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeIfStmt");
            }
        }
        case TokenType::NAME: {
            // preliminary checking for assignment statement
            SPToken nextToken = parser.peekNext();
            if (nextToken.GetType() == TokenType::SINGLE_EQUAL &&
                nextToken.GetValue() == std::string(1, SPAConstants::MathOperators::Equals)) {
                // is an assignment statement:
                parser.setStrategy(std::make_unique<ParseAssignStrategy>());
                std::shared_ptr<ASTNode> baseShared = parser.parse();
                std::shared_ptr<ASTNodeAssignStmt> derivedShared =
                    std::dynamic_pointer_cast<ASTNodeAssignStmt>(baseShared);

                if (derivedShared) {
                    stmtLstNode->addStmt(derivedShared);
                    break;
                } else {
                    // Handle the case where the dynamic cast fails
                    throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeAssignStmt");
                }
            } else {
                throw SemanticError("Invalid Statement type encountered", ".");
            }
        }
        default:
            throw SemanticError("Invalid Statement type encountered", ".");
        }

        currentToken = parser.peek(); // Update current token
    }

    currentToken = parser.extract();

    // Check for '}' token
    if (currentToken.GetValue() != std::string(1, SPAConstants::PunctuationSymbols::CloseCurlyParenthesis)) {
        throw SemanticError("Expected '}' at end of stmtLst statement", ".");
    }

    return stmtLstNode;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParsePrintStrategy.cpp
Generator: chatgpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/a8b6Pk5rJazaWuD4erUyD6y5?model=gpt-3.5-turbo&mode=chat
ChatId: a8b6Pk5rJazaWuD4erUyD6y5
Code:
#include "ParsePrintStrategy.h"
#include "../../ErrorHandling/ParseError.h"
#include "../../ErrorHandling/SemanticError.h"
#include "../../Tokens/SPToken.h"
#include "../../Tokens/TokenType.h"
#include "../SPParser.h"
#include "SP/AST/ASTNode.h"
#include "SP/AST/Stmt/ASTNodePrintStmt.h"
#include <memory>
#include <stdexcept>

std::unique_ptr<ASTNode> ParsePrintStrategy::parse(SPParser& parser) {

    // Check for the PRINT keyword
    SPToken& printToken = parser.extract();
    if (printToken.GetValue() != "print") {
        throw SemanticError("Expected 'print' keyword", ".");
    }

    // Extract variable name
    SPToken& variableNameToken = parser.extract();
    if (variableNameToken.GetType() != TokenType::NAME) {
        throw SemanticError("Expected variable name in the print statement", ".");
    }

    std::string stmtNo = to_string(parser.getCurrentStmtNo());
    auto printNode = std::make_unique<ASTNodePrintStmt>(variableNameToken, stmtNo);

    // Expect semicolon at the end of statement
    SPToken& semicolonToken = parser.extract();
    if (semicolonToken.GetType() != TokenType::SEMICOLON) {
        throw SemanticError("Expected ';' after variable name in print statement", ".");
    }

    parser.incrementCurrentStmtNo();
    return printNode;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseAssignStrategy.h
Generator: gpt
Intervention: 0
Language: e
Prompt: https://platform.openai.com/playground/p/a8b6Pk5rJazaWuD4erUyD6y5?model=gpt-3.5-turbo&mode=chat
ChatId: a8b6Pk5rJazaWuD4erUyD6y5
Code:
class ASTNode;
class SPParser;
class ParseExprStrategy;

class ParseAssignStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;

};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseProcedureStrategy.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
class ASTNode;
class SPParser;
class ParseStmtLstStrategy;

class ParseProcedureStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseIfStrategy.h
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/Wu4kTaJvoxrAGl1aMv0t4jMF?model=gpt-3.5-turbo&mode=chat
ChatId: Wu4kTaJvoxrAGl1aMv0t4jMF
Code:
#ifndef PARSE_IF_STRATEGY_H
#define PARSE_IF_STRATEGY_H

#include "ParseStrategy.h"
#include "../../AST/ASTNode.h"
#include "../../AST/Stmt/ASTNodeIfStmt.h"
#include <memory>

class ASTNode;
class ASTNodeIfStmt;
class SPParser;

class ParseIfStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser);
};

#endif // PARSE_IF_STRATEGY_H
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseReadStrategy.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
std::unique_ptr<ASTNode> ParseReadStrategy::parse(SPParser& parser) {

    // for the sake of easy implementation of assignment statements, read keyword must be passed
    SPToken& readToken = parser.extract();
    if (readToken.GetType() != TokenType::READ) {
        throw SemanticError("Expected 'read' keyword", ".");
    }

    // Extract variable name
    SPToken& variableNameToken = parser.extract();
    if (variableNameToken.GetType() != TokenType::NAME) {
        throw SemanticError("Expected variable name after read", ".");
    }

    std::string stmtNo = to_string(parser.getCurrentStmtNo());
    auto readNode = std::make_unique<ASTNodeReadStmt>(variableNameToken, stmtNo);

    // Expect semicolon at end of statement
    SPToken& openBraces = parser.extract();
    if (openBraces.GetType() != TokenType::SEMICOLON) {
        throw SemanticError("Expected ; after variable name in read statement", ".");
    }

    parser.incrementCurrentStmtNo();
    return readNode;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseProgramStrategy.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
class ASTNode;
class SPParser;
class ParseProcedureStrategy;

class ParseProgramStrategy : public ParseStrategy {
public:
    std::unique_ptr<ASTNode> parse(SPParser& parser) override;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/Parser/ParseStrategy/ParseProgramStrategy.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
std::unique_ptr<ASTNode> ParseProgramStrategy::parse(SPParser& parser) {
    auto programNode = std::make_unique<ASTNodeProgram>();

    // Extract procedures until end of file
    while (!parser.endOfParse()) {
        parser.setStrategy(std::make_shared<ParseProcedureStrategy>());
        std::shared_ptr<ASTNode> baseShared = parser.parse();
        std::shared_ptr<ASTNodeProcedure> derivedShared = std::dynamic_pointer_cast<ASTNodeProcedure>(baseShared);

        if (derivedShared) {
            programNode->addProcedure(derivedShared);
        } else {
            // Handle the case where the dynamic cast fails
            throw ParseError("Dynamic casting failed from: ", "ASTNode to ASTNodeProcedure");
        }
    }

    return programNode;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodeStmt.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_STMT_ASTNODESTMT_H_
#define SP_AST_STMT_ASTNODESTMT_H_

#include "../ASTNode.h"

class ASTNodeStmt : public ASTNode {
public:
	using ASTNode::ASTNode;
};

#endif // SP_AST_STMT_ASTNODESTMT_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodePrintStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodePrintStmt.h"
#include "../Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodePrintStmt::ASTNodePrintStmt(SPToken varName, std::string stmtNo) : ASTNodeStmt(stmtNo), varName(varName) {
    if (varName.GetType() != TokenType::NAME) {
        throw InvalidASTNodeTokenTypeError("ASTNodePrintStmt", "NAME");
    }
}

void ASTNodePrintStmt::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractPrintStmt(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodePrintStmt");
    }
}

std::string ASTNodePrintStmt::getVarName() const { return varName.GetValue(); }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodeWhileStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeWhileStmt.h"
#include "../ASTNodeStmtLst.h"
#include "../Exceptions/ASTExceptions.h"
#include "SP/AST/Expr/ASTNodeCondExpr.h"
#include "SP/DesignExtractor/DesignExtractor.h"

void ASTNodeWhileStmt::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractWhileStmt(*this);

        if (condExpr) {
            condExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeWhileStmt", "ASTNodeCondExpr");
        }

        if (stmtLst) {
            stmtLst->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeWhileStmt", "ASTNodeStmtLst");
        }

        extractedShared->notifyEndOfWhileStmt(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeWhileStmt");
    }
}

void ASTNodeWhileStmt::setCondExpr(std::shared_ptr<ASTNodeCondExpr> condExpr) { this->condExpr = condExpr; }

void ASTNodeWhileStmt::setStmtLst(std::shared_ptr<ASTNodeStmtLst> stmtLst) { this->stmtLst = stmtLst; }

const std::shared_ptr<ASTNodeCondExpr>& ASTNodeWhileStmt::getCondExpr() const { return condExpr; }

const std::shared_ptr<ASTNodeStmtLst>& ASTNodeWhileStmt::getStmtLst() const { return stmtLst; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodeCallStmt.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_STMT_ASTNODECALLSTMT_H_
#define SP_AST_STMT_ASTNODECALLSTMT_H_

#include "ASTNodeStmt.h"
#include "SP/Tokens/SPToken.h"
#include <string>

class ASTNodeCallStmt : public ASTNodeStmt {
public:
    ASTNodeCallStmt(SPToken procedureName, std::string stmtNo);
    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) override;

    std::string getProcedureName() const;

protected:
    SPToken procedureName;
};

#endif // SP_AST_STMT_ASTNODECALLSTMT_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodeAssignStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeAssignStmt.h"
#include "../Exceptions/ASTExceptions.h"
#include "../Expr/ASTNodeOprExpr.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeAssignStmt::ASTNodeAssignStmt(SPToken varName, std::string stmtNo)
    : ASTNodeStmt(std::move(stmtNo)), varName(varName) {
    if (varName.GetType() != TokenType::NAME) {
        throw InvalidASTNodeTokenTypeError("ASTNodeAssignStmt", "NAME");
    }
}

void ASTNodeAssignStmt::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractAssignStmt(*this);

        if (expr) {
            expr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeAssignStmt", "ASTNodeOprExpr");
        }

        extractedShared->notifyEndOfAssignStmt(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeAssignStmt");
    }
}

void ASTNodeAssignStmt::setExpr(std::shared_ptr<ASTNodeExpr> expr) { this->expr = expr; }

std::string ASTNodeAssignStmt::getVarName() const { return varName.GetValue(); }

std::shared_ptr<ASTNodeExpr> ASTNodeAssignStmt::getExpr() const { return expr; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodeIfStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeIfStmt.h"
#include "../ASTNodeStmtLst.h"
#include "../Exceptions/ASTExceptions.h"
#include "../Expr/ASTNodeCondExpr.h"
#include "SP/DesignExtractor/DesignExtractor.h"

void ASTNodeIfStmt::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractIfStmt(*this);

        if (condExpr) {
            condExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeIfStmt", "ASTNodeCondExpr");
        }

        if (thenStmtLst) {
            thenStmtLst->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeIfStmt", "Then ASTNodeStmtLst");
        }

        if (elseStmtLst) {
            elseStmtLst->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeIfStmt", "Else ASTNodeStmtLst");
        }

        extractedShared->notifyEndOfIfStmt(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeIfStmt");
    }
}

void ASTNodeIfStmt::setCondExpr(std::shared_ptr<ASTNodeCondExpr> condExpr) { this->condExpr = condExpr; }

void ASTNodeIfStmt::setThenStmtLst(std::shared_ptr<ASTNodeStmtLst> thenStmtLst) { this->thenStmtLst = thenStmtLst; }

void ASTNodeIfStmt::setElseStmtLst(std::shared_ptr<ASTNodeStmtLst> elseStmtLst) { this->elseStmtLst = elseStmtLst; }

const std::shared_ptr<ASTNodeCondExpr>& ASTNodeIfStmt::getCondExpr() const { return condExpr; }

const std::shared_ptr<ASTNodeStmtLst>& ASTNodeIfStmt::getThenStmtLst() const { return thenStmtLst; }

const std::shared_ptr<ASTNodeStmtLst>& ASTNodeIfStmt::getElseStmtLst() const { return elseStmtLst; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodeCallStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeCallStmt.h"
#include "../Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeCallStmt::ASTNodeCallStmt(SPToken procedureName, std::string stmtNo)
    : ASTNodeStmt(std::move(stmtNo)), procedureName(procedureName) {
    if (procedureName.GetType() != TokenType::NAME) {
        throw InvalidASTNodeTokenTypeError("ASTNodeCallStmt", "NAME");
    }
}

void ASTNodeCallStmt::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractCallStmt(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeCallStmt");
    }
}

std::string ASTNodeCallStmt::getProcedureName() const { return procedureName.GetValue(); }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Stmt/ASTNodeReadStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeReadStmt.h"
#include "../Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeReadStmt::ASTNodeReadStmt(SPToken varName, std::string stmtNo) : ASTNodeStmt(stmtNo), varName(varName) {
    if (varName.GetType() != TokenType::NAME) {
        throw InvalidASTNodeTokenTypeError("ASTNodeReadStmt", "NAME");
    }
}

void ASTNodeReadStmt::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractReadStmt(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeReadStmt");
    }
}
std::string ASTNodeReadStmt::getVarName() const { return varName.GetValue(); }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/ASTNodeProcedure.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_ASTNODEPROCEDURE_H_
#define SP_AST_ASTNODEPROCEDURE_H_

#include "ASTNode.h"
#include "SP/Tokens/SPToken.h"
#include <vector>

class ASTNodeStmtLst;
class DesignExtractor;

class ASTNodeProcedure : public ASTNode {
public:
    ASTNodeProcedure(SPToken procedureName, std::string stmtNo = "0");

    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) override;

    void setStmtLst(std::shared_ptr<ASTNodeStmtLst> stmtLst);

    const std::shared_ptr<ASTNodeStmtLst>& getStmtLst() const;
    std::string getProcedureName() const;

protected:
    std::shared_ptr<ASTNodeStmtLst> stmtLst;
    SPToken procedureName;
};

#endif // SP_AST_ASTNODEPROCEDURE_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/ASTNodeProgram.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeProgram.h"
#include "ASTNodeProcedure.h"
#include "Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

void ASTNodeProgram::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractProgram(*this);

        for (auto& proc : procs) {
            proc->acceptVisitor(extractor);
        }

        extractedShared->notifyEndOfProgram(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeProgram");
    }
}

void ASTNodeProgram::addProcedure(std::shared_ptr<ASTNodeProcedure> proc) {
    if (proc) {
        procs.push_back(proc);
    }
}

const std::vector<std::shared_ptr<ASTNodeProcedure>>& ASTNodeProgram::getProcs() const { return procs; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/ASTNodeProcedure.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeProcedure.h"
#include "ASTNodeStmtLst.h"
#include "Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeProcedure::ASTNodeProcedure(SPToken procedureName, std::string stmtNo)
    : ASTNode(stmtNo), procedureName(procedureName) {
    if (procedureName.GetType() != TokenType::NAME) {
        throw InvalidASTNodeTokenTypeError("ASTNodeProcedure", "NAME");
    }
}

void ASTNodeProcedure::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractProcedure(*this);

        if (stmtLst) {
            stmtLst->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeStmtLst", "ASTNodeProcedure");
        }

        extractedShared->notifyEndOfProcedure(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeProcedure");
    }
}

void ASTNodeProcedure::setStmtLst(std::shared_ptr<ASTNodeStmtLst> stmtLst) { this->stmtLst = stmtLst; }

const std::shared_ptr<ASTNodeStmtLst>& ASTNodeProcedure::getStmtLst() const { return stmtLst; }

std::string ASTNodeProcedure::getProcedureName() const { return procedureName.GetValue(); }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/ASTNode.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_ASTNODE_H_
#define SP_AST_ASTNODE_H_

#include <memory>
#include <string>

class DesignExtractor;

class ASTNode {
protected:
    std::string stmtNo;

public:
    ASTNode(std::string stmtNo) : stmtNo(stmtNo) {}
    virtual ~ASTNode() = default;
    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {}
    virtual std::string getStmtNo() const { return stmtNo; }
};

#endif // SP_AST_ASTNODE_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeUnaryCondExpr.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeUnaryCondExpr.h"
#include "../Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeUnaryCondExpr::ASTNodeUnaryCondExpr(SPToken condOp, std::string stmtNo)
    : ASTNodeCondExpr(std::move(stmtNo)), condOp(condOp) {
    //if (condOp.GetType() != TokenType::NOT) {
    //    throw InvalidASTNodeTokenTypeError("ASTNodeUnaryCondExpr", "NOT");
    //}
}

void ASTNodeUnaryCondExpr::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractUnaryCondExpr(*this);
        if (condExpr) {
            condExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeUnaryCondExpr", "ASTNodeCondExpr");
        }
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeUnaryCondExpr");
    }
}

void ASTNodeUnaryCondExpr::setCondExpr(std::shared_ptr<ASTNodeCondExpr> condExpr) { this->condExpr = condExpr; }

std::string ASTNodeUnaryCondExpr::getCondOp() const { return condOp.GetValue(); }

const std::shared_ptr<ASTNodeCondExpr>& ASTNodeUnaryCondExpr::getCondExpr() const { return condExpr; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeOprExpr.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_EXPR_ASTNODEOPREXPR_H_
#define SP_AST_EXPR_ASTNODEOPREXPR_H_

#include "ASTNodeExpr.h"
#include "SP/Tokens/SPToken.h"
#include <string>

class ASTNodeOprExpr : public ASTNodeExpr {
public:
    ASTNodeOprExpr(SPToken opr, std::string stmtNo = "0");
    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) override;

    void setLeftExpr(std::shared_ptr<ASTNodeExpr> leftExpr);
    void setRightExpr(std::shared_ptr<ASTNodeExpr> rightExpr);

    std::string getOpr() const;
    std::shared_ptr<ASTNodeExpr> getLeftExpr() const;
    std::shared_ptr<ASTNodeExpr> getRightExpr() const;

    bool isOprExpr() const override { return true; }

protected:
    SPToken opr;
    std::shared_ptr<ASTNodeExpr> leftExpr;
    std::shared_ptr<ASTNodeExpr> rightExpr;
};

#endif // SP_AST_EXPR_ASTNODEOPREXPR_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeTermExpr.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
ASTNodeTermExpr::ASTNodeTermExpr(SPToken term, std::string stmtNo) : ASTNodeExpr(stmtNo), term(term) {
    if (term.GetType() != TokenType::NAME && term.GetType() != TokenType::INTEGER) {
        throw InvalidASTNodeTokenTypeError("ASTNodeTermExpr", "NAME || INTEGER");
    }
}

void ASTNodeTermExpr::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractTermExpr(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeTermExpr");
    }
}

std::string ASTNodeTermExpr::getTerm() const { return term.GetValue(); }

bool ASTNodeTermExpr::isVariable() const { return term.GetType() == TokenType::NAME; }

bool ASTNodeTermExpr::isConstant() const { return term.GetType() == TokenType::INTEGER; }

bool ASTNodeTermExpr::isTermExpr() const { return true; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeRelCondExpr.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeRelCondExpr.h"
#include "../Exceptions/ASTExceptions.h"
#include "ASTNodeOprExpr.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeRelCondExpr::ASTNodeRelCondExpr(SPToken relOp, std::string stmtNo) : ASTNodeCondExpr(stmtNo), relOp(relOp) {
    // TODO: Add exception handling when relational token types are fixed
    // if (relOp.GetType() != TokenType::GREATER_THAN && relOp.GetType() != TokenType::LESS_THAN &&
    //     relOp.GetType() != TokenType::DOUBLE_EQUALS) {
    //     throw InvalidASTNodeTokenTypeError("ASTNodeRelCondExpr", "RELOP");
    // }
}

void ASTNodeRelCondExpr::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractRelCondExpr(*this);

        if (leftRelExpr) {
            leftRelExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeRelCondExpr", "Left ASTNodeExpr");
        }

        if (rightRelExpr) {
            rightRelExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeRelCondExpr", "Right ASTNodeExpr");
        }

    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeRelCondExpr");
    }
}

void ASTNodeRelCondExpr::setLeftExpr(std::shared_ptr<ASTNodeExpr> leftRelExpr) { this->leftRelExpr = leftRelExpr; }

void ASTNodeRelCondExpr::setRightExpr(std::shared_ptr<ASTNodeExpr> rightRelExpr) { this->rightRelExpr = rightRelExpr; }

std::string ASTNodeRelCondExpr::getRelOp() const { return relOp.GetValue(); }

std::shared_ptr<ASTNodeExpr> ASTNodeRelCondExpr::getLeftExpr() const { return leftRelExpr; }

std::shared_ptr<ASTNodeExpr> ASTNodeRelCondExpr::getRightExpr() const { return rightRelExpr; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeOprExpr.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeOprExpr.h"
#include "../Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeOprExpr::ASTNodeOprExpr(SPToken opr, std::string stmtNo) : ASTNodeExpr(stmtNo), opr(opr) {
    // if (opr.GetType() != TokenType::PLUS && opr.GetType() != TokenType::MINUS && opr.GetType() != TokenType::MULTIPLY
    // &&
    //     opr.GetType() != TokenType::DIVIDE && opr.GetType() != TokenType::MODULO) {
    //     throw InvalidASTNodeTokenTypeError("ASTNodeOprExpr", "OPR");
    // }
}

void ASTNodeOprExpr::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractOprExpr(*this);

        if (leftExpr) {
            leftExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeOprExpr", "Left ASTNodeExpr");
        }

        if (rightExpr) {
            rightExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeOprExpr", "Right ASTNodeExpr");
        }

    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeOprExpr");
    }
}

void ASTNodeOprExpr::setLeftExpr(std::shared_ptr<ASTNodeExpr> leftExpr) { this->leftExpr = leftExpr; }

void ASTNodeOprExpr::setRightExpr(std::shared_ptr<ASTNodeExpr> rightExpr) { this->rightExpr = rightExpr; }

std::string ASTNodeOprExpr::getOpr() const { return opr.GetValue(); }

std::shared_ptr<ASTNodeExpr> ASTNodeOprExpr::getLeftExpr() const { return leftExpr; }

std::shared_ptr<ASTNodeExpr> ASTNodeOprExpr::getRightExpr() const { return rightExpr; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeExpr.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_EXPR_ASTNODEEXPR_H_
#define SP_AST_EXPR_ASTNODEEXPR_H_

#include "../ASTNode.h"

class ASTNodeExpr : public ASTNode {
public:
    using ASTNode::ASTNode;

    virtual bool isTermExpr() const { return false; }
    virtual bool isOprExpr() const { return false; }
};

#endif // SP_AST_EXPR_ASTNODEEXPR_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeRelCondExpr.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_EXPR_ASTNODERELCONDEXPR_H_
#define SP_AST_EXPR_ASTNODERELCONDEXPR_H_

#include "ASTNodeCondExpr.h"
#include "SP/Tokens/SPToken.h"
#include <string>

class ASTNodeExpr;
class ASTNodeRelCondExpr : public ASTNodeCondExpr {
public:
    ASTNodeRelCondExpr(SPToken relOp, std::string stmtNo = "0");

    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) override;

    void setLeftExpr(std::shared_ptr<ASTNodeExpr> leftRelExpr);
    void setRightExpr(std::shared_ptr<ASTNodeExpr> rightRelExpr);

    std::string getRelOp() const;
    std::shared_ptr<ASTNodeExpr> getLeftExpr() const;
    std::shared_ptr<ASTNodeExpr> getRightExpr() const;

protected:
    SPToken relOp;
    std::shared_ptr<ASTNodeExpr> leftRelExpr;
    std::shared_ptr<ASTNodeExpr> rightRelExpr;
};

#endif // SP_AST_EXPR_ASTNODERELCONDEXPR_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeTermExpr.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeExpr.h"
#include "SP/Tokens/SPToken.h"
#include <string>

class ASTNodeTermExpr : public ASTNodeExpr {
public:
    ASTNodeTermExpr(SPToken term, std::string stmtNo = "0");

    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) override;

    std::string getTerm() const;
    bool isVariable() const;
    bool isConstant() const;
    bool isTermExpr() const override;

protected:
    SPToken term;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/Expr/ASTNodeBinaryCondExpr.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeBinaryCondExpr.h"
#include "../Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"

ASTNodeBinaryCondExpr::ASTNodeBinaryCondExpr(SPToken condOp, std::string stmtNo)
    : ASTNodeCondExpr(stmtNo), condOp(condOp) {
    // TODO: To add checking when TokenType is fixed
    // if (condOp.GetType() != TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS && condOp.GetType() != TokenType::OR)
    // {
    //     throw InvalidASTNodeTokenTypeError("ASTNodeBinaryCondExpr", "COND_OP");
    // }
}

void ASTNodeBinaryCondExpr::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractBinaryCondExpr(*this);
        if (leftCondExpr) {
            leftCondExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeBinaryCondExpr", "Left ASTNodeCondExpr");
        }
        if (rightCondExpr) {
            rightCondExpr->acceptVisitor(extractor);
        } else {
            throw MissingASTNodeError("ASTNodeBinaryCondExpr", "Right ASTNodeCondExpr");
        }
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeBinaryCondExpr");
    }
}

void ASTNodeBinaryCondExpr::setLeftCondExpr(std::shared_ptr<ASTNodeCondExpr> leftCondExpr) {
    this->leftCondExpr = leftCondExpr;
}

void ASTNodeBinaryCondExpr::setRightCondExpr(std::shared_ptr<ASTNodeCondExpr> rightCondExpr) {
    this->rightCondExpr = rightCondExpr;
}

std::string ASTNodeBinaryCondExpr::getCondOp() const { return condOp.GetValue(); }

const std::shared_ptr<ASTNodeCondExpr>& ASTNodeBinaryCondExpr::getLeftCondExpr() const { return leftCondExpr; }

const std::shared_ptr<ASTNodeCondExpr>& ASTNodeBinaryCondExpr::getRightCondExpr() const { return rightCondExpr; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/ASTNodeStmtLst.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_ASTNODESTMTLST_H_
#define SP_AST_ASTNODESTMTLST_H_

#include "ASTNode.h"
#include <memory>
#include <vector>

class ASTNodeStmt;

class ASTNodeStmtLst : public ASTNode {
protected:
    std::vector<std::shared_ptr<ASTNodeStmt>> stmts;

public:
    ASTNodeStmtLst(std::string stmtNo = "0") : ASTNode(stmtNo) {}
    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) override;

    void addStmt(std::shared_ptr<ASTNodeStmt> stmt);

    const std::vector<std::shared_ptr<ASTNodeStmt>>& getStmts() const;
};

#endif // SP_AST_ASTNODESTMTLST_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/ASTNodeProgram.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_AST_ASTNODEPROGRAM_H_
#define SP_AST_ASTNODEPROGRAM_H_

#include "ASTNode.h"
#include <memory>
#include <vector>

class ASTNodeProcedure;
class DesignExtractor;

class ASTNodeProgram : public ASTNode {
public:
    ASTNodeProgram(std::string stmtNo = "0") : ASTNode(stmtNo) {}
    virtual void acceptVisitor(std::weak_ptr<DesignExtractor> extractor) override;

    void addProcedure(std::shared_ptr<ASTNodeProcedure> proc);

    const std::vector<std::shared_ptr<ASTNodeProcedure>>& getProcs() const;

protected:
    std::vector<std::shared_ptr<ASTNodeProcedure>> procs;
};

#endif // SP_AST_ASTNODEPROGRAM_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/AST/ASTNodeStmtLst.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTNodeStmtLst.h"
#include "Exceptions/ASTExceptions.h"
#include "SP/DesignExtractor/DesignExtractor.h"
#include "Stmt/ASTNodeStmt.h"

void ASTNodeStmtLst::acceptVisitor(std::weak_ptr<DesignExtractor> extractor) {
    if (auto extractedShared = extractor.lock(); extractedShared) {
        extractedShared->extractStmtLst(*this);

        for (auto stmt : stmts) {
            stmt->acceptVisitor(extractor);
        }

        extractedShared->notifyEndOfStmtLst(*this);
    } else {
        throw InvalidDesignExtractorVisitedError("ASTNodeStmtLst");
    }
}

void ASTNodeStmtLst::addStmt(std::shared_ptr<ASTNodeStmt> stmt) {
    if (stmt) {
        stmts.push_back(stmt);
    }
}

const std::vector<std::shared_ptr<ASTNodeStmt>>& ASTNodeStmtLst::getStmts() const { return stmts; }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/PatternDesignExtractor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_DESIGNEXTRACTOR_EXTRACTORS_PATTERNDESIGNEXTRACTOR_H_
#define SP_DESIGNEXTRACTOR_EXTRACTORS_PATTERNDESIGNEXTRACTOR_H_

#include "DesignExtractor.h"
#include <memory>

class PatternDesignExtractor : public DesignExtractor {
public:
    PatternDesignExtractor(std::weak_ptr<Store> writer);
};

#endif // SP_DESIGNEXTRACTOR_EXTRACTORS_PATTERNDESIGNEXTRACTOR_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/DesignExtractor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_DESIGNEXTRACTOR_DESIGNEXTRACTOR_H_
#define SP_DESIGNEXTRACTOR_DESIGNEXTRACTOR_H_

#include "PKB/API/Store.h"
#include <memory>
#include <vector>

class Store;
class ASTNodeProgram;
class ASTNodeProcedure;
class ASTNodeStmtLst;
class ASTNodeStmt;
class ASTNodeReadStmt;
class ASTNodePrintStmt;
class ASTNodeAssignStmt;
class ASTNodeCallStmt;
class ASTNodeWhileStmt;
class ASTNodeIfStmt;
class ASTNodeRelCondExpr;
class ASTNodeBinaryCondExpr;
class ASTNodeUnaryCondExpr;
class ASTNodeOprExpr;
class ASTNodeTermExpr;
class NodeExtractor;

class DesignExtractor {
public:
    DesignExtractor(std::weak_ptr<Store> writer) : writer(writer) {}
    virtual ~DesignExtractor() = default;

    virtual void extractProgram(const ASTNodeProgram& programNode);
    virtual void extractProcedure(const ASTNodeProcedure& procedureNode);
    virtual void extractStmtLst(const ASTNodeStmtLst& stmtLstNode);
    virtual void extractStmt(const ASTNodeStmt& stmtNode);
    virtual void extractReadStmt(const ASTNodeReadStmt& readNode);
    virtual void extractPrintStmt(const ASTNodePrintStmt& printNode);
    virtual void extractAssignStmt(const ASTNodeAssignStmt& assignNode);
    virtual void extractCallStmt(const ASTNodeCallStmt& callNode);
    virtual void extractWhileStmt(const ASTNodeWhileStmt& whileNode);
    virtual void extractIfStmt(const ASTNodeIfStmt& ifNode);
    virtual void extractOprExpr(const ASTNodeOprExpr& oprExprNode);
    virtual void extractTermExpr(const ASTNodeTermExpr& termExprNode);
    virtual void extractRelCondExpr(const ASTNodeRelCondExpr& relCondExprNode);
    virtual void extractUnaryCondExpr(const ASTNodeUnaryCondExpr& unaryCondExprNode);
    virtual void extractBinaryCondExpr(const ASTNodeBinaryCondExpr& binaryCondExprNode);

    virtual void notifyEndOfProgram(const ASTNodeProgram& programNode);
    virtual void notifyEndOfProcedure(const ASTNodeProcedure& procedureNode);
    virtual void notifyEndOfStmtLst(const ASTNodeStmtLst& stmtLstNode);
    virtual void notifyEndOfAssignStmt(const ASTNodeAssignStmt& assignNode);
    virtual void notifyEndOfIfStmt(const ASTNodeIfStmt& ifNode);
    virtual void notifyEndOfWhileStmt(const ASTNodeWhileStmt& whileNode);

protected:
    std::vector<std::shared_ptr<NodeExtractor>> endOfProgramNodeSubscribers;
    std::vector<std::shared_ptr<NodeExtractor>> procedureNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> stmtLstNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> stmtNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> readNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> printNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> assignNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> callNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> whileNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> ifNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> oprExprNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> termExprNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> relCondExprNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> unaryCondExprNodeExtractors;
    std::vector<std::shared_ptr<NodeExtractor>> binaryCondExprNodeExtractors;

    std::weak_ptr<Store> writer;
};

#endif // SP_DESIGNEXTRACTOR_DESIGNEXTRACTOR_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Exceptions/DEExceptions.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
class InvalidPKBWriterReference : public std::runtime_error {
public:
    InvalidPKBWriterReference(const std::string& extractorName, const std::string& dataName)
        : std::runtime_error(extractorName + ": Invalid PKB writer reference during storage of extracted " + dataName) {
    }

    InvalidPKBWriterReference(const std::string& extractorName)
        : std::runtime_error(extractorName + ": Invalid PKB writer reference during extraction") {}
};

class MissingProcedureNameInRelationshipExtraction : public std::runtime_error {
public:
    MissingProcedureNameInRelationshipExtraction(const std::string& extractorName)
        : std::runtime_error(extractorName + ": Missing procedure name during relationship extraction") {}
};

class InvalidRelationshipKey : public std::runtime_error {
public:
    InvalidRelationshipKey(const std::string& extractorName, const std::string& dataName)
        : std::runtime_error(extractorName + ": Invalid " + dataName +
                             " relationship. Key is not a statement or procedure name") {}
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/EntityDesignExtractor.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef SP_DESIGNEXTRACTOR_ENTITYDESIGNEXTRACTOR_H_
#define SP_DESIGNEXTRACTOR_ENTITYDESIGNEXTRACTOR_H_

#include "DesignExtractor.h"
#include <memory>

class EntityDesignExtractor : public DesignExtractor {
public:
    EntityDesignExtractor(std::weak_ptr<Store> writer);
};

#endif // SP_DESIGNEXTRACTOR_ENTITYDESIGNEXTRACTOR_H_
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/DesignExtractorFacade.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
class MockEntity {
public:
    void setEntityAttributes(const std::string& attribute) { this->attribute = attribute; }

    std::string getEntityAttribute() const { return attribute; }

private:
    std::string attribute;
};
class MockRelationship {
public:
    MockRelationship() : keyAttribute(""), valueAttribute("") {}
    MockRelationship(const std::string& keyAttribute, const std::string& valueAttribute)
        : keyAttribute(keyAttribute), valueAttribute(valueAttribute) {}

    void setRelationshipAttributes(const std::string& keyAttribute, const std::string& valueAttribute) {
        this->keyAttribute = keyAttribute;
        this->valueAttribute = valueAttribute;
    }

    std::string getKeyAttribute() const { return keyAttribute; }
    std::string getValueAttribute() const { return valueAttribute; }

    bool operator==(const MockRelationship& other) const {
        return keyAttribute == other.keyAttribute && valueAttribute == other.valueAttribute;
    }

    void print() const { std::cout << "Key: " << keyAttribute << " Value: " << valueAttribute << std::endl; }

protected:
    std::string keyAttribute;
    std::string valueAttribute;
};

class MockPattern {
public:
    MockPattern() : keyAttribute(""), valueAttribute("") {}
    MockPattern(const std::string& keyAttribute, const std::string& valueAttribute)
        : keyAttribute(keyAttribute), valueAttribute(valueAttribute) {}

    void setPatternAttributes(const std::string& keyAttribute, const std::string& valueAttribute) {
        this->keyAttribute = keyAttribute;
        this->valueAttribute = valueAttribute;
    }

    std::string getKeyAttribute() const { return keyAttribute; }
    std::string getValueAttribute() const { return valueAttribute; }

    void print() const { std::cout << "Key: " << keyAttribute << " Value: " << valueAttribute << std::endl; }

    bool operator==(const MockPattern& other) const {
        return keyAttribute == other.keyAttribute && valueAttribute == other.valueAttribute;
    }

protected:
    std::string keyAttribute;
    std::string valueAttribute;
};

template <>
struct std::hash<MockRelationship> {
    std::size_t operator()(const MockRelationship relationship) const noexcept {
        auto h1 = std::hash<std::string>{}(relationship.getKeyAttribute());
        auto h2 = std::hash<std::string>{}(relationship.getValueAttribute());

        return h1 ^ (h2 << 1);
    }
};

template <>
struct std::hash<MockPattern> {
    std::size_t operator()(const MockPattern pattern) const noexcept {
        auto h1 = std::hash<std::string>{}(pattern.getKeyAttribute());
        auto h2 = std::hash<std::string>{}(pattern.getValueAttribute());

        return h1 ^ (h2 << 1);
    }
};

class MockWriter {
public:
    virtual void storeEntity(MockEntity& entity) { entities.insert(entity.getEntityAttribute()); }
    virtual void storeRelationship(MockRelationship& relationship) { relationships.insert(relationship); }
    virtual void storePattern(MockPattern& pattern) { patterns.insert(pattern); }

    const std::unordered_set<std::string>& getEntities() const { return entities; }
    const std::unordered_set<MockRelationship>& getRelationships() const { return relationships; }
    const std::unordered_set<MockPattern>& getPatterns() const { return patterns; }

protected:
    std::unordered_set<std::string> entities;
    std::unordered_set<MockRelationship> relationships;
    std::unordered_set<MockPattern> patterns;
};

class MockPKB {
public:
    MockPKB() {
        tempWriterRef = std::make_shared<MockWriter>();
        writer = tempWriterRef;
    }

    std::weak_ptr<MockWriter> getWriter() { return writer; }

protected:
    std::shared_ptr<MockWriter> tempWriterRef;
    std::weak_ptr<MockWriter> writer;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Patterns/AssignPatternExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void AssignPatternExtractor::extractDesign(const ASTNodeAssignStmt& assignStmtNode) {
    auto expr = assignStmtNode.getExpr();

    // Start processing the expr nodes
    std::string assignLHS = assignStmtNode.getVarName();
    std::string assignRHS = extractPostfixNotation(expr);
    assignRHS.pop_back(); // Remove the trailing space

    storePattern(assignLHS, assignRHS);
}

std::string AssignPatternExtractor::extractPostfixNotation(std::shared_ptr<ASTNodeExpr> expr) {
    std::string result;

    if (expr->isOprExpr()) {
        auto oprExpr = std::static_pointer_cast<ASTNodeOprExpr>(expr);
        result += extractPostfixNotation(oprExpr->getLeftExpr());
        result += extractPostfixNotation(oprExpr->getRightExpr());
        result += oprExpr->getOpr();
    } else if (expr->isTermExpr()) {
        auto termExpr = std::static_pointer_cast<ASTNodeTermExpr>(expr);
        result += termExpr->getTerm();
    }

    result += " ";
    return result;
}

void AssignPatternExtractor::storePattern(const std::string& keyAttribute, const std::string& valueAttribute) {
    AssignPattern assignPattern;
    assignPattern.setPatternAttributes(keyAttribute, valueAttribute);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storePattern(assignPattern);
    } else {
        throw InvalidPKBWriterReference("AssignPatternExtractor", "Assign pattern");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Relationships/ModifiesExtractor.cpp
Generator: copilot
Intervention: 2
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ModifiesExtractor.h"
#include "../../Exceptions/DEExceptions.h"
#include "Common/Relationships/ModifiesPRelationship.h"
#include "Common/Relationships/ModifiesSRelationship.h"
#include "SP/AST/ASTNodeProcedure.h"
#include "SP/AST/Stmt/ASTNodeAssignStmt.h"
#include "SP/AST/Stmt/ASTNodeCallStmt.h"
#include "SP/AST/Stmt/ASTNodeIfStmt.h"
#include "SP/AST/Stmt/ASTNodeReadStmt.h"
#include "SP/AST/Stmt/ASTNodeWhileStmt.h"
#include <queue>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

void ModifiesExtractor::extractDesign(const ASTNodeProcedure& procedureNode) {
    // New procedure encountered, store the procedure name
    currentProcedureName = procedureNode.getProcedureName();
    addContainerToStack(currentProcedureName);
    stmtAndProcedureSet.addProcedure(currentProcedureName);
}

void ModifiesExtractor::extractDesign(const ASTNodeAssignStmt& assignStmtNode) {
    verifyValidEntity(this->currentProcedureName);

    auto stmtNo = assignStmtNode.getStmtNo();
    auto varName = assignStmtNode.getVarName(); // Get the lhs variable name
    const auto& previousContainer = peekContainerFromStack();
    addRelationship(stmtNo, varName);               // Store the Modifies(a, v) relationship
    addRelationship(previousContainer, varName);    // Store the Modifies(s, v) relationship
    addRelationship(currentProcedureName, varName); // Store the Modifies(p, v) relationship
    stmtAndProcedureSet.addStmt(stmtNo);
}

void ModifiesExtractor::extractDesign(const ASTNodeReadStmt& readStmtNode) {
    verifyValidEntity(this->currentProcedureName);

    auto stmtNo = readStmtNode.getStmtNo();
    auto varName = readStmtNode.getVarName();
    const auto& previousContainer = peekContainerFromStack();
    addRelationship(stmtNo, varName);               // Store the Modifies(r, v) relationship
    addRelationship(previousContainer, varName);    // Store the Modifies(s, v) relationship
    addRelationship(currentProcedureName, varName); // Store the Modifies(p, v) relationship
    stmtAndProcedureSet.addStmt(stmtNo);
}

void ModifiesExtractor::storeRelationship(const std::string& keyAttribute, const std::string& valueAttribute) {
    if (auto writerShared = this->writer.lock(); writerShared) {
        if (stmtAndProcedureSet.isProcedure(keyAttribute)) {
            ModifiesPRelationship modifiesPRelationship;
            modifiesPRelationship.setRelationshipAttributes(keyAttribute, valueAttribute);

            writerShared->storeRelationship(modifiesPRelationship);
        } else if (stmtAndProcedureSet.isStmt(keyAttribute)) {
            ModifiesSRelationship modifiesSRelationship;
            modifiesSRelationship.setRelationshipAttributes(keyAttribute, valueAttribute);

            writerShared->storeRelationship(modifiesSRelationship);
        } else {
            throw InvalidRelationshipKey("ModifiesExtractor", "Modifies relationship");
        }
    } else {
        throw InvalidPKBWriterReference("ModifiesExtractor", "Modifies relationship");
    }
}

void ModifiesExtractor::verifyValidEntity(const std::string& procedureName) {
    if (this->currentProcedureName.empty()) {
        throw MissingProcedureNameInRelationshipExtraction("ModifiesExtractor");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Relationships/FollowsExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "FollowsExtractor.h"
#include "../../Exceptions/DEExceptions.h"
#include "Common/Relationships/FollowsRelationship.h"
#include "Common/Relationships/FollowsStarRelationship.h"
#include "SP/AST/ASTNodeStmtLst.h"
#include "SP/AST/Stmt/ASTNodeStmt.h"
#include <utility>

void FollowsExtractor::extractDesign(const ASTNodeStmtLst& stmtLstNode) {
    const auto& stmts = stmtLstNode.getStmts();

    auto it = stmts.begin();
    auto end = stmts.end();

    if (it != end) {
        auto prevStmt = *it;
        ++it;

        for (; it != end; ++it) {
            auto currStmt = *it;

            // Send data to PKB
            this->storeRelationship(prevStmt->getStmtNo(), currStmt->getStmtNo());

            addRelationship(prevStmt->getStmtNo(), currStmt->getStmtNo());
            addToPropagationMap(prevStmt->getStmtNo(), currStmt->getStmtNo());
            // containerStack not neccessary for this since Follows does not care about containers

            prevStmt = currStmt;
        }
    }
}

void FollowsExtractor::notifyEndOfNode(const ASTNodeProgram& programNode) {
    propagateRelationships();

    // Store all Follows* relationships
    for (const auto& [followStmtNo, stmtNos] : relationMap) {
        for (const auto& stmtNo : stmtNos) {
            storeStarRelationship(followStmtNo, stmtNo);
        }
    }
}

void FollowsExtractor::storeRelationship(const std::string& keyAttribute, const std::string& valueAttribute) {
    FollowsRelationship followsRelationship;
    followsRelationship.setRelationshipAttributes(keyAttribute, valueAttribute);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeRelationship(followsRelationship);
    } else {
        throw InvalidPKBWriterReference("FollowsExtractor", "Follows relationship");
    }
}

void FollowsExtractor::storeStarRelationship(const std::string& keyAttribute, const std::string& valueAttribute) {
    FollowsStarRelationship followsStarRelationship;
    followsStarRelationship.setRelationshipAttributes(keyAttribute, valueAttribute);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeRelationship(followsStarRelationship);
    } else {
        throw InvalidPKBWriterReference("FollowsExtractor", "Follows* relationship");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Relationships/ParentExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ParentExtractor.h"
#include "../../Exceptions/DEExceptions.h"
#include "Common/Relationships/ParentRelationship.h"
#include "Common/Relationships/ParentStarRelationship.h"
#include "SP/AST/ASTNodeStmtLst.h"
#include "SP/AST/Stmt/ASTNodeIfStmt.h"
#include "SP/AST/Stmt/ASTNodeWhileStmt.h"
#include <utility>

void ParentExtractor::extractDesign(const ASTNodeWhileStmt& whileNode) {
    const auto& stmts = whileNode.getStmtLst()->getStmts();
    auto currentStmtNo = whileNode.getStmtNo();

    // For each statement in the statement list, store the relationship
    for (const auto& stmt : stmts) {
        storeRelationship(currentStmtNo, stmt->getStmtNo());
        addRelationship(currentStmtNo, stmt->getStmtNo());
    }

    if (!isContainerStackEmpty()) {
        // Add dependency of while node on the previous container statement if there is one
        addToPropagationMap(peekContainerFromStack(), currentStmtNo);
    }

    addContainerToStack(currentStmtNo);
}

void ParentExtractor::extractDesign(const ASTNodeIfStmt& ifNode) {
    const auto& thenStmts = ifNode.getThenStmtLst()->getStmts();
    const auto& elseStmts = ifNode.getElseStmtLst()->getStmts();
    auto currentStmtNo = ifNode.getStmtNo();

    // For each statement in the then statement list, store the relationship
    for (const auto& stmt : thenStmts) {
        storeRelationship(currentStmtNo, stmt->getStmtNo());
        addRelationship(currentStmtNo, stmt->getStmtNo());
    }

    // For each statement in the else statement list, store the relationship
    for (const auto& stmt : elseStmts) {
        storeRelationship(currentStmtNo, stmt->getStmtNo());
        addRelationship(currentStmtNo, stmt->getStmtNo());
    }

    if (!isContainerStackEmpty()) {
        // Add dependency of while node on the previous container statement if there is one
        addToPropagationMap(peekContainerFromStack(), currentStmtNo);
    }

    addContainerToStack(currentStmtNo);
}

void ParentExtractor::notifyEndOfNode(const ASTNodeProgram& programNode) {
    propagateRelationships();

    // Store all Parent* relationships
    for (const auto& [parentStmtNo, stmtNos] : relationMap) {
        for (const auto& stmtNo : stmtNos) {
            storeStarRelationship(parentStmtNo, stmtNo);
        }
    }
}

void ParentExtractor::notifyEndOfNode(const ASTNodeWhileStmt& whileNode) { popContainerFromStack(); }

void ParentExtractor::notifyEndOfNode(const ASTNodeIfStmt& ifNode) { popContainerFromStack(); }

void ParentExtractor::storeRelationship(const std::string& keyAttribute, const std::string& valueAttribute) {
    ParentRelationship parentRelationship;
    parentRelationship.setRelationshipAttributes(keyAttribute, valueAttribute);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeRelationship(parentRelationship);
    } else {
        throw InvalidPKBWriterReference("ParentExtractor", "Parent relationship");
    }
}

void ParentExtractor::storeStarRelationship(const std::string& keyAttribute, const std::string& valueAttribute) {
    ParentStarRelationship parentStarRelationship;
    parentStarRelationship.setRelationshipAttributes(keyAttribute, valueAttribute);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeRelationship(parentStarRelationship);
    } else {
        throw InvalidPKBWriterReference("ParentExtractor", "Parent* relationship");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Relationships/PropagatingRelationshipContainer.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void PropagatingRelationshipContainer::addRelationship(const std::string& key, const std::string& value) {
    relationMap[key].insert(value);
}

// Add dependency of previous container on the current container
void PropagatingRelationshipContainer::addToPropagationMap(const std::string& previousContainer,
                                                           const std::string& currentContainer) {
    if (relationPropagationMap.count(currentContainer) == 0) {
        relationPropagationMap[currentContainer] = {previousContainer};
    } else {
        relationPropagationMap[currentContainer].insert(previousContainer);
    }
}

void PropagatingRelationshipContainer::addContainerToStack(const std::string& currentContainer) {
    containerStack.push(currentContainer);
}

std::string PropagatingRelationshipContainer::peekContainerFromStack() const { return containerStack.top(); }

void PropagatingRelationshipContainer::popContainerFromStack() { containerStack.pop(); }

bool PropagatingRelationshipContainer::isContainerStackEmpty() const { return containerStack.empty(); }

void PropagatingRelationshipContainer::propagateRelationships() {

    std::vector<std::string> topologicallyOrderedContainers = this->topologicalSort(this->relationPropagationMap);
    std::unordered_set<std::string>* relationshipsToPropagate;

    // container is either a statement number or a procedure name
    for (const auto& container : topologicallyOrderedContainers) {
        if (relationPropagationMap.count(container) > 0) {
            // There is a container statement or procedure to propagate to
            relationshipsToPropagate = &relationMap[container];
            const auto& containersToPropagateTo = relationPropagationMap[container];

            for (const auto& containerToPropagateTo : containersToPropagateTo) {
                // Propagate relationships
                relationMap[containerToPropagateTo].insert(relationshipsToPropagate->begin(),
                                                           relationshipsToPropagate->end());
            }
        } else {
            // There is no container statement or procedure to propagate to
        }
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Relationships/PropagatingRelationshipContainer.cpp
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
std::vector<std::string> PropagatingRelationshipContainer::topologicalSort(
    const std::unordered_map<std::string, std::unordered_set<std::string>>& relationPropagationMap) {
    std::unordered_map<std::string, int> indegree;
    std::unordered_map<std::string, std::vector<std::string>> adjacencyList;

    // Calculate the indegree of each node and build the adjacency list
    for (const auto& [key, values] : relationPropagationMap) {
        for (const auto& value : values) {
            indegree[value]++;
            adjacencyList[key].push_back(value);
        }
    }

    std::queue<std::string> q;
    for (const auto& [key, _] : relationPropagationMap) {
        if (indegree[key] == 0) {
            q.push(key);
        }
    }

    std::vector<std::string> result;
    while (!q.empty()) {
        std::string node = q.front();
        q.pop();
        result.push_back(node);

        for (const auto& neighbor : adjacencyList[node]) {
            indegree[neighbor]--;
            if (indegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }

    return result;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/PrintExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void PrintExtractor::extractDesign(const ASTNodePrintStmt& printNode) {
    auto stmtNo = printNode.getStmtNo();

    // Send data to PKB
    this->storeEntity(stmtNo);
}

void PrintExtractor::storeEntity(std::string entity) {
    PrintEntity printEntity;
    printEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(printEntity);
    } else {
        throw InvalidPKBWriterReference("PrintExtractor", "PrintStmt entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/VariableExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void VariableExtractor::extractDesign(const ASTNodeReadStmt& readStmtNode) {
    const auto& varName = readStmtNode.getVarName();

    // Send data to PKB
    this->storeEntity(varName);
}

void VariableExtractor::extractDesign(const ASTNodeAssignStmt& assignStmtNode) {
    const auto& varName = assignStmtNode.getVarName();

    // Send data to PKB
    this->storeEntity(varName);
}

void VariableExtractor::extractDesign(const ASTNodePrintStmt& printStmtNode) {
    const auto& varName = printStmtNode.getVarName();

    // Send data to PKB
    this->storeEntity(varName);
}

void VariableExtractor::extractDesign(const ASTNodeTermExpr& termExprNode) {
    if (termExprNode.isVariable()) {
        const auto& term = termExprNode.getTerm();

        // Send data to PKB
        this->storeEntity(term);
    }
}

void VariableExtractor::storeEntity(std::string entity) {
    VariableEntity variableEntity;
    variableEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(variableEntity);
    } else {
        throw InvalidPKBWriterReference("VariableExtractor", "Variable entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/ConstantExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void ConstantExtractor::extractDesign(const ASTNodeTermExpr& termExprNode) {
    if (termExprNode.isConstant()) {
        const auto& term = termExprNode.getTerm();

        // Send data to PKB
        this->storeEntity(term);
    }
}

void ConstantExtractor::storeEntity(std::string entity) {
    ConstantEntity constantEntity;
    constantEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(constantEntity);
    } else {
        throw InvalidPKBWriterReference("ConstantExtractor", "Constant entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/StmtExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void StmtExtractor::extractDesign(const ASTNodeStmt& stmtNode) {
    auto stmtNo = stmtNode.getStmtNo();

    // Send data to PKB
    this->storeEntity(stmtNo);
}

void StmtExtractor::storeEntity(std::string entity) {
    StatementEntity stmtEntity;
    stmtEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(stmtEntity);
    } else {
        throw InvalidPKBWriterReference("StmtExtractor", "Stmt entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/IfExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void IfExtractor::extractDesign(const ASTNodeIfStmt& ifNode) {
    auto stmtNo = ifNode.getStmtNo();

    // Send data to PKB
    this->storeEntity(stmtNo);
}

void IfExtractor::storeEntity(std::string entity) {
    IfEntity ifEntity;
    ifEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(ifEntity);
    } else {
        throw InvalidPKBWriterReference("IfExtractor", "IfStmt entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/ReadExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void ReadExtractor::extractDesign(const ASTNodeReadStmt& readNode) {
    auto stmtNo = readNode.getStmtNo();

    // Send data to PKB
    this->storeEntity(stmtNo);
}

void ReadExtractor::storeEntity(std::string entity) {
    ReadEntity readEntity;
    readEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(readEntity);
    } else {
        throw InvalidPKBWriterReference("ReadExtractor", "ReadStmt entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/CallExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void CallExtractor::extractDesign(const ASTNodeCallStmt& callNode) {
    auto stmtNo = callNode.getStmtNo();

    // Send data to PKB
    this->storeEntity(stmtNo);
}

void CallExtractor::storeEntity(std::string entity) {
    CallEntity callEntity;
    callEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(callEntity);
    } else {
        throw InvalidPKBWriterReference("CallExtractor", "CallStmt entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/ProcedureExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void ProcedureExtractor::extractDesign(const ASTNodeProcedure& procedureNode) {
    auto procedureName = procedureNode.getProcedureName();

    // Send data to PKB
    this->storeEntity(procedureName);
}

void ProcedureExtractor::storeEntity(std::string entity) {
    ProcedureEntity procedureEntity;
    procedureEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(procedureEntity);
    } else {
        throw InvalidPKBWriterReference("ProcedureExtractor", "Procedure entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/SP/DesignExtractor/Extractors/Entities/AssignExtractor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
void AssignExtractor::extractDesign(const ASTNodeAssignStmt& assignNode) {
    auto stmtNo = assignNode.getStmtNo();

    // Send data to PKB
    this->storeEntity(stmtNo);
}

void AssignExtractor::storeEntity(std::string entity) {
    AssignEntity assignEntity;
    assignEntity.setEntityAttributes(entity);

    if (auto writerShared = this->writer.lock(); writerShared) {
        writerShared->storeEntity(assignEntity);
    } else {
        throw InvalidPKBWriterReference("AssignExtractor", "AssignStmt entities");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/PatternStorage/PatternStorageBase.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once
#include <unordered_map>
#include <unordered_set>
#include <string>

class PatternStorageBase {
    
private:
    std::unordered_map<std::string, std::unordered_set<std::string>> patterns;

public:
    virtual ~PatternStorageBase();
    virtual void addPattern(const std::string& key, const std::string& value);
    virtual bool isEmpty() const;
    virtual std::unordered_set<std::string> getValue(const std::string& key) const;
    virtual std::unordered_set<std::string> getKeys() const;
    virtual bool containsKey(const std::string& key) const;
    virtual std::unordered_map<std::string, std::unordered_set<std::string>> getPatterns() const;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/ProcedureStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/ProcedureEntity.h"

class ProcedureStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/PrintStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/PrintEntity.h"

class PrintStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/EntityStorageBase.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once
#include<unordered_set>
#include<string>
#include "Common/Entities/Entity.h"

class EntityStorageBase {

private:
    std::unordered_set<std::string> entities;

public:
    virtual ~EntityStorageBase();
    virtual void addEntity(const std::string& Entity);
    virtual std::unordered_set<std::string> getEntities() const;
    virtual bool isEmpty() const;
    virtual size_t count() const;
    virtual bool containsEntity(const std::string& Entity) const;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/IfStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/IfEntity.h"

class IfStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/WhileStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/WhileEntity.h"

class WhileStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/AssignStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/AssignEntity.h"

class AssignStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/CallStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/CallEntity.h"

class CallStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/ReadStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/ReadEntity.h"

class ReadStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/VariableStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/VariableEntity.h"

class VariableStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/ConstantStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/ConstantEntity.h"

class ConstantStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/EntityStorageBase.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "EntityStorageBase.h"

EntityStorageBase::~EntityStorageBase() {}


void EntityStorageBase::addEntity(const std::string& Entity) {
    entities.insert(Entity);
}


std::unordered_set<std::string> EntityStorageBase::getEntities() const {
    return entities;
}

bool EntityStorageBase::isEmpty() const {
    return entities.empty();
}

size_t EntityStorageBase::count() const {
    return entities.size();
}

bool EntityStorageBase::containsEntity(const std::string& Entity) const {
    return entities.count(Entity) > 0;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/EntityStorage/StatementStorage.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "EntityStorageBase.h"
#include "Common/Entities/StatementEntity.h"

class StatementStorage : public EntityStorageBase {
public:
    // Uses all the methods from EntityStorageBase, no need to redefine them here
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/ParentTStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' stmtRef ', unordered_set<'stmtRef'>) pairs
class ParentTStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/AbstractionStorageBase.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once
#include <unordered_map>
#include <unordered_set>
#include <string>

class AbstractionStorageBase {

private:
    std::unordered_map<std::string, std::unordered_set<std::string>> relationship;
    std::unordered_map<std::string, std::unordered_set<std::string>> inverseRelationship;

public:
    virtual ~AbstractionStorageBase();
    virtual void addToRelationship(const std::string& key, const std::string& value);
    virtual void addToInverseRelationship(const std::string& key, const std::string& value);
    virtual void addToBoth(const std::string& key, const std::string& value);
    virtual std::unordered_set<std::string> getValue(const std::string& key) const;
    virtual std::unordered_set<std::string> getKeys() const;
    virtual std::unordered_set<std::string> getInvertedValue(const std::string& key) const;
    virtual std::unordered_set<std::string> getInvertedKeys() const;
    virtual bool isEmpty() const;
    virtual bool containsKey(const std::string& key) const;
    virtual bool containsInvertedKey(const std::string& key) const;
    virtual std::unordered_map<std::string, std::unordered_set<std::string>> getRelationship() const;
    virtual std::unordered_map<std::string, std::unordered_set<std::string>> getInverseRelationship() const;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/ModifiesPStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' entRef ', unordered_set<'entRef'>) pairs
class ModifiesPStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/UsesSStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' stmtRef ', unordered_set<'entRef'>) pairs
class UsesSStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/ParentStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' stmtRef ', unordered_set<'stmtRef'>) pairs
class ParentStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/AbstractionStorageBase.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/X0MfnTPRzaKgz1JZaTAPugjk?model=gpt-4&mode=chat
ChatId: X0MfnTPRzaKgz1JZaTAPugjk
Code:
#include "AbstractionStorageBase.h"

AbstractionStorageBase::~AbstractionStorageBase() {}

void AbstractionStorageBase::addToRelationship(const std::string& key, const std::string& value) {
    relationship[key].insert(value);
}

void AbstractionStorageBase::addToInverseRelationship(const std::string& key, const std::string& value) {
    inverseRelationship[key].insert(value);
}

void AbstractionStorageBase::addToBoth(const std::string& key, const std::string& value) {

    // One relationship is stored in two places, so we need to add it to both
    addToRelationship(key, value);
    addToInverseRelationship(value, key);
}

std::unordered_set<std::string> AbstractionStorageBase::getKeys() const {
    std::unordered_set<std::string> keys;
    for (const auto& entry : relationship) {
        keys.insert(entry.first);
    }
    return keys;
}

std::unordered_set<std::string> AbstractionStorageBase::getValue(const std::string& key) const {
    if (relationship.find(key) != relationship.end()) {
        return relationship.at(key);
    }
    return {};
}

std::unordered_set<std::string> AbstractionStorageBase::getInvertedKeys() const {
    std::unordered_set<std::string> keys;
    for (const auto& entry : inverseRelationship) {
        keys.insert(entry.first);
    }
    return keys;
}

std::unordered_set<std::string> AbstractionStorageBase::getInvertedValue(const std::string& key) const {
    if (inverseRelationship.find(key) != inverseRelationship.end()) {
        return inverseRelationship.at(key);
    }
    return {};
}

bool AbstractionStorageBase::isEmpty() const {
    return relationship.empty();
}

bool AbstractionStorageBase::containsKey(const std::string& key) const {
    return relationship.count(key) > 0;
}

bool AbstractionStorageBase::containsInvertedKey(const std::string& key) const {
    return inverseRelationship.count(key) > 0;
}

std::unordered_map<std::string, std::unordered_set<std::string>> AbstractionStorageBase::getRelationship() const {
    return relationship;
}

std::unordered_map<std::string, std::unordered_set<std::string>> AbstractionStorageBase::getInverseRelationship() const {
    return inverseRelationship;
}

// end ai-gen
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/FollowsTStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' stmtRef ', unordered_set<'stmtRef'>) pairs
class FollowsTStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/UsesPStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' entRef ', unordered_set<'entRef'>) pairs
class UsesPStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/FollowsStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' stmtRef ', unordered_set<'stmtRef'>) pairs
class FollowsStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/PKB/AbstractionStorage/ModifiesSStorage.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#pragma once

#include "AbstractionStorageBase.h"

// stores (' stmtRef ', unordered_set<'entRef'> ) pairs
class ModifiesSStorage : public AbstractionStorageBase {
    // No additional methods
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/Patterns/Pattern.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "Pattern.h"
#include <functional> // Add this line


Pattern::~Pattern() {}

void Pattern::setPatternAttributes(const std::string& keyAttribute, const std::string& valueAttribute) {
    key = keyAttribute;
    value = valueAttribute;
}

void Pattern::findValue(const std::string& queryKey) {
    key = queryKey;
}

std::string Pattern::getKey() {
    return key;
}

std::string Pattern::getValue() {
    return value;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/ITokenizer/ITokenizer.h
Generator: gpt
Intervention: 0
Language: e
Prompt: 
ChatId: 
Code:
// Tokenizer assistant used - THREAD: thread_Wu21Pq3DmbgzHOCkgLlUbx2j

#ifndef ITOKENIZER_H
#define ITOKENIZER_H

#include <vector>
#include "../../SP/Tokens/SPToken.h"

class ITokenizer {
public:
    // Ensure proper cleanup with a virtual destructor
    virtual ~ITokenizer() {}

    // Pure virtual function for tokenizing a string
    virtual std::vector<SPToken> tokenize() = 0;
};

#endif
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/Exceptions/SyntaxError.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef COMMON_EXCEPTIONS_SYNTAXERROR_H_
#define COMMON_EXCEPTIONS_SYNTAXERROR_H_

#include <string>
#include <stdexcept>

class SyntaxError : public std::runtime_error
{
private:
    std::string message;

public:
    SyntaxError(std::string message);
};

#endif // COMMON_EXCEPTIONS_SYNTAXERROR_H_

// ai-gen-end
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/Exceptions/SyntaxError.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "SyntaxError.h"

SyntaxError::SyntaxError(std::string message) : std::runtime_error(message) {}

// ai-gen-end
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/Exceptions/SemanticError.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#ifndef COMMON_EXCEPTIONS_SEMANTICERROR_H_
#define COMMON_EXCEPTIONS_SEMANTICERROR_H_

#include <string>
#include <stdexcept>

class SemanticError : public std::runtime_error
{
private:
    std::string message;

public:
    SemanticError(std::string message);
};

#endif // COMMON_EXCEPTIONS_SEMANTICERROR_H_

// ai-gen-end
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/Exceptions/SemanticError.cpp
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "SemanticError.h"

SemanticError::SemanticError(std::string message) : std::runtime_error(message) {}

// ai-gen-end
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/Relationships/Relationship.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "Relationship.h"

Relationship::~Relationship() {}

void Relationship::setRelationshipAttributes(const std::string& keyAttribute, const std::string& valueAttribute) {
    key = keyAttribute;
    value = valueAttribute;
}

void Relationship::findValue(const std::string& queryKey) {
    key = queryKey;
}

std::string Relationship::getKey() {
    return key;
}

std::string Relationship::getValue() {
    return value;
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/spa/src/Common/Entities/Entity.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "Entity.h"

Entity::~Entity() = default;

void Entity::setEntityAttributes(const std::string& entity){
    attribute = entity;
};

std::string Entity::getEntityAttributes(){
    return attribute;
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestQueryProcessor.cpp
Generator: copilot
Intervention: 2
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "QPS/QueryProcessors/QueryProcessor.h"
#include "QPS/AbstractQuery/AbstractQuery.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ParentClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ModifiesSClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"
#include "QPS/AbstractQuery/References/SynonymRef.h"
#include "QPS/AbstractQuery/References/IntegerRef.h"
#include "QPS/AbstractQuery/References/WildcardRef.h"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/AbstractQuery/Declaration.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/EntityDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/AssignRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/CallRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ConstantRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/PrintRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ProcedureRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ReadRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/StatementRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/VariableRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/WhileRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ParentRetriever.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ParentClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/SuchThatClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/QueryProcessorStrategy.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"
#include "PKB/API/Retrieve.h"
#include "PKB/API/Store.h"
#include "PKB/PKB.h"

#include "catch.hpp"

TEST_CASE("Test QueryProcessor")
{
    std::shared_ptr<PKB> mockPKB = std::make_shared<PKB>();
    IfEntity if1 = IfEntity();
    if1.setEntityAttributes("1");
    IfEntity if2 = IfEntity();
    if2.setEntityAttributes("3");
    IfEntity if3 = IfEntity();
    if3.setEntityAttributes("5");
    mockPKB->storeEntity(if1);
    mockPKB->storeEntity(if2);
    mockPKB->storeEntity(if3);
    CallEntity call1 = CallEntity();
    call1.setEntityAttributes("2");
    CallEntity call2 = CallEntity();
    call2.setEntityAttributes("4");
    CallEntity call3 = CallEntity();
    call3.setEntityAttributes("6");
    mockPKB->storeEntity(call1);
    mockPKB->storeEntity(call2);
    mockPKB->storeEntity(call3);
    ParentRelationship parent1 = ParentRelationship();
    parent1.setRelationshipAttributes("1", "2");
    ParentRelationship parent2 = ParentRelationship();
    parent2.setRelationshipAttributes("3", "4");
    ParentRelationship parent3 = ParentRelationship();
    parent3.setRelationshipAttributes("3", "5");
    ParentRelationship parent4 = ParentRelationship();
    parent4.setRelationshipAttributes("3", "6");
    ParentRelationship parent5 = ParentRelationship();
    parent5.setRelationshipAttributes("5", "6");
    mockPKB->storeRelationship(parent1);
    mockPKB->storeRelationship(parent2);
    mockPKB->storeRelationship(parent3);
    mockPKB->storeRelationship(parent4);

    mockPKB->storeRelationship(parent5);
    std::vector<Declaration> declarations;
    declarations.push_back(Declaration("if", "i"));
    declarations.push_back(Declaration("call", "c"));
    std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
    Ref leftRef = SynonymRef("i");
    Ref rightRef = SynonymRef("c");
    abstractQuery->addSuchThatClause("Parent", leftRef, rightRef);

    // Ref leftRef2 = SynonymRef("z");
    // Ref rightRef2 = WildcardRef("_");
    // abstractQuery->addSuchThatClause("Parent", leftRef, rightRef);
    SelectProjection selectProjection = SelectProjection(DesignEntityType::IF, Synonym("i"));
    QueryProcessor processor;
    std::list<std::string> results;
    std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
    processor.processQuery(results, clauseResultTableManager, abstractQuery, mockPKB);
    results.push_back("1");
    REQUIRE(results.size() == 1);
    REQUIRE(results.front() == "1");
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestDeclaration.cpp
Generator: copilot
Intervention: 2
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "QPS/AbstractQuery/Declaration.h"
#include "catch.hpp"

TEST_CASE("Declaration test if type and synonym are correctly stored")
{
    Declaration d(DesignEntityType::ASSIGN, Synonym("a"));
    REQUIRE(d.getDesignEntityType() == DesignEntityType::ASSIGN);
    REQUIRE(d.getSynonym().getName() == "a");
}

TEST_CASE("Declaration test if type and synonym are correctly stored with string inputs")
{
    Declaration d("assign", "a");
    REQUIRE(d.getDesignEntityType() == DesignEntityType::ASSIGN);
    REQUIRE(d.getSynonym().getName() == "a");
}

TEST_CASE("Declaration test if invalid DesignEntity string throws exception")
{
    REQUIRE_THROWS(Declaration("wrong", "a"));
}

TEST_CASE("Declaration test if invalid DesignEntity type throws exception")
{
    Declaration d(static_cast<DesignEntityType>(-1), Synonym("a")); // cast to invalid Enum type
    DesignEntityType invalid = d.getDesignEntityType();
    REQUIRE_THROWS(getDesignEntityStringFromType(invalid));
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestPatternProcessor.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "PKB/API/Retrieve.h"
#include "PKB/API/Store.h"
#include "PKB/PKB.h"
#include "QPS/AbstractQuery/References/Ref.h"
#include "QPS/AbstractQuery/References/SynonymRef.h"
#include "QPS/AbstractQuery/References/IntegerRef.h"
#include "QPS/AbstractQuery/References/WildcardRef.h"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/AbstractQuery/Declaration.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/EntityDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/AssignRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/CallRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ConstantRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/PrintRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ProcedureRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ReadRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/StatementRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/VariableRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/WhileRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/PatternDataRetrievers/PatternDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/PatternDataRetrievers/AssignPatternRetriever.h"
#include "QPS/QueryProcessors/Processors/PatternProcessors/PatternProcessor.h"
#include "QPS/QueryProcessors/Processors/PatternProcessors/AssignPatternProcessor.h"

#include "catch.hpp"

TEST_CASE("Test AssignPatternProcessor")
{
    std::shared_ptr<PKB> mockPKB = std::make_shared<PKB>();
    AssignPattern aPattern;
    AssignPattern bPattern;
    aPattern.setPatternAttributes("1", "x 1 +");
    bPattern.setPatternAttributes("2", "y 1 +");
    mockPKB->storePattern(aPattern);
    mockPKB->storePattern(bPattern);
    StatementEntity s1 = StatementEntity();
    s1.setEntityAttributes("1");
    StatementEntity s2 = StatementEntity();
    s2.setEntityAttributes("2");
    StatementEntity s3 = StatementEntity();
    s3.setEntityAttributes("3");
    mockPKB->storeEntity(s1);
    mockPKB->storeEntity(s2);
    mockPKB->storeEntity(s3);
    std::vector<Declaration> declarations;
    declarations.push_back(Declaration("stmt", "s"));
    SECTION("Test pattern with leftRef Synonym")
    {
        ExpressionSpec expressionSpec = ExpressionSpec("x 1 +");
        std::shared_ptr<PatternProcessor> patternProcessor = std::make_shared<AssignPatternProcessor>(SynonymRef("s"), expressionSpec);
        std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
        REQUIRE(patternProcessor->processQuery(clauseResultTableManager, mockPKB, declarations));
        std::shared_ptr<ClauseResultTable> table = clauseResultTableManager->getUngroupedTable();
        std::vector<std::string> headers = table->getHeaders();
        std::vector<std::vector<std::string>> rows = table->getRows();
        REQUIRE(headers.size() == 1);
        REQUIRE(headers[0] == "s");
        REQUIRE(rows.size() == 1);
        REQUIRE(rows[0].size() == 1);
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test pattern with leftRef Wildcard")
    {
        ExpressionSpec expressionSpec = ExpressionSpec("x 1 +");
        std::shared_ptr<PatternProcessor> patternProcessor = std::make_shared<AssignPatternProcessor>(WildcardRef("_"), expressionSpec);
        std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
        REQUIRE(patternProcessor->processQuery(clauseResultTableManager, mockPKB, declarations));
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test pattern with leftRef Wildcard with empty assign storage from pkb")
    {
        std::shared_ptr<PKB> emptyPKB = std::make_shared<PKB>();
        ExpressionSpec expressionSpec = ExpressionSpec("x 1 +");
        std::shared_ptr<PatternProcessor> patternProcessor = std::make_shared<AssignPatternProcessor>(WildcardRef("_"), expressionSpec);
        std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
        REQUIRE_FALSE(patternProcessor->processQuery(clauseResultTableManager, emptyPKB, declarations));
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test pattern with valid leftRef Integer")
    {
        ExpressionSpec expressionSpec = ExpressionSpec("x 1 +");
        std::shared_ptr<PatternProcessor> patternProcessor = std::make_shared<AssignPatternProcessor>(IntegerRef("1"), expressionSpec);
        std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
        REQUIRE(patternProcessor->processQuery(clauseResultTableManager, mockPKB, declarations));
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty());
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test pattern with invalid leftRef Integer")
    {
        ExpressionSpec expressionSpec = ExpressionSpec("x 1 +");
        std::shared_ptr<PatternProcessor> patternProcessor = std::make_shared<AssignPatternProcessor>(IntegerRef("99"), expressionSpec);
        std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
        REQUIRE_FALSE(patternProcessor->processQuery(clauseResultTableManager, mockPKB, declarations));
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty());
        clauseResultTableManager->clearAllTables();
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestClauseResultTableManager.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "catch.hpp"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/ClauseResultTable.h"

TEST_CASE("Test merging of two tables")
{
    SECTION("Merging two tables with no common headers")
    {
        ClauseResultTableManager manager;
        ClauseResultTable table1;
        table1.addHeader("v");
        table1.addRow({"1"});
        table1.addRow({"2"});

        ClauseResultTable table2;
        table2.addHeader("a");
        table2.addRow({"3"});
        table2.addRow({"4"});
        manager.addUngroupedTable(table1);
        manager.addUngroupedTable(table2);
        manager.generateFinalResultTable();
        std::shared_ptr<ClauseResultTable> finalResultTable = manager.getFinalResultTable();

        REQUIRE(finalResultTable->getHeaders() == std::vector<std::string>{"v", "a"});

        REQUIRE(finalResultTable->getRows() == std::vector<std::vector<std::string>>{{"1", "3"}, {"1", "4"}, {"2", "3"}, {"2", "4"}});
        manager.clearAllTables();
    }

    SECTION("Merging two tables with common headers")
    {
        ClauseResultTableManager manager;
        ClauseResultTable table1;
        table1.addHeader("v");
        table1.addRow({"1"});
        table1.addRow({"2"});

        ClauseResultTable table2;
        table2.addHeader("v");
        table2.addRow({"3"});
        table2.addRow({"4"});

        manager.addUngroupedTable(table1);
        manager.addUngroupedTable(table2);
        manager.generateFinalResultTable();

        REQUIRE(manager.getFinalResultTable()->getHeaders() == std::vector<std::string>{"v"});
        REQUIRE(manager.getFinalResultTable()->getRows() == std::vector<std::vector<std::string>>{{"1"}, {"2"}, {"3"}, {"4"}});
        manager.clearAllTables();
    }

    SECTION("Merging two tables with common and non-common headers")
    {
        ClauseResultTableManager manager;
        ClauseResultTable table1;
        table1.addHeader("v");
        table1.addHeader("a");
        table1.addRow({"1", "5"});
        table1.addRow({"2", "6"});
        table1.addRow({"3", "6"});

        ClauseResultTable table2;
        table2.addHeader("v");
        table2.addHeader("b");
        table2.addRow({"3", "7"});
        table2.addRow({"4", "8"});

        manager.addUngroupedTable(table1);
        manager.addUngroupedTable(table2);
        manager.generateFinalResultTable();

        REQUIRE(manager.getFinalResultTable()->getHeaders() == std::vector<std::string>{"v", "a", "b"});

        REQUIRE(manager.getFinalResultTable()->getRows() == std::vector<std::vector<std::string>>{{"3", "6", "7"}});
        manager.clearAllTables();
    }

    SECTION("Merging two tables with empty rows")
    {
        ClauseResultTableManager manager;
        ClauseResultTable table1;
        table1.addHeader("v");
        table1.addRow({"1"});
        table1.addRow({"2"});

        ClauseResultTable table2;
        table2.addHeader("v");
        table2.addRow({""});
        table2.addRow({""});

        manager.addUngroupedTable(table1);
        manager.addUngroupedTable(table2);
        manager.generateFinalResultTable();

        REQUIRE(manager.getFinalResultTable()->getHeaders() == std::vector<std::string>{"v"});
        REQUIRE(manager.getFinalResultTable()->getRows() == std::vector<std::vector<std::string>>{{"1"}, {"2"}, {""}, {""}});
        manager.clearAllTables();
    }
}

TEST_CASE("Test clearing of tables")
{
    ClauseResultTableManager manager;
    ClauseResultTable table;
    table.addHeader("v");
    table.addRow({"1"});
    table.addRow({"2"});

    manager.addUngroupedTable(table);
    manager.createGroup();
    manager.clearAllTables();

    REQUIRE(manager.isUngroupedTableEmpty());
    REQUIRE(manager.getFinalResultTable()->getHeaders().empty());
    REQUIRE(manager.getFinalResultTable()->getRows().empty());
}

TEST_CASE("Merging on table")
{
    ClauseResultTableManager manager;
    ClauseResultTable table;
    table.addHeader("v");
    table.addRow({"1"});
    table.addRow({"2"});

    manager.addUngroupedTable(table);
    manager.generateFinalResultTable();

    REQUIRE(manager.getFinalResultTable()->getHeaders() == std::vector<std::string>{"v"});
    REQUIRE(manager.getFinalResultTable()->getRows() == std::vector<std::vector<std::string>>{{"1"}, {"2"}});
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestClauseResultTableEvaluator.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "catch.hpp"
#include "QPS/QueryProcessors/ClauseResultTableEvaluator.h"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/ClauseResultTable.h"
#include <list>
#include <string>
#include <memory>
#include <vector>

TEST_CASE("Test evaluateQuery")
{
    std::list<std::string> results;
    std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
    SECTION("Empty result table")
    {
        std::list<std::string> results;
        std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
        std::vector<std::string> selectProjectionSynonyms;

        ClauseResultTableEvaluator evaluator;
        evaluator.evaluateQuery(results, clauseResultTableManager, selectProjectionSynonyms);

        REQUIRE(results.empty());
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Non-empty result table")
    {
        std::vector<std::string> selectProjectionSynonyms = {"x", "y", "z"};

        std::shared_ptr<ClauseResultTable> table = std::make_shared<ClauseResultTable>();
        std::vector<std::string> headers = {"x", "y", "z"};
        table->addHeaders(headers);
        table->addRow({"1", "2", "3"});
        table->addRow({"4", "5", "6"});
        clauseResultTableManager->addUngroupedTable(*table);
        clauseResultTableManager->generateFinalResultTable();

        std::shared_ptr<ClauseResultTable> finalTable = clauseResultTableManager->getFinalResultTable();

        ClauseResultTableEvaluator evaluator;
        evaluator.evaluateQuery(results, clauseResultTableManager, selectProjectionSynonyms);

        REQUIRE(results.size() == 2);
        REQUIRE(results.front() == "123");
        results.pop_front();
        REQUIRE(results.front() == "456");
        clauseResultTableManager->clearAllTables();
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestSuchThatClauseProcessor.cpp
Generator: copilot
Intervention: 2
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ParentClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ModifiesSClauseProcessor.h"
#include "QPS/AbstractQuery/References/Ref.h"
#include "QPS/AbstractQuery/References/SynonymRef.h"
#include "QPS/AbstractQuery/References/IntegerRef.h"
#include "QPS/AbstractQuery/References/WildcardRef.h"
#include "QPS/ClauseResultTableManager.h"
#include "QPS/AbstractQuery/Declaration.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/EntityDataRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/AssignRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/CallRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ConstantRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/PrintRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ProcedureRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/ReadRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/StatementRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/VariableRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/WhileRetriever.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/RelationshipDataRetrievers/ParentRetriever.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/ParentClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/SuchThatProcessors/SuchThatClauseProcessor.h"
#include "QPS/QueryProcessors/Processors/QueryProcessorStrategy.h"
#include "QPS/QueryProcessors/PKBDataRetrievers/EntityDataRetrievers/IfRetriever.h"

#include "PKB/API/Retrieve.h"
#include "PKB/API/Store.h"
#include "PKB/PKB.h"

#include "catch.hpp"

TEST_CASE("Test ParentClauseProcessor")
{
    std::shared_ptr<PKB> mockPKB = std::make_shared<PKB>();
    IfEntity if1 = IfEntity();
    if1.setEntityAttributes("1");
    IfEntity if2 = IfEntity();
    if2.setEntityAttributes("3");
    IfEntity if3 = IfEntity();
    if3.setEntityAttributes("5");
    mockPKB->storeEntity(if1);
    mockPKB->storeEntity(if2);
    mockPKB->storeEntity(if3);
    CallEntity call1 = CallEntity();
    call1.setEntityAttributes("2");
    CallEntity call2 = CallEntity();
    call2.setEntityAttributes("4");
    CallEntity call3 = CallEntity();
    call3.setEntityAttributes("6");
    mockPKB->storeEntity(call1);
    mockPKB->storeEntity(call2);
    mockPKB->storeEntity(call3);
    ParentRelationship parent1 = ParentRelationship();
    parent1.setRelationshipAttributes("1", "2");
    ParentRelationship parent2 = ParentRelationship();
    parent2.setRelationshipAttributes("3", "4");
    ParentRelationship parent3 = ParentRelationship();
    parent3.setRelationshipAttributes("3", "5");
    ParentRelationship parent4 = ParentRelationship();
    parent4.setRelationshipAttributes("3", "6");
    ParentRelationship parent5 = ParentRelationship();
    parent5.setRelationshipAttributes("5", "6");
    mockPKB->storeRelationship(parent1);
    mockPKB->storeRelationship(parent2);
    mockPKB->storeRelationship(parent3);
    mockPKB->storeRelationship(parent4);
    mockPKB->storeRelationship(parent5);
    std::vector<Declaration> declarations;
    declarations.push_back(Declaration("if", "i"));
    declarations.push_back(Declaration("call", "c"));
    std::shared_ptr<ClauseResultTableManager> clauseResultTableManager = std::make_shared<ClauseResultTableManager>();
    SECTION("Test query with 2 synonyms")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(SynonymRef("i"), SynonymRef("c"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        auto result = clauseResultTableManager->getUngroupedTable();
        REQUIRE(result->getHeaders() == std::vector<std::string>{"i", "c"});
        REQUIRE(result->getRow(0) == std::vector<std::string>{"1", "2"});
        REQUIRE(result->getRow(1) == std::vector<std::string>{"3", "4"});
        REQUIRE(result->getRow(2) == std::vector<std::string>{"3", "6"});
        REQUIRE(result->getRowCount() == 4);
        clauseResultTableManager->generateFinalResultTable();
        auto finalTable = clauseResultTableManager->getFinalResultTable();
        REQUIRE(finalTable->getHeaders() == std::vector<std::string>{"i", "c"});
        REQUIRE(finalTable->getRowCount() == 4);
        std::vector<std::string> finalColumnHeaders = {"i"};
        finalTable->filterColumns(finalColumnHeaders);
        REQUIRE(finalTable->getHeaders() != std::vector<std::string>{"c"});
        REQUIRE(finalTable->getHeaders() == std::vector<std::string>{"i"});
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test query with leftRef as a synoym and rightref as a NAME/INTEGER")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(SynonymRef("i"), IntegerRef("6"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        auto result = clauseResultTableManager->getUngroupedTable();
        REQUIRE(result->getHeaders() == std::vector<std::string>{"i"});
        REQUIRE(result->getRowCount() == 2);
        REQUIRE(result->getRow(0) == std::vector<std::string>{"3"});
        REQUIRE(result->getRow(1) == std::vector<std::string>{"5"});
        clauseResultTableManager->generateFinalResultTable();
        auto finalTable = clauseResultTableManager->getFinalResultTable();
        REQUIRE(finalTable->getHeaders() == std::vector<std::string>{"i"});
        REQUIRE(finalTable->getRowCount() == 2);
        clauseResultTableManager->clearAllTables();
    }
    SECTION("Test query with leftRef as a synoym and rightref as a WILDCARD")

    {
        auto processor = std::make_shared<ParentClauseProcessor>(SynonymRef("i"), WildcardRef("_"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        auto result = clauseResultTableManager->getUngroupedTable();
        REQUIRE(result->getHeaders() == std::vector<std::string>{"i"});
        REQUIRE(result->getRowCount() == 3);
        REQUIRE(result->getRow(0) == std::vector<std::string>{"1"});
        REQUIRE(result->getRow(1) == std::vector<std::string>{"3"});
        REQUIRE(result->getRow(2) == std::vector<std::string>{"5"});
        clauseResultTableManager->generateFinalResultTable();
        auto finalTable = clauseResultTableManager->getFinalResultTable();
        REQUIRE(finalTable->getHeaders() == std::vector<std::string>{"i"});
        REQUIRE(finalTable->getRowCount() == 3);
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test query with leftRef as a NAME/INTEGER and rightref as a synoym")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(IntegerRef("3"), SynonymRef("c"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        auto result = clauseResultTableManager->getUngroupedTable();
        REQUIRE(result->getHeaders() == std::vector<std::string>{"c"});
        REQUIRE(result->getRowCount() == 2);
        REQUIRE(result->getRow(0) == std::vector<std::string>{"4"});
        REQUIRE(result->getRow(1) == std::vector<std::string>{"6"});
        clauseResultTableManager->generateFinalResultTable();
        auto finalTable = clauseResultTableManager->getFinalResultTable();
        REQUIRE(finalTable->getHeaders() == std::vector<std::string>{"c"});
        REQUIRE(finalTable->getRowCount() == 2);
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test query with leftRef as a WILDCARD and rightref as a synoym")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(WildcardRef("_"), SynonymRef("c"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        auto result = clauseResultTableManager->getUngroupedTable();
        REQUIRE(result->getHeaders() == std::vector<std::string>{"c"});
        REQUIRE(result->getRowCount() == 3);
        REQUIRE(result->getRow(0) == std::vector<std::string>{"2"});
        REQUIRE(result->getRow(1) == std::vector<std::string>{"4"});
        REQUIRE(result->getRow(2) == std::vector<std::string>{"6"});
        clauseResultTableManager->generateFinalResultTable();
        auto finalTable = clauseResultTableManager->getFinalResultTable();
        REQUIRE(finalTable->getHeaders() == std::vector<std::string>{"c"});
        REQUIRE(finalTable->getRowCount() == 3);
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test query with leftRef as a WILDCARD and rightref as a WILDCARD")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(WildcardRef("_"), WildcardRef("_"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty() == true);
        auto emptyProcessor = std::make_shared<ModifiesSClauseProcessor>(WildcardRef("_"), WildcardRef("_"));
        REQUIRE(emptyProcessor->processQuery(clauseResultTableManager, mockPKB, declarations) == false);
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test query with leftRef as a NAME/INTEGER and rightref as a NAME/INTEGER")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(IntegerRef("3"), IntegerRef("6"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty() == true);
        clauseResultTableManager->clearAllTables();
        auto falseProcessor = std::make_shared<ModifiesSClauseProcessor>(IntegerRef("70"), IntegerRef("6"));
        REQUIRE(falseProcessor->processQuery(clauseResultTableManager, mockPKB, declarations) == false);
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty() == true);
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test query with leftRef as a NAME/INTEGER and rightref as a WILDCARD")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(IntegerRef("3"), WildcardRef("_"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty() == true);
        clauseResultTableManager->clearAllTables();
        auto falseProcessor = std::make_shared<ModifiesSClauseProcessor>(IntegerRef("70"), WildcardRef("_"));
        REQUIRE(falseProcessor->processQuery(clauseResultTableManager, mockPKB, declarations) == false);
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty() == true);
        clauseResultTableManager->clearAllTables();
    }

    SECTION("Test query with leftRef as a WILDCARD and rightref as a NAME/INTEGER")
    {
        auto processor = std::make_shared<ParentClauseProcessor>(WildcardRef("_"), IntegerRef("6"));
        REQUIRE(processor->processQuery(clauseResultTableManager, mockPKB, declarations) == true);
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty() == true);
        clauseResultTableManager->clearAllTables();
        auto falseProcessor = std::make_shared<ModifiesSClauseProcessor>(WildcardRef("_"), IntegerRef("70"));
        REQUIRE(falseProcessor->processQuery(clauseResultTableManager, mockPKB, declarations) == false);
        REQUIRE(clauseResultTableManager->isUngroupedTableEmpty() == true);
        clauseResultTableManager->clearAllTables();
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestSuchThatClause.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/FollowsClause.h"
#include "QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/ModifiesPClause.h"
#include "QPS/AbstractQuery/Clauses/SuchThatClauses/ConcreteClauses/ModifiesSClause.h"
#include "QPS/AbstractQuery/References/SynonymRef.h"
#include "QPS/AbstractQuery/References/IntegerRef.h"
#include "QPS/AbstractQuery/References/NameRef.h"

#include "catch.hpp"

TEST_CASE("Test FollowsClause (IntegerRef, IntegerRef)")
{
    FollowsClause fc(IntegerRef("1"), IntegerRef("2"));

    REQUIRE(fc.getLeftRef().getValue() == "1");
    REQUIRE(fc.getLeftRef().getRefType() == Ref::RefType::STMT_REF);
    REQUIRE(fc.getLeftRef().getRefSubType() == Ref::RefSubType::INTEGER);
    REQUIRE(fc.getRightRef().getValue() == "2");
    REQUIRE(fc.getRightRef().getRefType() == Ref::RefType::STMT_REF);
    REQUIRE(fc.getRightRef().getRefSubType() == Ref::RefSubType::INTEGER);
}

TEST_CASE("Test FollowsClause (SynonymRef, SynonymRef)")
{
    FollowsClause fc(SynonymRef("s"), SynonymRef("s2"));

    REQUIRE(fc.getLeftRef().getValue() == "s");
    REQUIRE(fc.getLeftRef().getRefType() == Ref::RefType::UNDECIDED_REF);
    REQUIRE(fc.getLeftRef().getRefSubType() == Ref::RefSubType::SYNONYM);
    REQUIRE(fc.getRightRef().getValue() == "s2");
    REQUIRE(fc.getRightRef().getRefType() == Ref::RefType::UNDECIDED_REF);
    REQUIRE(fc.getRightRef().getRefSubType() == Ref::RefSubType::SYNONYM);
}

TEST_CASE("Test ModifiesPClause (NameRef, NameRef)")
{
    ModifiesPClause mpc(NameRef("proc_name"), NameRef("y"));

    REQUIRE(mpc.getLeftRef().getValue() == "proc_name");
    REQUIRE(mpc.getLeftRef().getRefType() == Ref::RefType::ENT_REF);
    REQUIRE(mpc.getLeftRef().getRefSubType() == Ref::RefSubType::NAME);
    REQUIRE(mpc.getRightRef().getValue() == "y");
    REQUIRE(mpc.getRightRef().getRefType() == Ref::RefType::ENT_REF);
    REQUIRE(mpc.getRightRef().getRefSubType() == Ref::RefSubType::NAME);
}

TEST_CASE("Test ModifiesSClause (IntegerRef, NameRef)")
{
    ModifiesSClause msc(IntegerRef("1"), NameRef("x"));

    REQUIRE(msc.getLeftRef().getValue() == "1");
    REQUIRE(msc.getLeftRef().getRefType() == Ref::RefType::STMT_REF);
    REQUIRE(msc.getLeftRef().getRefSubType() == Ref::RefSubType::INTEGER);
    REQUIRE(msc.getRightRef().getValue() == "x");
    REQUIRE(msc.getRightRef().getRefType() == Ref::RefType::ENT_REF);
    REQUIRE(msc.getRightRef().getRefSubType() == Ref::RefSubType::NAME);
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/QPS/TestQueryValidator.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "QPS/QueryValidator.h"
#include "QPS/AbstractQuery/AbstractQuery.h"
#include "QPS/AbstractQuery/References/SynonymRef.h"
#include "QPS/AbstractQuery/References/IntegerRef.h"
#include "QPS/AbstractQuery/References/NameRef.h"
#include "QPS/AbstractQuery/References/WildcardRef.h"

#include "catch.hpp"

TEST_CASE("Test QueryValidator validateDeclarations")
{
    SECTION("Test validateDeclarations")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("assign", "a");
        abstractQuery->addSelectProjectionSynonym("s");
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
    }

    SECTION("Test validateDeclarations with duplicate declaration")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("assign", "s");
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }
}

TEST_CASE("Test QueryValidator validateSelectProjections")
{

    SECTION("Test validateSelectProjections default")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("assign", "s");
        abstractQuery->addSelectProjectionSynonym("s");
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
        SelectProjection selectProjection = abstractQuery->getSelectProjections().at(0);
        REQUIRE(selectProjection.getSynonym().getName() == "s");
        REQUIRE(selectProjection.getDesignEntityType() == DesignEntityType::ASSIGN);
        REQUIRE(abstractQuery->getSelectProjections().size() == 1);

        // Check that it correctly converts the select projection synonyms to a SelectProjection object
        REQUIRE(abstractQuery->getSelectProjections().at(0).getSynonym().getName() == "s");
        REQUIRE(abstractQuery->getSelectProjections().at(0).getDesignEntityType() == DesignEntityType::ASSIGN);
    }

    SECTION("Test validateSelectProjections with no select projection synonym")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validateSelectProjections with multiple select projection synonyms")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("assign", "a");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSelectProjectionSynonym("a");
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validateSelectProjections with undeclared select projection synonym")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addSelectProjectionSynonym("a");
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }
}

TEST_CASE("Test QueryValidator validateSuchThatClauses")
{

    SECTION("Test validateSuchThatClauses with stmt numbers in Parent suchThatClause")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("assign", "a");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Parent", IntegerRef("1"), IntegerRef("2"));
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::PARENT);
        REQUIRE(suchThatClause->getLeftRef().getValue() == "1");
        REQUIRE(suchThatClause->getRightRef().getValue() == "2");
        REQUIRE(suchThatClause->getLeftRef().getRefSubType() == Ref::RefSubType::INTEGER);
        REQUIRE(suchThatClause->getRightRef().getRefSubType() == Ref::RefSubType::INTEGER);
        REQUIRE(suchThatClause->getLeftRef().getRefType() == Ref::RefType::STMT_REF);
        REQUIRE(suchThatClause->getRightRef().getRefType() == Ref::RefType::STMT_REF);
    }

    SECTION("Test validateSuchThatClauses with synonyms in Parent suchThatClause")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("assign", "a");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Parent", SynonymRef("s"), SynonymRef("a"));
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::PARENT);
        REQUIRE(suchThatClause->getLeftRef().getValue() == "s");
        REQUIRE(suchThatClause->getRightRef().getValue() == "a");
        REQUIRE(suchThatClause->getLeftRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getRightRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getLeftRef().getRefType() == Ref::RefType::STMT_REF);
        REQUIRE(suchThatClause->getRightRef().getRefType() == Ref::RefType::STMT_REF);
    }

    SECTION("Test validateSuchThatClauses Parent clause with SynonymRef (entRef) and SynonymRef (stmtRef) should throw error")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("variable", "v");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Parent", SynonymRef("v"), SynonymRef("s"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validateSuchThatClauses Parent clause with SynonymRef (entRef) and SynonymRef (entRef) should throw error")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("procedure", "proc");
        abstractQuery->addDeclaration("variable", "v");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Parent", SynonymRef("v"), SynonymRef("proc"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validateSuchThatClauses Parent clause with SynonymRef (stntRef) and SynonymRef (entRef) should throw error")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("variable", "v");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Parent", SynonymRef("s"), SynonymRef("v"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validateSuchThatClauses Modifies clause with SynonymRef (stmtRef) and SynonymRef (entRef)")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("variable", "v");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Modifies", SynonymRef("s"), SynonymRef("v"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::MODIFIES_UNDECIDED); // Check that it changes

        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
        suchThatClause = abstractQuery->getSuchThatClauses().at(0);

        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::MODIFIES_S);
        REQUIRE(suchThatClause->getLeftRef().getValue() == "s");
        REQUIRE(suchThatClause->getRightRef().getValue() == "v");
        REQUIRE(suchThatClause->getLeftRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getRightRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getLeftRef().getRefType() == Ref::RefType::STMT_REF);
        REQUIRE(suchThatClause->getRightRef().getRefType() == Ref::RefType::ENT_REF);
    }

    SECTION("Test validateSuchThatClauses Modifies clause with SynonymRef (entRef) and SynonymRef (entRef)")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("procedure", "proc");
        abstractQuery->addDeclaration("variable", "v");
        abstractQuery->addSelectProjectionSynonym("v");
        abstractQuery->addSuchThatClause("Modifies", SynonymRef("proc"), SynonymRef("v"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::MODIFIES_UNDECIDED); // Check that it changes

        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
        suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::MODIFIES_P);
        REQUIRE(suchThatClause->getLeftRef().getValue() == "proc");
        REQUIRE(suchThatClause->getRightRef().getValue() == "v");
        REQUIRE(suchThatClause->getLeftRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getRightRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getLeftRef().getRefType() == Ref::RefType::ENT_REF);
        REQUIRE(suchThatClause->getRightRef().getRefType() == Ref::RefType::ENT_REF);
    }

    SECTION("Test validateSuchThatClauses Modifies clause with SynonymRef (stmtRef) and SynonymRef (stmtRef) should throw error")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addDeclaration("assign", "a");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Modifies", SynonymRef("s"), SynonymRef("a"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validateSuchThatClauses Modifies clause with SynonymRef (stmtRef) and NameRef (entRef)")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Modifies", SynonymRef("s"), NameRef("var"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
        suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::MODIFIES_S);
        REQUIRE(suchThatClause->getLeftRef().getValue() == "s");
        REQUIRE(suchThatClause->getRightRef().getValue() == "var");
        REQUIRE(suchThatClause->getLeftRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getRightRef().getRefSubType() == Ref::RefSubType::NAME);
        REQUIRE(suchThatClause->getLeftRef().getRefType() == Ref::RefType::STMT_REF);
        REQUIRE(suchThatClause->getRightRef().getRefType() == Ref::RefType::ENT_REF);
    }

    SECTION("Test validateSuchThatClauses Modifies clause with SynonymRef (stmtRef) and wildCard (undecidedRef)")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Modifies", SynonymRef("s"), WildcardRef("_"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());
        suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        REQUIRE(suchThatClause->getSuchThatRelationship() == SuchThatClause::SuchThatRelationship::MODIFIES_S);
        REQUIRE(suchThatClause->getLeftRef().getValue() == "s");
        REQUIRE(suchThatClause->getRightRef().getValue() == "_");
        REQUIRE(suchThatClause->getLeftRef().getRefSubType() == Ref::RefSubType::SYNONYM);
        REQUIRE(suchThatClause->getRightRef().getRefSubType() == Ref::RefSubType::WILDCARD);
        REQUIRE(suchThatClause->getLeftRef().getRefType() == Ref::RefType::STMT_REF);
        REQUIRE(suchThatClause->getRightRef().getRefType() == Ref::RefType::UNDECIDED_REF);
    }

    SECTION("Test validateSuchThatClause where synonym is not declared")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("stmt", "s");
        abstractQuery->addSelectProjectionSynonym("s");
        abstractQuery->addSuchThatClause("Modifies", SynonymRef("s"), SynonymRef("var"));

        SuchThatClause *suchThatClause = abstractQuery->getSuchThatClauses().at(0);
        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }
}

TEST_CASE("Test QueryValidator validatePatternClauses")
{
    SECTION("Test validatePatternClauses with Assign synonym, var (entRef) and x (ExpressionSpec)")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("assign", "a");
        abstractQuery->addSelectProjectionSynonym("a");
        abstractQuery->addPatternClauseParameters("a", NameRef("var"), ExpressionSpec("x"));

        QueryValidator queryValidator(abstractQuery);
        REQUIRE_NOTHROW(queryValidator.validateQuery());

        // check that it correctly converts the pattern clause parameters to a PatternClause object
        PatternClause *patternClause = abstractQuery->getPatternClauses().at(0);
        REQUIRE(patternClause->getSynonymDesignEntityType() == DesignEntityType::ASSIGN);
        REQUIRE(patternClause->getSynonym() == "a");
        REQUIRE(patternClause->getLeftRef().getValue() == "var");
        REQUIRE(patternClause->getExpressionSpec().getExpression() == "x");
    }

    SECTION("Test validatePatternClauses with Variable synonym, var (entRef) and x (ExpressionSpec) should throw error")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("variable", "v");
        abstractQuery->addSelectProjectionSynonym("v");
        abstractQuery->addPatternClauseParameters("v", NameRef("var"), ExpressionSpec("x"));

        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validatePatternClauses with undeclared synonym should throw error")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("variable", "v");
        abstractQuery->addSelectProjectionSynonym("v");
        abstractQuery->addPatternClauseParameters("a", NameRef("var"), ExpressionSpec("x"));

        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }

    SECTION("Test validatePatternClauses with Assign synonym, x (stmtRef) and x (ExpressionSpec) should throw error")
    {
        std::shared_ptr<AbstractQuery> abstractQuery = std::make_shared<AbstractQuery>();
        abstractQuery->addDeclaration("assign", "a");
        abstractQuery->addDeclaration("stmt", "x");
        abstractQuery->addSelectProjectionSynonym("a");
        abstractQuery->addPatternClauseParameters("a", SynonymRef("x"), ExpressionSpec("x"));

        QueryValidator queryValidator(abstractQuery);
        REQUIRE_THROWS(queryValidator.validateQuery());
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/ASTTestUtils.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "../../../../integration_testing/src/SP/DesignExtractor/Util/MockStore.h"
#include "SP/AST/ASTNodeProcedure.h"
#include "SP/AST/ASTNodeProgram.h"
#include "SP/AST/ASTNodeStmtLst.h"
#include "SP/AST/Exceptions/ASTExceptions.h"
#include "SP/AST/Expr/ASTNodeBinaryCondExpr.h"
#include "SP/AST/Expr/ASTNodeOprExpr.h"
#include "SP/AST/Expr/ASTNodeRelCondExpr.h"
#include "SP/AST/Expr/ASTNodeTermExpr.h"
#include "SP/AST/Expr/ASTNodeUnaryCondExpr.h"
#include "SP/AST/Stmt/ASTNodeAssignStmt.h"
#include "SP/AST/Stmt/ASTNodeCallStmt.h"
#include "SP/AST/Stmt/ASTNodeIfStmt.h"
#include "SP/AST/Stmt/ASTNodePrintStmt.h"
#include "SP/AST/Stmt/ASTNodeReadStmt.h"
#include "SP/AST/Stmt/ASTNodeWhileStmt.h"
#include "SP/DesignExtractor/DesignExtractor.h"
#include <memory>

// Create the mock design extractor
class MockDesignExtractor : public DesignExtractor {
public:
    MockDesignExtractor() : DesignExtractor(std::static_pointer_cast<Store>(std::make_shared<MockStore>())) {}
    // Tracks the number of times the design extractor's extract functions were called
    // This is a proxy for the number of nodes in the AST when designExtractor->extractProgram(programNode) is called
    int totalNodesTraversed = 0;

    virtual void extractProgram(const ASTNodeProgram& programNode) override { ++totalNodesTraversed; }
    virtual void extractProcedure(const ASTNodeProcedure& procedureNode) override { ++totalNodesTraversed; }
    virtual void extractStmtLst(const ASTNodeStmtLst& stmtLstNode) override { ++totalNodesTraversed; }
    virtual void extractAssignStmt(const ASTNodeAssignStmt& assignStmtNode) override { ++totalNodesTraversed; }
    virtual void extractCallStmt(const ASTNodeCallStmt& callStmtNode) override { ++totalNodesTraversed; }
    virtual void extractIfStmt(const ASTNodeIfStmt& ifStmtNode) override { ++totalNodesTraversed; }
    virtual void extractPrintStmt(const ASTNodePrintStmt& printStmtNode) override { ++totalNodesTraversed; }
    virtual void extractReadStmt(const ASTNodeReadStmt& readStmtNode) override { ++totalNodesTraversed; }
    virtual void extractWhileStmt(const ASTNodeWhileStmt& whileStmtNode) override { ++totalNodesTraversed; }
    virtual void extractTermExpr(const ASTNodeTermExpr& termExprNode) override { ++totalNodesTraversed; }
    virtual void extractOprExpr(const ASTNodeOprExpr& oprExprNode) override { ++totalNodesTraversed; }
    virtual void extractRelCondExpr(const ASTNodeRelCondExpr& relCondExprNode) override { ++totalNodesTraversed; }
    virtual void extractUnaryCondExpr(const ASTNodeUnaryCondExpr& exprUnaryNode) override { ++totalNodesTraversed; }
    virtual void extractBinaryCondExpr(const ASTNodeBinaryCondExpr& exprBinaryNode) override { ++totalNodesTraversed; }
};
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/ASTTestUtils.h
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
static std::shared_ptr<ASTNodeProgram> createProgramNode(std::string stmtNo = "0") {
        return std::make_shared<ASTNodeProgram>(stmtNo);
    }
    static std::shared_ptr<ASTNodeProcedure> createProcedureNode(SPToken procedureName, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeProcedure>(procedureName);
    }
    static std::shared_ptr<ASTNodeStmtLst> createStmtLstNode(std::string stmtNo = "0") {
        return std::make_shared<ASTNodeStmtLst>(stmtNo);
    }
    static std::shared_ptr<ASTNodeAssignStmt> createAssignStmtNode(SPToken varName, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeAssignStmt>(varName, stmtNo);
    }
    static std::shared_ptr<ASTNodeCallStmt> createCallStmtNode(SPToken procedureName, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeCallStmt>(procedureName, stmtNo);
    }
    static std::shared_ptr<ASTNodeIfStmt> createIfStmtNode(std::string stmtNo = "0") {
        return std::make_shared<ASTNodeIfStmt>(stmtNo);
    }
    static std::shared_ptr<ASTNodePrintStmt> createPrintStmtNode(SPToken varName, std::string stmtNo = "0") {
        return std::make_shared<ASTNodePrintStmt>(varName, stmtNo);
    }
    static std::shared_ptr<ASTNodeReadStmt> createReadStmtNode(SPToken varName, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeReadStmt>(varName, stmtNo);
    }
    static std::shared_ptr<ASTNodeWhileStmt> createWhileStmtNode(std::string stmtNo = "0") {
        return std::make_shared<ASTNodeWhileStmt>(stmtNo);
    }
    static std::shared_ptr<ASTNodeTermExpr> createTermExprNode(SPToken term, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeTermExpr>(term, stmtNo);
    }
    static std::shared_ptr<ASTNodeOprExpr> createOprExprNode(SPToken opr, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeOprExpr>(opr, stmtNo);
    }
    static std::shared_ptr<ASTNodeRelCondExpr> createRelCondExprNode(SPToken relOp, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeRelCondExpr>(relOp, stmtNo);
    }
    static std::shared_ptr<ASTNodeUnaryCondExpr> createUnaryCondExprNode(SPToken condOp, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeUnaryCondExpr>(condOp, stmtNo);
    }
    static std::shared_ptr<ASTNodeBinaryCondExpr> createBinaryCondExprNode(SPToken condOp, std::string stmtNo = "0") {
        return std::make_shared<ASTNodeBinaryCondExpr>(condOp, stmtNo);
    }

    /**
     * procedure procedureName {
     * 01  read x;
     * 02  if (z < 10) {
     * 03    print x;
     *     }
     *     else {
     * 04    y = i + 11;
     *     }
     * 05  while (!(z < 12)) {
     * 06    read variableName;
     *     }
     */
    // 22 nodes
    static std::shared_ptr<ASTNodeProgram> createSampleAST1() {
        auto programNode = MockNodeFactory::createProgramNode();
        auto procedureName = SPToken(TokenType::NAME, "procedureName");
        auto procedureNode = MockNodeFactory::createProcedureNode(procedureName);
        auto stmtLstNode = MockNodeFactory::createStmtLstNode();

        auto readStmtNode1 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "x"), "1");
        auto ifStmtNode = MockNodeFactory::createIfStmtNode("2");
        auto printStmtNode = MockNodeFactory::createPrintStmtNode(SPToken(TokenType::NAME, "x"), "3");
        auto assignStmtNode = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, "y"), "4");
        auto whileStmtNode = MockNodeFactory::createWhileStmtNode("5");
        auto readStmtNode2 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "variableName"), "6");

        auto unaryCondExprNode = MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!"), "5");
        auto relCondExprNode1 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "2");
        auto relCondExprNode2 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "5");
        auto oprExprNode = MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, "+"), "4");

        auto termExprNode1 = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "z"), "2");
        auto termExprNode2 = MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "10"), "2");
        auto termExprNode3 = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "i"), "4");
        auto termExprNode4 = MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "11"), "4");
        auto termExprNode5 = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "z"), "6");
        auto termExprNode6 = MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "12"), "6");

        // procedure definition
        programNode->addProcedure(procedureNode);
        procedureNode->setStmtLst(stmtLstNode);

        // procedure body

        // read statement
        stmtLstNode->addStmt(readStmtNode1);

        // relational expression for if and while
        relCondExprNode1->setLeftExpr(termExprNode1);
        relCondExprNode1->setRightExpr(termExprNode2);

        // if statement
        stmtLstNode->addStmt(ifStmtNode);
        ifStmtNode->setCondExpr(relCondExprNode1);
        //   if-then body
        auto thenStmtLst = MockNodeFactory::createStmtLstNode();
        ifStmtNode->setThenStmtLst(thenStmtLst);
        //     print statement
        thenStmtLst->addStmt(printStmtNode);
        //   if-else body
        auto elseStmtLst = MockNodeFactory::createStmtLstNode();
        ifStmtNode->setElseStmtLst(elseStmtLst);
        elseStmtLst->addStmt(assignStmtNode);
        //     assign statement
        assignStmtNode->setExpr(oprExprNode);
        oprExprNode->setLeftExpr(termExprNode3);
        oprExprNode->setRightExpr(termExprNode4);

        // while statement
        stmtLstNode->addStmt(whileStmtNode);
        whileStmtNode->setCondExpr(unaryCondExprNode);
        //   while unary condition
        //     relational expression for while
        relCondExprNode2->setLeftExpr(termExprNode5);
        relCondExprNode2->setRightExpr(termExprNode6);

        unaryCondExprNode->setCondExpr(relCondExprNode2);
        //   while body
        auto whileStmtLst = MockNodeFactory::createStmtLstNode();
        whileStmtNode->setStmtLst(whileStmtLst);
        //     call statement
        whileStmtLst->addStmt(readStmtNode2);

        return programNode;
    }

    /**
     * procedure procedureName {
     * 01  read x;
     * 02  if (z < 10) {
     * 03    print x;
     *     }
     *     else {
     * 04    y = i + 11;
     *     }
     * 05  while (!(z < 12)) {
     * 06    call otherProcedure;
     *     }
     *
     * procedure otherProcedure {
     * 07  read aa;
     * 08  bb = 14;
     * 09  cc = dd;
     *     }
     */
    // 29 nodes
    static std::shared_ptr<ASTNodeProgram> createSampleAST2() {
        auto programNode = MockNodeFactory::createProgramNode();
        auto procedureName1 = SPToken(TokenType::NAME, "procedureName");
        auto procedureName2 = SPToken(TokenType::NAME, "otherProcedure");
        auto procedureNode1 = MockNodeFactory::createProcedureNode(procedureName1);
        auto procedureNode2 = MockNodeFactory::createProcedureNode(procedureName2);
        auto stmtLstNode1 = MockNodeFactory::createStmtLstNode();
        auto stmtLstNode2 = MockNodeFactory::createStmtLstNode();

        auto readStmtNode1 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "x"), "1");
        auto readStmtNode2 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "aa"), "7");
        auto ifStmtNode = MockNodeFactory::createIfStmtNode("2");
        auto printStmtNode = MockNodeFactory::createPrintStmtNode(SPToken(TokenType::NAME, "x"), "3");
        auto assignStmtNode1 = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, "y"), "4");
        auto assignStmtNode2 = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, "bb"), "8");
        auto assignStmtNode3 = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, "cc"), "9");
        auto whileStmtNode = MockNodeFactory::createWhileStmtNode("5");
        auto callStmtNode = MockNodeFactory::createCallStmtNode(procedureName2, "6");

        auto unaryCondExprNode = MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!"), "5");
        auto relCondExprNode1 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "2");
        auto relCondExprNode2 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "5");
        auto oprExprNode = MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, "+"), "4");

        auto termExprNode1 = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "z"), "2");
        auto termExprNode2 = MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "10"), "2");
        auto termExprNode3 = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "i"), "4");
        auto termExprNode4 = MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "11"), "4");
        auto termExprNode5 = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "z"), "6");
        auto termExprNode6 = MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "12"), "6");
        auto termExprNode7 = MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "14"), "8");
        auto termExprNode8 = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "dd"), "9");

        // procedure definition
        programNode->addProcedure(procedureNode1);
        procedureNode1->setStmtLst(stmtLstNode1);

        // procedure body

        // read statement
        stmtLstNode1->addStmt(readStmtNode1);

        // relational expression for if and while
        relCondExprNode1->setLeftExpr(termExprNode1);
        relCondExprNode1->setRightExpr(termExprNode2);

        // if statement
        stmtLstNode1->addStmt(ifStmtNode);
        ifStmtNode->setCondExpr(relCondExprNode1);
        //   if-then body
        auto thenStmtLst = MockNodeFactory::createStmtLstNode();
        ifStmtNode->setThenStmtLst(thenStmtLst);
        //     print statement
        thenStmtLst->addStmt(printStmtNode);
        //   if-else body
        auto elseStmtLst = MockNodeFactory::createStmtLstNode();
        ifStmtNode->setElseStmtLst(elseStmtLst);
        elseStmtLst->addStmt(assignStmtNode1);
        //     assign statement
        assignStmtNode1->setExpr(oprExprNode);
        oprExprNode->setLeftExpr(termExprNode3);
        oprExprNode->setRightExpr(termExprNode4);

        // while statement
        stmtLstNode1->addStmt(whileStmtNode);
        whileStmtNode->setCondExpr(unaryCondExprNode);
        //   while unary condition
        //     relational expression for while
        relCondExprNode2->setLeftExpr(termExprNode5);
        relCondExprNode2->setRightExpr(termExprNode6);

        unaryCondExprNode->setCondExpr(relCondExprNode2);
        //   while body
        auto whileStmtLst = MockNodeFactory::createStmtLstNode();
        whileStmtNode->setStmtLst(whileStmtLst);
        //     call statement
        whileStmtLst->addStmt(callStmtNode);

        // otherProcedure definition
        programNode->addProcedure(procedureNode2);
        procedureNode2->setStmtLst(stmtLstNode2);

        // procedure body

        // read statement
        stmtLstNode2->addStmt(readStmtNode2);

        //     assign statement
        stmtLstNode2->addStmt(assignStmtNode2);
        assignStmtNode2->setExpr(termExprNode7);

        //     assign statement
        stmtLstNode2->addStmt(assignStmtNode3);
        assignStmtNode3->setExpr(termExprNode8);

        return programNode;
    }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/ASTTestUtils.h
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
/**
     * procedure procedureName {
     * 01  read x;
     * 02  if (z < 10) {
     * 03    print x;
     * 04        if (z < 10) {
     * 05            print x;
     *           }
     *           else {
     * 06            read y;
     *           }
     *      }
     *      else {
     * 07        y = i + 11;
     *      }
     * 08  while (!(z < 12)) {
     * 09    read variableName;
     * 10        while (!(i < 13)) {
     * 11            read otherVariable;
     * 12            read anotherVariable;
     *          }
     *     }
     */
    // 38 nodes
    static std::shared_ptr<ASTNodeProgram> createSampleAST3() {
        // Create the root of the AST
        auto programNode = MockNodeFactory::createProgramNode();
        auto procedureName = SPToken(TokenType::NAME, "procedureName");
        auto procedureNode = MockNodeFactory::createProcedureNode(procedureName);
        auto stmtLstNode = MockNodeFactory::createStmtLstNode();

        // Add the procedure to the program
        programNode->addProcedure(procedureNode);
        procedureNode->setStmtLst(stmtLstNode);

        // Create the read statement
        auto readStmtNode1 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "x"), "1");
        stmtLstNode->addStmt(readStmtNode1);

        // Create the first if statement
        auto ifStmtNode1 = MockNodeFactory::createIfStmtNode("2");
        stmtLstNode->addStmt(ifStmtNode1);

        // Create the condition for the first if statement
        auto relCondExprNode1 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "2");
        relCondExprNode1->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "z"), "2"));
        relCondExprNode1->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "10"), "2"));
        ifStmtNode1->setCondExpr(relCondExprNode1);

        // Create the then statement list for the first if statement
        auto thenStmtLst1 = MockNodeFactory::createStmtLstNode();
        ifStmtNode1->setThenStmtLst(thenStmtLst1);

        // Create the print statement
        auto printStmtNode1 = MockNodeFactory::createPrintStmtNode(SPToken(TokenType::NAME, "x"), "3");
        thenStmtLst1->addStmt(printStmtNode1);

        // Create the second if statement
        auto ifStmtNode2 = MockNodeFactory::createIfStmtNode("4");
        thenStmtLst1->addStmt(ifStmtNode2);

        // Create the condition for the second if statement
        auto relCondExprNode2 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "4");
        relCondExprNode2->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "z"), "4"));
        relCondExprNode2->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "10"), "4"));
        ifStmtNode2->setCondExpr(relCondExprNode2);

        // Create the then statement list for the second if statement
        auto thenStmtLst2 = MockNodeFactory::createStmtLstNode();
        ifStmtNode2->setThenStmtLst(thenStmtLst2);

        // Create the second print statement
        auto printStmtNode2 = MockNodeFactory::createPrintStmtNode(SPToken(TokenType::NAME, "x"), "5");
        thenStmtLst2->addStmt(printStmtNode2);

        // Create the else statement list for the second if statement
        auto elseStmtLst2 = MockNodeFactory::createStmtLstNode();
        ifStmtNode2->setElseStmtLst(elseStmtLst2);

        // Create the second read statement
        auto readStmtNode2 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "y"), "6");
        elseStmtLst2->addStmt(readStmtNode2);

        // Create the else statement list for the first if statement
        auto elseStmtLst1 = MockNodeFactory::createStmtLstNode();
        ifStmtNode1->setElseStmtLst(elseStmtLst1);

        // Create the assign statement
        auto assignStmtNode = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, "y"), "7");
        elseStmtLst1->addStmt(assignStmtNode);

        // Create the expression for the assign statement
        auto oprExprNode = MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, "+"), "7");
        oprExprNode->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "i"), "7"));
        oprExprNode->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "11"), "7"));
        assignStmtNode->setExpr(oprExprNode);

        // Create the first while statement
        auto whileStmtNode1 = MockNodeFactory::createWhileStmtNode("8");
        stmtLstNode->addStmt(whileStmtNode1);

        // Create the condition for the first while statement
        auto unaryCondExprNode1 = MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!"), "8");
        auto relCondExprNode3 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "8");
        relCondExprNode3->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "z"), "8"));
        relCondExprNode3->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "12"), "8"));
        unaryCondExprNode1->setCondExpr(relCondExprNode3);
        whileStmtNode1->setCondExpr(unaryCondExprNode1);

        // Create the statement list for the first while statement
        auto whileStmtLst1 = MockNodeFactory::createStmtLstNode();
        whileStmtNode1->setStmtLst(whileStmtLst1);

        // Create the third read statement
        auto readStmtNode3 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "variableName"), "9");
        whileStmtLst1->addStmt(readStmtNode3);

        // Create the second while statement
        auto whileStmtNode2 = MockNodeFactory::createWhileStmtNode("10");
        whileStmtLst1->addStmt(whileStmtNode2);

        // Create the condition for the second while statement
        auto unaryCondExprNode2 = MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!"), "10");
        auto relCondExprNode4 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"), "10");
        relCondExprNode4->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "i"), "10"));
        relCondExprNode4->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::INTEGER, "13"), "10"));
        unaryCondExprNode2->setCondExpr(relCondExprNode4);
        whileStmtNode2->setCondExpr(unaryCondExprNode2);

        // Create the statement list for the second while statement
        auto whileStmtLst2 = MockNodeFactory::createStmtLstNode();
        whileStmtNode2->setStmtLst(whileStmtLst2);

        // Create the fourth read statement
        auto readStmtNode4 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "otherVariable"), "11");
        whileStmtLst2->addStmt(readStmtNode4);

        // Create the fifth read statement
        auto readStmtNode5 = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "anotherVariable"), "12");
        whileStmtLst2->addStmt(readStmtNode5);

        return programNode;
    }
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/TestASTExpr.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "ASTTestUtils.h"

TEST_CASE("ASTNodeExpr Construction") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    SECTION("ASTNodeExprBinary constructor and methods", "[ASTNodeExprBinary]") {
        auto exprBinaryNode = MockNodeFactory::createBinaryCondExprNode(
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "&&"));
        std::string condOp = "&&";
        auto condExprNode1 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"));
        auto condExprNode2 = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"));
        auto termExprNode = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x"));
        condExprNode1->setLeftExpr(termExprNode);
        condExprNode1->setRightExpr(termExprNode);
        condExprNode2->setLeftExpr(termExprNode);
        condExprNode2->setRightExpr(termExprNode);

        exprBinaryNode->setLeftCondExpr(condExprNode1);
        exprBinaryNode->setRightCondExpr(condExprNode2);

        REQUIRE(exprBinaryNode->getCondOp() == condOp);
        REQUIRE(exprBinaryNode->getLeftCondExpr() == condExprNode1);
        REQUIRE(exprBinaryNode->getRightCondExpr() == condExprNode2);

        exprBinaryNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 7);
    }

    SECTION("ASTNodeExprUnary constructor and methods", "[ASTNodeExprUnary]") {
        auto exprUnaryNode = MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!"));
        auto condOp = "!";
        auto condExprNode = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"));
        auto termExprNode = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x"));
        condExprNode->setLeftExpr(termExprNode);
        condExprNode->setRightExpr(termExprNode);

        exprUnaryNode->setCondExpr(condExprNode);

        REQUIRE(exprUnaryNode->getCondOp() == condOp);
        REQUIRE(exprUnaryNode->getCondExpr() == condExprNode);

        exprUnaryNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 4);
    }

    SECTION("ASTNodeRelCondExpr constructor and methods", "[ASTNodeRelCondExpr]") {
        auto relOp = "<";
        auto relCondExprNode = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, relOp));
        auto leftExpr = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x"));
        auto rightExpr = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "y"));

        relCondExprNode->setLeftExpr(leftExpr);
        relCondExprNode->setRightExpr(rightExpr);

        REQUIRE(relCondExprNode->getRelOp() == relOp);
        REQUIRE(relCondExprNode->getLeftExpr() == leftExpr);
        REQUIRE(relCondExprNode->getRightExpr() == rightExpr);

        relCondExprNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 3);
    }

    SECTION("ASTNodeTermExpr constructor and methods", "[ASTNodeTermExpr]") {
        auto term = "x";
        auto termExprNode = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, term));

        REQUIRE(termExprNode->getTerm() == term);

        termExprNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 1);
    }

    SECTION("ASTNodeOprExpr constructor and methods", "[ASTNodeOprExpr]") {
        auto opr = "+";
        auto oprExprNode = MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, opr));
        auto leftExprOprNode = MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, opr));
        auto rightExprOprNode = MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, opr));
        auto leftTermExpr = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x"));
        auto rightTermExpr = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "y"));

        oprExprNode->setLeftExpr(leftExprOprNode);
        oprExprNode->setRightExpr(rightExprOprNode);
        leftExprOprNode->setLeftExpr(leftTermExpr);
        leftExprOprNode->setRightExpr(rightTermExpr);
        rightExprOprNode->setLeftExpr(leftTermExpr);
        rightExprOprNode->setRightExpr(rightTermExpr);

        REQUIRE(oprExprNode->getOpr() == opr);
        REQUIRE(oprExprNode->getLeftExpr() == leftExprOprNode);
        REQUIRE(oprExprNode->getRightExpr() == rightExprOprNode);
        REQUIRE(leftExprOprNode->getLeftExpr() == leftTermExpr);
        REQUIRE(leftExprOprNode->getRightExpr() == rightTermExpr);

        oprExprNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 7);
    }
}

TEST_CASE("ASTNodeExpr missing child nodes exceptions") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    SECTION("ASTNodeExprBinary missing child nodes", "[ASTNodeExprBinary]") {
        auto exprBinaryNode = MockNodeFactory::createBinaryCondExprNode(
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "&&"));

        SECTION("Missing LeftCondExpr") {
            exprBinaryNode->setRightCondExpr(
                MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<")));
            REQUIRE_THROWS_AS(exprBinaryNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }

        SECTION("Missing RightCondExpr") {
            exprBinaryNode->setLeftCondExpr(MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<")));
            REQUIRE_THROWS_AS(exprBinaryNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }

    SECTION("ASTNodeExprUnary missing child nodes", "[ASTNodeExprUnary]") {
        auto exprBinaryNode = MockNodeFactory::createBinaryCondExprNode(
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "&&"));

        SECTION("Missing CondExpr") {
            REQUIRE_THROWS_AS(exprBinaryNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }

    SECTION("ASTNodeRelCondExpr missing child nodes", "[ASTNodeRelCondExpr]") {
        auto relCondExprNode = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"));

        SECTION("Missing leftExpr") {
            relCondExprNode->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));
            REQUIRE_THROWS_AS(relCondExprNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }

        SECTION("Missing rightExpr") {
            relCondExprNode->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));
            REQUIRE_THROWS_AS(relCondExprNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }

    SECTION("ASTNodeOprExpr missing child nodes", "[ASTNodeOprExpr]") {
        auto oprExprNode = MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, "+"));

        SECTION("Missing leftExpr") {
            oprExprNode->setLeftExpr(static_cast<std::shared_ptr<ASTNodeOprExpr>>(nullptr));
            oprExprNode->setRightExpr(MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, "+")));
            REQUIRE_THROWS_AS(oprExprNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }

        SECTION("Missing rightExpr") {
            oprExprNode->setLeftExpr(MockNodeFactory::createOprExprNode(SPToken(TokenType::PLUS, "+")));
            oprExprNode->setRightExpr(static_cast<std::shared_ptr<ASTNodeOprExpr>>(nullptr));
            REQUIRE_THROWS_AS(oprExprNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/TestAST.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
TEST_CASE("ASTNode Construction") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    SECTION("ASTNode constructor and methods", "[ASTNode]") {
        auto programNode = MockNodeFactory::createProgramNode();

        programNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 1);
    }

    SECTION("ASTNodeProcedure constructor and methods", "[ASTNodeProcedure]") {
        std::string procedureName = "testProcedure";
        auto procedureNode = MockNodeFactory::createProcedureNode(SPToken(TokenType::NAME, procedureName));
        auto stmtLstNode = MockNodeFactory::createStmtLstNode();

        procedureNode->setStmtLst(stmtLstNode);

        REQUIRE(procedureNode->getProcedureName() == procedureName);

        procedureNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 2);
    }

    SECTION("ASTNodeStmtLst constructor and methods", "[ASTNodeStmtLst]") {
        auto stmtLstNode = MockNodeFactory::createStmtLstNode();

        stmtLstNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 1);
    }
}

TEST_CASE("ASTNode missing child nodes exceptions") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    SECTION("ASTNodeProcedure missing child node", "[ASTNodeProcedure]") {
        SPToken procedureName = SPToken(TokenType::NAME, "testProcedure");
        auto procedureNode = MockNodeFactory::createProcedureNode(procedureName);

        SECTION("Missing stmtLst") {
            REQUIRE_THROWS_AS(procedureNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/TestAST.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
TEST_CASE("Test ASTNode AST Construction and AST Traversal") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();
    auto programNode = MockNodeFactory::createProgramNode();
    auto procedureName = SPToken(TokenType::NAME, "testProcedure");
    auto procedureNode = MockNodeFactory::createProcedureNode(procedureName);
    auto stmtLstNode = MockNodeFactory::createStmtLstNode();

    // Linking of nodes to form AST
    programNode->addProcedure(procedureNode);
    procedureNode->setStmtLst(stmtLstNode);

    // Verification of number of nodes in AST
    programNode->acceptVisitor(designExtractor);
    REQUIRE(designExtractor->totalNodesTraversed == 3);
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/TestASTFull.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
TEST_CASE("Full AST Construction and traversal with 1 procedure") {
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    auto programNode = MockNodeFactory::createSampleAST1();

    // Perform traversal
    programNode->acceptVisitor(designExtractor);
    REQUIRE(designExtractor->totalNodesTraversed == 22);
}

TEST_CASE("Full AST Construction and traversal with 2 procedures") {
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    auto programNode = MockNodeFactory::createSampleAST2();

    // Perform traversal
    programNode->acceptVisitor(designExtractor);
    REQUIRE(designExtractor->totalNodesTraversed == 29);
}

TEST_CASE("Full AST Construction and traversal with 1 procedure and nested if and while stmts") {
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    auto programNode = MockNodeFactory::createSampleAST3();

    // Perform traversal
    programNode->acceptVisitor(designExtractor);
    REQUIRE(designExtractor->totalNodesTraversed == 38);
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/TestASTStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
TEST_CASE("ASTNodeStmt Construction") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    SECTION("ASTNodeAssignStmt constructor and methods", "[ASTNodeAssignStmt]") {
        std::string varName = "testVar";
        auto assignStmtNode = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, varName));
        auto termExpr = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x"));

        assignStmtNode->setExpr(termExpr);

        REQUIRE(assignStmtNode->getVarName() == varName);
        REQUIRE(assignStmtNode->getExpr() == termExpr);

        assignStmtNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 2); // assign and expropr nodes
    }

    SECTION("ASTNodeCallStmt constructor and methods", "[ASTNodeCallStmt]") {
        std::string procedureName = "testProcedure";
        auto callStmtNode = MockNodeFactory::createCallStmtNode(SPToken(TokenType::NAME, procedureName));

        REQUIRE(callStmtNode->getProcedureName() == procedureName);

        callStmtNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 1);
    }

    SECTION("ASTNodeIfStmt constructor and methods", "[ASTNodeIfStmt]") {
        auto ifStmtNode = MockNodeFactory::createIfStmtNode();
        auto condExpr = MockNodeFactory::createBinaryCondExprNode(
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "&&")); // can be unary or rel too
        auto thenStmtLst = MockNodeFactory::createStmtLstNode();
        auto elseStmtLst = MockNodeFactory::createStmtLstNode();
        auto relCondExpr = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"));
        relCondExpr->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));
        relCondExpr->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));

        condExpr->setLeftCondExpr(relCondExpr);
        condExpr->setRightCondExpr(relCondExpr);

        ifStmtNode->setCondExpr(condExpr);
        ifStmtNode->setThenStmtLst(thenStmtLst);
        ifStmtNode->setElseStmtLst(elseStmtLst);

        REQUIRE(ifStmtNode->getCondExpr() == condExpr);
        REQUIRE(ifStmtNode->getThenStmtLst() == thenStmtLst);
        REQUIRE(ifStmtNode->getElseStmtLst() == elseStmtLst);

        ifStmtNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 10);
    }

    SECTION("ASTNodePrintStmt constructor and methods", "[ASTNodePrintStmt]") {
        std::string varName = "testVar";
        auto printStmtNode = MockNodeFactory::createPrintStmtNode(SPToken(TokenType::NAME, varName));

        REQUIRE(printStmtNode->getVarName() == varName);

        printStmtNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 1);
    }

    SECTION("ASTNodeReadStmt constructor and methods", "[ASTNodeReadStmt]") {
        std::string varName = "testVar";
        auto readStmtNode = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, varName));

        REQUIRE(readStmtNode->getVarName() == varName);

        readStmtNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 1);
    }

    SECTION("ASTNodeWhileStmt constructor and methods", "[ASTNodeWhileStmt]") {
        auto whileStmtNode = MockNodeFactory::createWhileStmtNode();
        auto unaryCondExpr =
            MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!")); // can also be binary or rel
        auto stmtLst = MockNodeFactory::createStmtLstNode();
        auto relExprCond = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"));
        relExprCond->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));
        relExprCond->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));

        unaryCondExpr->setCondExpr(relExprCond);

        whileStmtNode->setCondExpr(unaryCondExpr);
        whileStmtNode->setStmtLst(stmtLst);

        REQUIRE(whileStmtNode->getCondExpr() == unaryCondExpr);
        REQUIRE(whileStmtNode->getStmtLst() == stmtLst);

        whileStmtNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 6);
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/TestASTStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
TEST_CASE("ASTNodeStmt missing child nodes exceptions") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();

    SECTION("ASTNodeAssignStmt missing child nodes", "[ASTNodeAssignStmt]") {
        auto assignStmtNode = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, "testVar"));
        auto termExpr = MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x"));

        SECTION("Missing expr") {
            REQUIRE_THROWS_AS(assignStmtNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }

    SECTION("ASTNodeIfStmt missing child nodes", "[ASTNodeIfStmt]") {
        auto ifStmtNode = MockNodeFactory::createIfStmtNode();

        SECTION("Missing CondExpr") {
            ifStmtNode->setThenStmtLst(MockNodeFactory::createStmtLstNode());
            ifStmtNode->setElseStmtLst(MockNodeFactory::createStmtLstNode());
            REQUIRE_THROWS_AS(ifStmtNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }

        SECTION("Missing ThenStmtLst") {
            ifStmtNode->setCondExpr(MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!")));
            ifStmtNode->setElseStmtLst(MockNodeFactory::createStmtLstNode());
            REQUIRE_THROWS_AS(ifStmtNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }

        SECTION("Missing ElseStmtLst") {
            ifStmtNode->setCondExpr(MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<")));
            ifStmtNode->setThenStmtLst(MockNodeFactory::createStmtLstNode());
            REQUIRE_THROWS_AS(ifStmtNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }

    SECTION("ASTNodeWhileStmt missing child nodes", "[ASTNodeWhileStmt]") {
        auto whileStmtNode = MockNodeFactory::createWhileStmtNode();

        SECTION("Missing CondExpr") {
            whileStmtNode->setStmtLst(MockNodeFactory::createStmtLstNode());
            REQUIRE_THROWS_AS(whileStmtNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }

        SECTION("Missing StmtLst") {
            whileStmtNode->setCondExpr(MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!")));
            REQUIRE_THROWS_AS(whileStmtNode->acceptVisitor(designExtractor), MissingASTNodeError);
        }
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SP/AST/TestASTStmt.cpp
Generator: copilot
Intervention: 1
Language: e
Prompt: used copilot
ChatId: 
Code:
TEST_CASE("Test AST w/ Stmts Construction and AST Traversal") {
    // Construction of extractor and nodes
    auto designExtractor = std::make_shared<MockDesignExtractor>();
    auto programNode = MockNodeFactory::createProgramNode("0");
    auto procedureName1 = SPToken(TokenType::NAME, "testProcedure1");
    // We ignore stmtno for procedure node
    auto procedureNode1 = MockNodeFactory::createProcedureNode(procedureName1);
    auto stmtLstNode1 = MockNodeFactory::createStmtLstNode("1");
    auto assignStmtNode = MockNodeFactory::createAssignStmtNode(SPToken(TokenType::NAME, "x"), "2");
    auto procedureName2 = SPToken(TokenType::NAME, "testProcedure2");
    auto callStmtNode = MockNodeFactory::createCallStmtNode(procedureName2, "3");
    auto ifStmtNode = MockNodeFactory::createIfStmtNode("4");
    auto printStmtNode = MockNodeFactory::createPrintStmtNode(SPToken(TokenType::NAME, "x"), "5");
    auto readStmtNode = MockNodeFactory::createReadStmtNode(SPToken(TokenType::NAME, "x"), "6");
    auto whileStmtNode = MockNodeFactory::createWhileStmtNode("7");

    auto relCondExpr = MockNodeFactory::createRelCondExprNode(SPToken(TokenType::LESS_THAN, "<"));
    relCondExpr->setLeftExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));
    relCondExpr->setRightExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));

    // Set necessary child nodes for stmt nodes
    assignStmtNode->setExpr(MockNodeFactory::createTermExprNode(SPToken(TokenType::NAME, "x")));

    ifStmtNode->setCondExpr(relCondExpr);
    ifStmtNode->setThenStmtLst(MockNodeFactory::createStmtLstNode());
    ifStmtNode->setElseStmtLst(MockNodeFactory::createStmtLstNode());

    auto whileStmtCondExpr = MockNodeFactory::createUnaryCondExprNode(SPToken(TokenType::NOT, "!"));
    whileStmtCondExpr->setCondExpr(relCondExpr);
    whileStmtNode->setCondExpr(whileStmtCondExpr);
    whileStmtNode->setStmtLst(MockNodeFactory::createStmtLstNode());

    SECTION("Traversal with All 6 Types of Stmts in 1 Procedure/StmtLst") {
        // Linking of nodes to form AST
        programNode->addProcedure(procedureNode1);
        procedureNode1->setStmtLst(stmtLstNode1);
        stmtLstNode1->addStmt(assignStmtNode);
        stmtLstNode1->addStmt(callStmtNode);
        stmtLstNode1->addStmt(ifStmtNode);
        stmtLstNode1->addStmt(printStmtNode);
        stmtLstNode1->addStmt(readStmtNode);
        stmtLstNode1->addStmt(whileStmtNode);

        // Verification of number of nodes in AST
        programNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 20);
    }

    SECTION("Traversal with All 6 Stmt Types in 2 separate Procedures/StmtLsts") {
        // Additional nodes
        auto procedureName2 = SPToken(TokenType::NAME, "testProcedure1");
        // We ignore stmtno for procedure node
        auto procedureNode2 = MockNodeFactory::createProcedureNode(procedureName2);
        auto stmtLstNode2 = MockNodeFactory::createStmtLstNode("8");

        // Linking of nodes to form AST
        programNode->addProcedure(procedureNode1);
        programNode->addProcedure(procedureNode2);
        procedureNode1->setStmtLst(stmtLstNode1);
        procedureNode2->setStmtLst(stmtLstNode2);
        stmtLstNode1->addStmt(assignStmtNode);
        stmtLstNode1->addStmt(callStmtNode);
        stmtLstNode1->addStmt(ifStmtNode);
        stmtLstNode2->addStmt(printStmtNode);
        stmtLstNode2->addStmt(readStmtNode);
        stmtLstNode2->addStmt(whileStmtNode);

        // Verification of number of nodes in AST
        programNode->acceptVisitor(designExtractor);
        REQUIRE(designExtractor->totalNodesTraversed == 22);

        // Double check stmtNos
        REQUIRE(programNode->getStmtNo() == "0");
        REQUIRE(stmtLstNode1->getStmtNo() == "1");
        REQUIRE(stmtLstNode2->getStmtNo() == "8");
        REQUIRE(assignStmtNode->getStmtNo() == "2");
        REQUIRE(callStmtNode->getStmtNo() == "3");
        REQUIRE(ifStmtNode->getStmtNo() == "4");
        REQUIRE(printStmtNode->getStmtNo() == "5");
    }
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/PKB/TestPKBPatternMethods.cpp
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "PKB/PKB.h"
#include "catch.hpp"

TEST_CASE("PKB stores assign pattern") {
    PKB pkb;
    AssignPattern aPattern;
    AssignPattern bPattern;
    aPattern.setPatternAttributes("1", "x 1 +");
    bPattern.setPatternAttributes("2", "y 1 +");
    pkb.storePattern(aPattern);
    pkb.storePattern(bPattern);

    AssignPattern queryPattern;
    REQUIRE(pkb.retrievePatternKeys(queryPattern) == std::unordered_set<std::string>{"1", "2"});
    queryPattern.findValue("1");
    REQUIRE(pkb.retrievePatternValues(queryPattern) == std::unordered_set<std::string>{"x 1 +"});
    queryPattern.findValue("2");
    REQUIRE(pkb.retrievePatternValues(queryPattern) == std::unordered_set<std::string>{"y 1 +"});
}

TEST_CASE("PKB call on empty pattern storage") {
    PKB pkb;
    AssignPattern queryPattern;
    REQUIRE(pkb.retrievePatternKeys(queryPattern).empty());
    queryPattern.findValue("1");
    REQUIRE(pkb.retrievePatternValues(queryPattern).empty());
}

TEST_CASE("PKB retrieve the pattern table") {
    PKB pkb;
    AssignPattern aPattern;
    AssignPattern bPattern;
    aPattern.setPatternAttributes("1", "x 1 +");
    bPattern.setPatternAttributes("2", "y 1 +");
    pkb.storePattern(aPattern);
    pkb.storePattern(bPattern);

    AssignPattern queryPattern;
    std::unordered_map<std::string, std::unordered_set<std::string>> expected = {{"1", {"x 1 +"}}, {"2", {"y 1 +"}}};
    REQUIRE(pkb.retrievePatternTable(queryPattern) == expected);
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/PKB/TestPKBRelationshipMethods.cpp
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "PKB/PKB.h"
#include "catch.hpp"

TEST_CASE("PKB stores follows Relationship") {
    PKB pkb;

    FollowsRelationship f;
    f.setRelationshipAttributes("1", "2");
    pkb.storeRelationship(f);

    FollowsRelationship f2;
    f2.setRelationshipAttributes("1", "2");
    pkb.storeRelationship(f2);

    FollowsRelationship followsQuery1;
    FollowsRelationship followsQuery2;
    REQUIRE(pkb.retrieveRelationshipKeys(followsQuery1) == std::unordered_set<std::string>{"1"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(followsQuery2) == std::unordered_set<std::string>{"2"});


    followsQuery1.findValue("1");
    REQUIRE(pkb.retrieveRelationshipValues(followsQuery1) == std::unordered_set<std::string>{"2"});

    followsQuery2.findValue("2");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(followsQuery2) == std::unordered_set<std::string>{"1"});

}

TEST_CASE("PKB stores follows* Relationship") {
    PKB pkb;

    FollowsStarRelationship f1;
    f1.setRelationshipAttributes("1", "2");
    FollowsStarRelationship f2;
    f2.setRelationshipAttributes("2", "3");
    FollowsStarRelationship f3;
    f3.setRelationshipAttributes("1", "3");

    pkb.storeRelationship(f1);
    pkb.storeRelationship(f2);
    pkb.storeRelationship(f3);


    FollowsStarRelationship followsStarQuery1;
    FollowsStarRelationship followsStarQuery2;
    REQUIRE(pkb.retrieveRelationshipKeys(followsStarQuery1) == std::unordered_set<std::string>{"1", "2"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(followsStarQuery2) == std::unordered_set<std::string>{"2", "3"});

    followsStarQuery1.findValue("1");
    REQUIRE(pkb.retrieveRelationshipValues(followsStarQuery1) == std::unordered_set<std::string>{"2", "3"});
    followsStarQuery1.findValue("2");
    REQUIRE(pkb.retrieveRelationshipValues(followsStarQuery1) == std::unordered_set<std::string>{"3"});
    followsStarQuery2.findValue("2");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(followsStarQuery2) == std::unordered_set<std::string>{"1"});
    followsStarQuery2.findValue("3");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(followsStarQuery2) == std::unordered_set<std::string>{"2", "1"});

}

TEST_CASE("PKB stores parent Relationship") {
    PKB pkb;

    ParentRelationship f1;
    f1.setRelationshipAttributes("1", "2");
    pkb.storeRelationship(f1);

    ParentRelationship f2;
    f2.setRelationshipAttributes("1", "3");
    pkb.storeRelationship(f2);

    ParentRelationship f3;
    f3.setRelationshipAttributes("4", "5");
    pkb.storeRelationship(f3);



    ParentRelationship parentQuery1;
    ParentRelationship parentQuery2;
    ParentRelationship parentQuery3;
    REQUIRE(pkb.retrieveRelationshipKeys(parentQuery1) == std::unordered_set<std::string>{"1", "4"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(parentQuery2) == std::unordered_set<std::string>{"2", "3", "5"});

    parentQuery1.findValue("1");
    REQUIRE(pkb.retrieveRelationshipValues(parentQuery1) == std::unordered_set<std::string>{"2", "3"});
    parentQuery2.findValue("2");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(parentQuery2) == std::unordered_set<std::string>{"1"});
    parentQuery3.findValue("3");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(parentQuery2) == std::unordered_set<std::string>{"1"});

}

TEST_CASE("PKB stores parent* Relationship") {

    PKB pkb;

    ParentStarRelationship f1;
    f1.setRelationshipAttributes("1", "2");
    ParentStarRelationship f2;
    f2.setRelationshipAttributes("2", "3");
    ParentStarRelationship f3;
    f3.setRelationshipAttributes("1", "3");
    ParentStarRelationship f4;
    f4.setRelationshipAttributes("8", "9");
    ParentStarRelationship f5;
    f5.setRelationshipAttributes("1", "8");
    ParentStarRelationship f6;
    f6.setRelationshipAttributes("1", "9");


    pkb.storeRelationship(f1);
    pkb.storeRelationship(f2);
    pkb.storeRelationship(f3);
    pkb.storeRelationship(f4);
    pkb.storeRelationship(f5);
    pkb.storeRelationship(f6);

    ParentStarRelationship parentStarQuery1;
    ParentStarRelationship parentStarQuery2;
    REQUIRE(pkb.retrieveRelationshipKeys(parentStarQuery1) == std::unordered_set<std::string>{"1", "2", "8"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(parentStarQuery2) == std::unordered_set<std::string>{"2", "3", "8", "9"});

    parentStarQuery1.findValue("1");
    REQUIRE(pkb.retrieveRelationshipValues(parentStarQuery1) == std::unordered_set<std::string>{"2", "3", "8", "9"});
    parentStarQuery1.findValue("2");
    REQUIRE(pkb.retrieveRelationshipValues(parentStarQuery1) == std::unordered_set<std::string>{"3"});
    parentStarQuery2.findValue("2");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(parentStarQuery2) == std::unordered_set<std::string>{"1"});
    parentStarQuery2.findValue("3");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(parentStarQuery2) == std::unordered_set<std::string>{"1", "2"});
    parentStarQuery2.findValue("8");
    REQUIRE(pkb.retrieveRelationshipValues(parentStarQuery2) == std::unordered_set<std::string>{"9"});
    REQUIRE(pkb.retrieveRelationshipInvertedValues(parentStarQuery2) == std::unordered_set<std::string>{"1"});
    parentStarQuery2.findValue("9");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(parentStarQuery2) == std::unordered_set<std::string>{"1", "8"});

}

TEST_CASE("PKB stores UsesS Relationship") {
    PKB pkb;

    UsesSRelationship f1;
    f1.setRelationshipAttributes("1", "x");
    UsesSRelationship f2;
    f2.setRelationshipAttributes("1", "y");
    UsesSRelationship f3;
    f3.setRelationshipAttributes("1", "z");
    UsesSRelationship f4;
    f4.setRelationshipAttributes("4", "x");
    UsesSRelationship f5;
    f5.setRelationshipAttributes("5", "y");
    UsesSRelationship f6;
    f6.setRelationshipAttributes("6", "z");

    pkb.storeRelationship(f1);
    pkb.storeRelationship(f2);
    pkb.storeRelationship(f3);
    pkb.storeRelationship(f4);
    pkb.storeRelationship(f5);
    pkb.storeRelationship(f6);

    UsesSRelationship usesSQuery1;
    UsesSRelationship usesSQuery2;
    REQUIRE(pkb.retrieveRelationshipKeys(usesSQuery1) == std::unordered_set<std::string>{"1", "4", "5", "6"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(usesSQuery2) == std::unordered_set<std::string>{"x", "y", "z"});

    usesSQuery1.findValue("1");
    REQUIRE(pkb.retrieveRelationshipValues(usesSQuery1) == std::unordered_set<std::string>{"x", "y", "z"});
    usesSQuery1.findValue("4");
    REQUIRE(pkb.retrieveRelationshipValues(usesSQuery1) == std::unordered_set<std::string>{"x"});
    usesSQuery1.findValue("5");
    REQUIRE(pkb.retrieveRelationshipValues(usesSQuery1) == std::unordered_set<std::string>{"y"});
    usesSQuery2.findValue("x");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(usesSQuery2) == std::unordered_set<std::string>{"1", "4"});
    usesSQuery2.findValue("y");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(usesSQuery2) == std::unordered_set<std::string>{"1", "5"});
    usesSQuery2.findValue("z");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(usesSQuery2) == std::unordered_set<std::string>{"1", "6"});

}

TEST_CASE("PKB Stores UsesP Relationship") {
    PKB pkb;

    UsesSRelationship f1;
    f1.setRelationshipAttributes("one", "x");
    UsesSRelationship f2;
    f2.setRelationshipAttributes("one", "y");
    UsesSRelationship f3;
    f3.setRelationshipAttributes("one", "z");
    UsesSRelationship f4;
    f4.setRelationshipAttributes("four", "x");
    UsesSRelationship f5;
    f5.setRelationshipAttributes("five", "y");
    UsesSRelationship f6;
    f6.setRelationshipAttributes("six", "z");

    pkb.storeRelationship(f1);
    pkb.storeRelationship(f2);
    pkb.storeRelationship(f3);
    pkb.storeRelationship(f4);
    pkb.storeRelationship(f5);
    pkb.storeRelationship(f6);

    UsesSRelationship usesSQuery1;
    UsesSRelationship usesSQuery2;
    REQUIRE(pkb.retrieveRelationshipKeys(usesSQuery1) == std::unordered_set<std::string>{"one", "four", "five", "six"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(usesSQuery2) == std::unordered_set<std::string>{"x", "y", "z"});

    usesSQuery1.findValue("one");
    REQUIRE(pkb.retrieveRelationshipValues(usesSQuery1) == std::unordered_set<std::string>{"x", "y", "z"});
    usesSQuery1.findValue("four");
    REQUIRE(pkb.retrieveRelationshipValues(usesSQuery1) == std::unordered_set<std::string>{"x"});
    usesSQuery1.findValue("five");
    REQUIRE(pkb.retrieveRelationshipValues(usesSQuery1) == std::unordered_set<std::string>{"y"});
    usesSQuery2.findValue("x");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(usesSQuery2) == std::unordered_set<std::string>{"one", "four"});
    usesSQuery2.findValue("y");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(usesSQuery2) == std::unordered_set<std::string>{"one", "five"});
    usesSQuery2.findValue("z");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(usesSQuery2) == std::unordered_set<std::string>{"one", "six"});

}

TEST_CASE("PKB Stores ModifiesS Relationship") {

    PKB pkb;

    ModifiesSRelationship f1;
    f1.setRelationshipAttributes("1", "x");
    ModifiesSRelationship f2;
    f2.setRelationshipAttributes("2", "y");
    ModifiesSRelationship f3;
    f3.setRelationshipAttributes("3", "z");
    ModifiesSRelationship f4;
    f4.setRelationshipAttributes("4", "x");
    ModifiesSRelationship f5;
    f5.setRelationshipAttributes("5", "y");
    ModifiesSRelationship f6;
    f6.setRelationshipAttributes("6", "z");

    pkb.storeRelationship(f1);
    pkb.storeRelationship(f2);
    pkb.storeRelationship(f3);
    pkb.storeRelationship(f4);
    pkb.storeRelationship(f5);
    pkb.storeRelationship(f6);

    ModifiesSRelationship modifiesSQuery1;
    ModifiesSRelationship modifiesSQuery2;
    REQUIRE(pkb.retrieveRelationshipKeys(modifiesSQuery1) == std::unordered_set<std::string>{"1","2", "3", "4", "5", "6"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(modifiesSQuery2) == std::unordered_set<std::string>{"x", "y", "z"});

    modifiesSQuery1.findValue("1");
    REQUIRE(pkb.retrieveRelationshipValues(modifiesSQuery1) == std::unordered_set<std::string>{"x"});
    modifiesSQuery1.findValue("4");
    REQUIRE(pkb.retrieveRelationshipValues(modifiesSQuery1) == std::unordered_set<std::string>{"x"});
    modifiesSQuery1.findValue("5");
    REQUIRE(pkb.retrieveRelationshipValues(modifiesSQuery1) == std::unordered_set<std::string>{"y"});
    modifiesSQuery2.findValue("x");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(modifiesSQuery2) == std::unordered_set<std::string>{"1", "4"});
    modifiesSQuery2.findValue("y");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(modifiesSQuery2) == std::unordered_set<std::string>{"2", "5"});
    modifiesSQuery2.findValue("z");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(modifiesSQuery2) == std::unordered_set<std::string>{"3", "6"});

}

TEST_CASE("PKB Stores ModifiesP Relationship") {

    PKB pkb;

    ModifiesSRelationship f1;
    f1.setRelationshipAttributes("one", "x");
    ModifiesSRelationship f2;
    f2.setRelationshipAttributes("one", "y");
    ModifiesSRelationship f3;
    f3.setRelationshipAttributes("one", "z");
    ModifiesSRelationship f4;
    f4.setRelationshipAttributes("four", "x");
    ModifiesSRelationship f5;
    f5.setRelationshipAttributes("five", "y");
    ModifiesSRelationship f6;
    f6.setRelationshipAttributes("six", "z");

    pkb.storeRelationship(f1);
    pkb.storeRelationship(f2);
    pkb.storeRelationship(f3);
    pkb.storeRelationship(f4);
    pkb.storeRelationship(f5);
    pkb.storeRelationship(f6);

    ModifiesSRelationship modifiesSQuery1;
    ModifiesSRelationship modifiesSQuery2;
    REQUIRE(pkb.retrieveRelationshipKeys(modifiesSQuery1) == std::unordered_set<std::string>{"one", "four", "five", "six"});
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(modifiesSQuery2) == std::unordered_set<std::string>{"x", "y", "z"});

    modifiesSQuery1.findValue("one");
    REQUIRE(pkb.retrieveRelationshipValues(modifiesSQuery1) == std::unordered_set<std::string>{"x", "y", "z"});
    modifiesSQuery1.findValue("four");
    REQUIRE(pkb.retrieveRelationshipValues(modifiesSQuery1) == std::unordered_set<std::string>{"x"});
    modifiesSQuery1.findValue("five");
    REQUIRE(pkb.retrieveRelationshipValues(modifiesSQuery1) == std::unordered_set<std::string>{"y"});
    modifiesSQuery2.findValue("x");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(modifiesSQuery2) == std::unordered_set<std::string>{"one", "four"});
    modifiesSQuery2.findValue("y");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(modifiesSQuery2) == std::unordered_set<std::string>{"one", "five"});
    modifiesSQuery2.findValue("z");
    REQUIRE(pkb.retrieveRelationshipInvertedValues(modifiesSQuery2) == std::unordered_set<std::string>{"one", "six"});


}

TEST_CASE("PKB returns empty for non-existent relationship") {
    PKB pkb;
    FollowsRelationship f;
    REQUIRE(pkb.retrieveRelationshipKeys(f).empty());
    REQUIRE(pkb.retrieveRelationshipInvertedKeys(f).empty());
    REQUIRE(pkb.retrieveRelationshipValues(f).empty());
    REQUIRE(pkb.retrieveRelationshipInvertedValues(f).empty());

}

TEST_CASE("PKB retrieve the relationship tables") {
    PKB pkb;

    FollowsRelationship f1;
    f1.setRelationshipAttributes("1", "2");
    FollowsRelationship f2;
    f2.setRelationshipAttributes("2", "3");
    FollowsRelationship f3;
    f3.setRelationshipAttributes("3", "4");

    pkb.storeRelationship(f1);
    pkb.storeRelationship(f2);
    pkb.storeRelationship(f3);

    FollowsRelationship followsQuery;
    std::unordered_map<std::string, std::unordered_set<std::string>> expected = {{"1", {"2"}}, {"2", {"3"}}, {"3", {"4"}}};
    REQUIRE(pkb.retrieveRelationshipTable(followsQuery) == expected);
    std::unordered_map<std::string, std::unordered_set<std::string>> expected2 = {{"2", {"1"}}, {"3", {"2"}}, {"4", {"3"}}};
    REQUIRE(pkb.retrieveRelationshipInvertedTable(followsQuery) == expected2);
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/PKB/TestPKBEntityMethods.cpp
Generator: copilot
Intervention: 0
Language: e
Prompt: used copilot
ChatId: 
Code:
#include "PKB/PKB.h"
#include "catch.hpp"

TEST_CASE("PKB stores variable entity") {
    PKB pkb;
    VariableEntity v;
    VariableEntity variableQuery;
    v.setEntityAttributes("x");
    pkb.storeEntity(v);
    REQUIRE(pkb.retrieveEntityData(variableQuery) == std::unordered_set<std::string>{"x"});

    VariableEntity v2;
    v2.setEntityAttributes("y");
    pkb.storeEntity(v2);
    REQUIRE(pkb.retrieveEntityData(variableQuery) == std::unordered_set<std::string>{"x", "y"});

    VariableEntity v3;
    v3.setEntityAttributes("z");
    pkb.storeEntity(v3);
    REQUIRE(pkb.retrieveEntityData(variableQuery) == std::unordered_set<std::string>{"x", "y", "z"});

}

TEST_CASE("PKB stores constant entity") {
    PKB pkb;
    ConstantEntity c;
    ConstantEntity constantQuery;
    c.setEntityAttributes("1");
    pkb.storeEntity(c);
    REQUIRE(pkb.retrieveEntityData(constantQuery) == std::unordered_set<std::string>{"1"});

    ConstantEntity c2;
    c2.setEntityAttributes("2");
    pkb.storeEntity(c2);
    REQUIRE(pkb.retrieveEntityData(constantQuery) == std::unordered_set<std::string>{"1", "2"});

    ConstantEntity c3;
    c3.setEntityAttributes("3");
    pkb.storeEntity(c3);
    REQUIRE(pkb.retrieveEntityData(constantQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores procedure entity") {
    PKB pkb;
    ProcedureEntity p;
    ProcedureEntity procedureQuery;
    p.setEntityAttributes("main");
    pkb.storeEntity(p);
    REQUIRE(pkb.retrieveEntityData(procedureQuery) == std::unordered_set<std::string>{"main"});

    ProcedureEntity p2;
    p2.setEntityAttributes("proc1");
    pkb.storeEntity(p2);
    REQUIRE(pkb.retrieveEntityData(procedureQuery) == std::unordered_set<std::string>{"main", "proc1"});

    ProcedureEntity p3;
    p3.setEntityAttributes("proc2");
    pkb.storeEntity(p3);
    REQUIRE(pkb.retrieveEntityData(procedureQuery) == std::unordered_set<std::string>{"main", "proc1", "proc2"});

}

TEST_CASE("PKB stores statement entity") {
    PKB pkb;
    StatementEntity s;
    StatementEntity statementQuery;
    s.setEntityAttributes("1");
    pkb.storeEntity(s);
    REQUIRE(pkb.retrieveEntityData(statementQuery) == std::unordered_set<std::string>{"1"});

    StatementEntity s2;
    s2.setEntityAttributes("2");
    pkb.storeEntity(s2);
    REQUIRE(pkb.retrieveEntityData(statementQuery) == std::unordered_set<std::string>{"1", "2"});

    StatementEntity s3;
    s3.setEntityAttributes("3");
    pkb.storeEntity(s3);
    REQUIRE(pkb.retrieveEntityData(statementQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores read entity") {
    PKB pkb;
    ReadEntity r;
    ReadEntity readQuery;
    r.setEntityAttributes("1");
    pkb.storeEntity(r);
    REQUIRE(pkb.retrieveEntityData(readQuery) == std::unordered_set<std::string>{"1"});

    ReadEntity r2;
    r2.setEntityAttributes("2");
    pkb.storeEntity(r2);
    REQUIRE(pkb.retrieveEntityData(readQuery) == std::unordered_set<std::string>{"1", "2"});

    ReadEntity r3;
    r3.setEntityAttributes("3");
    pkb.storeEntity(r3);
    REQUIRE(pkb.retrieveEntityData(readQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores print entity") {
    PKB pkb;
    PrintEntity p;
    PrintEntity printQuery;
    p.setEntityAttributes("1");
    pkb.storeEntity(p);
    REQUIRE(pkb.retrieveEntityData(printQuery) == std::unordered_set<std::string>{"1"});

    PrintEntity p2;
    p2.setEntityAttributes("2");
    pkb.storeEntity(p2);
    REQUIRE(pkb.retrieveEntityData(printQuery) == std::unordered_set<std::string>{"1", "2"});

    PrintEntity p3;
    p3.setEntityAttributes("3");
    pkb.storeEntity(p3);
    REQUIRE(pkb.retrieveEntityData(printQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores assign entity") {
    PKB pkb;
    AssignEntity a;
    AssignEntity assignQuery;
    a.setEntityAttributes("1");
    pkb.storeEntity(a);
    REQUIRE(pkb.retrieveEntityData(assignQuery) == std::unordered_set<std::string>{"1"});

    AssignEntity a2;
    a2.setEntityAttributes("2");
    pkb.storeEntity(a2);
    REQUIRE(pkb.retrieveEntityData(assignQuery) == std::unordered_set<std::string>{"1", "2"});

    AssignEntity a3;
    a3.setEntityAttributes("3");
    pkb.storeEntity(a3);
    REQUIRE(pkb.retrieveEntityData(assignQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores while entity") {
    PKB pkb;
    WhileEntity w;
    WhileEntity whileQuery;
    w.setEntityAttributes("1");
    pkb.storeEntity(w);
    REQUIRE(pkb.retrieveEntityData(whileQuery) == std::unordered_set<std::string>{"1"});

    WhileEntity w2;
    w2.setEntityAttributes("2");
    pkb.storeEntity(w2);
    REQUIRE(pkb.retrieveEntityData(whileQuery) == std::unordered_set<std::string>{"1", "2"});

    WhileEntity w3;
    w3.setEntityAttributes("3");
    pkb.storeEntity(w3);
    REQUIRE(pkb.retrieveEntityData(whileQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores if entity") {
    PKB pkb;
    IfEntity i;
    IfEntity ifQuery;
    i.setEntityAttributes("1");
    pkb.storeEntity(i);
    REQUIRE(pkb.retrieveEntityData(ifQuery) == std::unordered_set<std::string>{"1"});

    IfEntity i2;
    i2.setEntityAttributes("2");
    pkb.storeEntity(i2);
    REQUIRE(pkb.retrieveEntityData(ifQuery) == std::unordered_set<std::string>{"1", "2"});

    IfEntity i3;
    i3.setEntityAttributes("3");
    pkb.storeEntity(i3);
    REQUIRE(pkb.retrieveEntityData(ifQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores call entity") {
    PKB pkb;
    CallEntity c;
    CallEntity callQuery;
    c.setEntityAttributes("1");
    pkb.storeEntity(c);
    REQUIRE(pkb.retrieveEntityData(callQuery) == std::unordered_set<std::string>{"1"});

    CallEntity c2;
    c2.setEntityAttributes("2");
    pkb.storeEntity(c2);
    REQUIRE(pkb.retrieveEntityData(callQuery) == std::unordered_set<std::string>{"1", "2"});

    CallEntity c3;
    c3.setEntityAttributes("3");
    pkb.storeEntity(c3);
    REQUIRE(pkb.retrieveEntityData(callQuery) == std::unordered_set<std::string>{"1", "2", "3"});

}

TEST_CASE("PKB stores constant, procedure, and call entity") {

    PKB pkb;
    ConstantEntity c;
    ConstantEntity constantQuery;
    c.setEntityAttributes("1");
    pkb.storeEntity(c);
    REQUIRE(pkb.retrieveEntityData(constantQuery) == std::unordered_set<std::string>{"1"});

    ConstantEntity c2;
    c2.setEntityAttributes("2");
    pkb.storeEntity(c2);
    REQUIRE(pkb.retrieveEntityData(constantQuery) == std::unordered_set<std::string>{"1", "2"});

    ProcedureEntity p;
    ProcedureEntity procedureQuery;
    p.setEntityAttributes("main");
    pkb.storeEntity(p);
    REQUIRE(pkb.retrieveEntityData(procedureQuery) == std::unordered_set<std::string>{"main"});

    ProcedureEntity p2;
    p2.setEntityAttributes("proc1");
    pkb.storeEntity(p2);
    REQUIRE(pkb.retrieveEntityData(procedureQuery) == std::unordered_set<std::string>{"main", "proc1"});

    CallEntity call;
    CallEntity callQuery;
    call.setEntityAttributes("1");
    pkb.storeEntity(call);
    REQUIRE(pkb.retrieveEntityData(callQuery) == std::unordered_set<std::string>{"1"});
    CallEntity call2;
    call2.setEntityAttributes("2");
    pkb.storeEntity(call2);
    REQUIRE(pkb.retrieveEntityData(callQuery) == std::unordered_set<std::string>{"1", "2"});
}

TEST_CASE("PKB call on empty print entity") {
    PKB pkb;
    PrintEntity printQuery;
    REQUIRE(pkb.retrieveEntityData(printQuery).empty());
}
--------------------
RepoName: 23s2-cp-spa-team-06
File: Team06/Code06/src/unit_testing/src/SPTokeniser/TestSPTokenizer.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/oAJohybeAV5fcQwk7i4toIUu?model=gpt-3.5-turbo&mode=chat
ChatId: oAJohybeAV5fcQwk7i4toIUu
Code:
SECTION("Testing tokenisation of relational operators- with spaces.") {
       std::string input = "if(i >= 10)";
       std::vector<SPToken> expectedTokens{
           SPToken(TokenType::NAME, "if"),
           SPToken(TokenType::PUNCTUATION, "("),
           SPToken(TokenType::NAME, "i"),
           SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, ">="),
           SPToken(TokenType::INTEGER, "10"),
           SPToken(TokenType::PUNCTUATION, ")")
       };

       SPTokenizer tokenizer(input);
       std::vector<SPToken> actualTokens = tokenizer.tokenize();

       REQUIRE(actualTokens == expectedTokens);
   }
    
}

TEST_CASE("Tokenization of relational operators") {
    SECTION("Testing tokenisation of relational operators with spaces") {
        std::string input = "if(i >= 10)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "i"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, ">="),
            SPToken(TokenType::INTEGER, "10"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();

        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Greater Than operator") {
        std::string input = "if(i > 5)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "i"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, ">"),
            SPToken(TokenType::INTEGER, "5"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Less Than operator") {
        std::string input = "if(x < 20)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "x"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "<"),
            SPToken(TokenType::INTEGER, "20"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Less Than or Equal To operator") {
        std::string input = "if(y <= 100)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "y"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "<="),
            SPToken(TokenType::INTEGER, "100"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Equal To operator") {
        std::string input = "if(a == 50)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "a"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "=="),
            SPToken(TokenType::INTEGER, "50"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Not Equal To operator") {
        std::string input = "if(b != 0)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "b"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "!="),
            SPToken(TokenType::INTEGER, "0"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of GTE without spaces") {
        std::string input = "if(i>=10)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "i"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, ">="),
            SPToken(TokenType::INTEGER, "10"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();

        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Greater Than operator") {
        std::string input = "if(i>5)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "i"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, ">"),
            SPToken(TokenType::INTEGER, "5"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Less Than operator") {
        std::string input = "if(x<20)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "x"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "<"),
            SPToken(TokenType::INTEGER, "20"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Less Than or Equal To operator") {
        std::string input = "if(y<=100)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "y"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "<="),
            SPToken(TokenType::INTEGER, "100"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Equal To operator") {
        std::string input = "if(a==50)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "a"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "=="),
            SPToken(TokenType::INTEGER, "50"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of Not Equal To operator") {
        std::string input = "if(b!=0)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "b"),
            SPToken(TokenType::RELATIONAL_EXPRESSION_OPERATORS, "!="),
            SPToken(TokenType::INTEGER, "0"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of unary conditional operator not- without whitespaces") {
        std::string input = "if(!b)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::UNARY_CONDITIONAL_EXPRESSION_OPERATORS, "!"),
            SPToken(TokenType::NAME, "b"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }
}

TEST_CASE("Tokenization of conditional operators") {
    // Existing test cases for relational operators

    SECTION("Testing tokenisation of unary conditional operator not- with whitespaces") {
        std::string input = "if( ! b )";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::UNARY_CONDITIONAL_EXPRESSION_OPERATORS, "!"),
            SPToken(TokenType::NAME, "b"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of unary conditional operator not- with partial whitespaces") {
        std::string input = "if( !b )";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::UNARY_CONDITIONAL_EXPRESSION_OPERATORS, "!"),
            SPToken(TokenType::NAME, "b"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of binary logical AND operator") {
        std::string input = "if(a && b)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "a"),
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "&&"),
            SPToken(TokenType::NAME, "b"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of binary logical AND operator - without whitespace") {
        std::string input = "if(a&&b)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "a"),
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "&&"),
            SPToken(TokenType::NAME, "b"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of binary logical OR operator") {
        std::string input = "if(x || y)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "x"),
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "||"),
            SPToken(TokenType::NAME, "y"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }

    SECTION("Testing tokenisation of binary logical OR operator- without whitespaces") {
        std::string input = "if(x||y)";
        std::vector<SPToken> expectedTokens{
            SPToken(TokenType::NAME, "if"),
            SPToken(TokenType::PUNCTUATION, "("),
            SPToken(TokenType::NAME, "x"),
            SPToken(TokenType::BINARY_CONDITIONAL_EXPRESSION_OPERATORS, "||"),
            SPToken(TokenType::NAME, "y"),
            SPToken(TokenType::PUNCTUATION, ")")
        };

        SPTokenizer tokenizer(input);
        std::vector<SPToken> actualTokens = tokenizer.tokenize();
        REQUIRE(actualTokens == expectedTokens);
    }
}
--------------------
Directory:../sample/repo/23s2-cp-spa-team-06
Total Snippets: 183
Total lines: 8221
SP Snippets: 76
SP lines: 3740
PKB Snippets: 26
PKB lines: 972
QPS Snippets: 72
QPS lines: 3053
