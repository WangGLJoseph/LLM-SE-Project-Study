RepoName: 23s2-cp-spa-team-13
File: Team13/Code13/src/spa/src/SP/Validator/SyntaxValidator.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/8zpPT0KiO2e7WE5jSHHLxE9p?model=gpt-4&mode=chat
ChatId: 8zpPT0KiO2e7WE5jSHHLxE9p
Code:
bool SyntaxValidator::isRelExpr(vector<Token> tokens, int start, int end) {
  std::vector<std::string> rel_operators = { ">", ">=", "<", "<=", "==", "!=" };
  int operator_index = -1;
  for (int i = start + 1; i < end; i++) {
    if(std::find(rel_operators.begin(), rel_operators.end(), tokens[i].getValue()) != rel_operators.end()) {
      operator_index = i;
      break;
    }
  }
  if (operator_index == -1) {
    return false;
  }
  return isRelFactor(tokens, start, operator_index - 1) && isRelFactor(tokens, operator_index + 1, end);
}

bool SyntaxValidator::validateAssignStmt(vector<Token> tokens) {
  cout << "VALIDATE ASSIGN STMT";
  if (tokens[1].getTokenType() == EQUALS && tokens[tokens.size() - 1].getValue() == ";") {
    return isExpr(tokens, 2, tokens.size() - 2);
  } else {
    return false;
  }
}

bool SyntaxValidator::isCondExpr(vector<Token> tokens, int start, int end) {
  cout << "ISCONDEXPR REACHED " << start << "," << end << "\n";
  if (tokens[start].getValue() == "!") {
    return (tokens[start+1].getValue() == "(") &&
           isCondExpr(tokens, start + 2, end - 1) && (tokens[end].getValue() == ")");
  }
  else if ((tokens[start].getValue() == "(") && (tokens[end].getValue() == ")")) {
    int i = start;
    int paren_depth = 0;
    while(i <= end-1) {
      if (tokens[i].getValue() == "(") {
        ++paren_depth;
      }
      else if (tokens[i].getValue() == ")") {
        --paren_depth;
      }
      else if ((paren_depth == 0) && ((tokens[i].getValue() == "&&") || (tokens[i].getValue() == "||"))) {
        return isCondExpr(tokens, start + 1, i - 2) &&
               isCondExpr(tokens, i + 2, end - 1);
      }
      i++;
    }
  }
  // If we are still not sure about what kind of expression it is (maybe we didn't encounter '&&' or '||')
  // We should try to check if it's a rel_expr
  else if (isRelExpr(tokens, start, end)) {
    cout << "ISRELEXPR " << start << "," << end << "\n";
    return true;
  }
  // Finally, if none of the above return statements were hit,
  // we know the expression isn't valid, so return false.
  return false;
}

bool SyntaxValidator::isRelFactor(vector<Token> tokens, int start, int end) {
  if (start == end)
    return isVarOrConst(tokens[start].getTokenType());  // check if single token is var_name or const_value
  return isExpr(tokens, start, end);  // else check if it's an expression
}

bool SyntaxValidator::isExpr(vector<Token> tokens, int start, int end) {
  cout << "REACHED ISEXPR: start=" << start << " end=" << end << "\n";
  int i = start;
  int paren_depth = 0;
  while(i <= end-1) {
    if (tokens[i].getValue() == "(") {
      ++paren_depth;
    }
    else if (tokens[i].getValue() == ")") {
      --paren_depth;
    }
  //... check for "+" and "-" operator and verify terms on both side recursively...
    else if((paren_depth == 0) && (tokens[i].getValue() == "+" || tokens[i].getValue() == "-")) {
      return isTerm(tokens, start, i - 1) && isExpr(tokens, i + 1, end);
    }
    i++;
  }
  return isTerm(tokens, start, end);
}

bool SyntaxValidator::isTerm(vector<Token> tokens, int start, int end) {
  cout << "REACHED ISTERM: start=" << start << " end=" << end << "\n";
  int i = start;
  int paren_depth = 0;
  while(i <= end-1) {
    if (tokens[i].getValue() == "(") {
      ++paren_depth;
    }
    else if (tokens[i].getValue() == ")") {
      --paren_depth;
    }
    else if ((paren_depth == 0) && (tokens[i].getValue() == "*" || tokens[i].getValue() == "/" || tokens[i].getValue() == "%")) {
      return isTerm(tokens, start, i - 1) && isTerm(tokens, i + 1, end);
    }
    i++;
  }
  return isFactor(tokens, start, end);
}

bool SyntaxValidator::isFactor(vector<Token> tokens, int start, int end) {
  cout << "REACHED ISFACTOR: start=" << start << " end=" << end << "\n";
  // check if it's a var_name or const_value
  if (start == end && isVarOrConst(tokens[start].getTokenType())) {
    return true;
  }
  // check if it's an expr enclosed in parentheses
  else if (tokens[start].getValue() == "(" && tokens[end].getValue() == ")"){
    return isExpr(tokens, start + 1, end - 1);
  }
  // if it's neither a var_name/const_value nor an expr with parentheses - it's not a valid factor
  else {
    return false;
  }
}
--------------------
RepoName: 23s2-cp-spa-team-13
File: Team13/Code13/src/spa/src/SP/Parser/Parser.cpp
Generator: gpt
Intervention: 1
Language: e
Prompt: https://platform.openai.com/playground/p/NUX1lMOIK7DCiEzSZgir8veZ?model=gpt-4&mode=chat
ChatId: NUX1lMOIK7DCiEzSZgir8veZ
Code:
vector<Token> Parser::infixToPostfix(vector<Token>& infix){
    stack<Token> stk;
    vector<Token> postfix;
    for (int i = 0; i < infix.size(); i++) {
        Token token = infix[i];
        if(token.getTokenType() == INTEGER || token.getTokenType() == NAME){
            postfix.push_back(token);
        }
        else if(token.getValue() == "("){
            stk.push(token);
        }
        else if(token.getValue() == ")"){
            while(!stk.empty() && stk.top().getValue() != "("){
                postfix.push_back(stk.top());
                stk.pop();
            }
            stk.pop(); // Removing the opening bracket "("
        }
        else{
            while(!stk.empty() && precedence(token.getValue()) <= precedence(stk.top().getValue())){
                postfix.push_back(stk.top());
                stk.pop();
            }
            stk.push(infix[i]);
        }
    }
    while(!stk.empty()){
        postfix.push_back(stk.top());
        stk.pop();
    }
    return postfix;
}

ASTNode* Parser::parsePostfixArithmeticAST(vector<Token>& tokens, int lineNum) {
    stack<ASTNode*> st;
    for(Token token: tokens) {
        ASTNode* node;
        if(token.getTokenType() == INTEGER) {
            node = new ConstantNode(lineNum, token.getValue());
            st.push(node);
        } else if (token.getTokenType() == NAME) {
            node = new VariableNode(lineNum, token.getValue());
            st.push(node);
        }
        else {
            node = new ArithmeticOperatorNode(lineNum, token.getValue());
            ASTNode* secondChild = st.top();
            st.pop();
            ASTNode* firstChild = st.top();
            st.pop();
            node->addChildNode(firstChild);
            node->addChildNode(secondChild);
            st.push(node);
        }
    }
    return st.top();
}
--------------------
RepoName: 23s2-cp-spa-team-13
File: Team13/Code13/src/spa/src/PKB/Facade/SPTalker.cpp
Generator: gpt
Intervention: 3
Language: e
Prompt: 
ChatId: 
Code:
//promt: wirte the SPTalker skeleton (given uml)

#include "SPTalker.h"

bool SPTalker::numberOfStmt(int num) {
    return pkb.setTotalNumStmt(num);
}

bool SPTalker::variable(int stmt, std::string variable) {
    return pkb.addVariable(stmt, variable);
}

bool SPTalker::ifStmt(int stmt) {
    return pkb.addIfs(stmt);
}

bool SPTalker::whileStmt(int stmt) {
    return pkb.addWhile(stmt);
}

bool SPTalker::assignStmt(int stmt) {
    return pkb.addAssign(stmt);
}


bool SPTalker::readStmt(int stmt) {
    return pkb.addRead(stmt);
}

bool SPTalker::printStmt(int stmt) {
    return pkb.addPrint(stmt);
}

bool SPTalker::callStmt(int stmt) {
    return pkb.addCall(stmt);
}

bool SPTalker::followStmt(int stmt1, int stmt2) {
    pkb.addFollows(stmt1, stmt2);
    return true;
}

bool SPTalker::procedureName(std::string name) {
    return pkb.addProcedureName(name);
}

bool SPTalker::constValue(int value, int stmt) {
    pkb.addConstPattern(value, stmt);
    return pkb.addConstValue(value);
}

bool SPTalker::parentStmt(int stmt, std::vector<int> list) {
    for (int i = 0; i < list.size(); i++) {
        pkb.addParentAndChild(stmt, list[i]);
    }
    return true;
}

bool SPTalker::variableName(string varName, int stmtNo, bool isModified, bool isUses) {
    pkb.addVariableName(varName, stmtNo, isModified, isUses);
    return true;
}

bool SPTalker::parentStarStmt(int stmt, std::vector<int> list) {
    pkb.addParentAndChildStar(stmt, list);
    return true;
}
--------------------
RepoName: 23s2-cp-spa-team-13
File: Team13/Code13/src/spa/src/PKB/ParentRelation.cpp
Generator: gpt
Intervention: 3
Language: e
Prompt: write the parentrelation class; write doxygen comments for class
ChatId: 
Code:
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <iostream>
#include "ParentRelation.h"

    void ParentRelation::addParentAndChild(int stmt1, int stmt2) {
        parent[stmt1].push_back(stmt2);
        child.insert({ stmt2, stmt1 });
    }


    bool ParentRelation::isParent(int stmt1, int stmt2) {
        if (parent.count(stmt1) > 0 && !parent[stmt1].empty()) {
            std::vector<int> childList = parent[stmt1];
            auto it = std::find(childList.begin(), childList.end(), stmt2);
            return it != childList.end();
        }
        return false;
    }

    int ParentRelation::whoParent(int stmt) {
        return child[stmt];
    }

    std::vector<int> ParentRelation::whoChild(int stmt) {
        return parent[stmt];
    }
--------------------
RepoName: 23s2-cp-spa-team-13
File: Team13/Code13/src/spa/src/PKB/ParentRelationStar.cpp
Generator: gpt
Intervention: 3
Language: e
Prompt: 
ChatId: 
Code:
//promt: wirte the ParentRelationStar class;

#include <unordered_map>
#include <vector>
#include <algorithm>
#include <iostream>
#include "ParentRelationStar.h"

void ParentRelationStar::addParentAndChild(int stmt1, int stmt2) {
    parentStar[stmt1].push_back(stmt2);
    childStar[stmt2].push_back(stmt1);
}


bool ParentRelationStar::isParent(int stmt1, int stmt2) {
    if (parentStar.count(stmt1) > 0 && !parentStar[stmt1].empty()) {
        std::vector<int> childList = parentStar[stmt1];
        auto it = std::find(childList.begin(), childList.end(), stmt2);
        return it != childList.end();
    }
    return false;
}

std::vector<int> ParentRelationStar::whoChild(int stmt) {
    return parentStar[stmt];
}


void ParentRelationStar::parseParentList(int stmt, std::vector<int> list) {
    for (int i = 0; i < list.size(); i++) {
        if (!isParent(stmt, list[i])) {
            addParentAndChild(stmt, list[i]);
        }
    }
}
--------------------
RepoName: 23s2-cp-spa-team-13
File: Team13/Code13/src/spa/src/PKB/FollowsRelation.cpp
Generator: gpt
Intervention: 3
Language: e
Prompt: 
ChatId: 
Code:
//promt: write the followsrelation class;

#include <unordered_map>
#include <vector>
#include <algorithm>
#include <iostream>
#include <list>
#include "FollowsRelation.h"

    void FollowsRelation::addFollows(int stmt1, int stmt2) {
        if (inSeen(stmt1)) {
            int stmtToAdd = stmt1;
            while (seen.find(stmtToAdd) != seen.end()) {
                follows[rootSeen(stmtToAdd)].push_back(stmt2);
                stmtToAdd = rootSeen(stmtToAdd);
            }
            follows[stmt1].push_back(stmt2);
            addSeen(stmt1, stmt2);
        } else {
            follows[stmt1].push_back(stmt2);
            addSeen(stmt1, stmt2);
        }

        if (inSeenReversed(stmt2)) {
            followed[rootSeenReversed(stmt2)].push_back(stmt1);
            followed[stmt2].push_back(stmt1);
            addSeenReversed(stmt1, stmt2);
        } else {
            followed[stmt2].push_back(stmt1);
            addSeenReversed(stmt1, stmt2);
        }
    }

    void FollowsRelation::addSeen(int stmt1, int stmt2) {
        seen.insert({stmt2, stmt1});
    }

    void FollowsRelation::addSeenReversed(int stmt1, int stmt2) {
        seenReversed.insert({stmt1, stmt2});
    }


    bool FollowsRelation::inSeen(int stmt) {
        return seen.find(stmt) != seen.end();
    }

    bool FollowsRelation::inSeenReversed(int stmt) {
        return seenReversed.find(stmt) != seenReversed.end();
    }


    int FollowsRelation::rootSeen(int stmt) {
        if (inSeen(stmt)) {
            return seen.find(stmt)->second;
        }
        return stmt;
    }

    int FollowsRelation::rootSeenReversed(int stmt) {
        if (inSeenReversed(stmt)) {
            return rootSeenReversed(seenReversed.find(stmt)->second);
        }
        return stmt;
    }

    bool FollowsRelation::isFollows(int stmt1, int stmt2) {
        if (follows.count(stmt1) > 0 && !follows[stmt1].empty()) {
            return follows[stmt1][0] == stmt2;
        }
        return false;
    }

    int FollowsRelation::whoFollow(int stmt) {
        std::vector<int> &v = follows[stmt];
        return *std::min_element(v.begin(), v.end());
    }

    std::vector<int> FollowsRelation::whoFollowsStar(int stmt) {
        std::vector<int> v = follows[stmt];
        std::sort(v.begin(), v.end());
        return v;
    }
--------------------
Directory:../sample/repo/23s2-cp-spa-team-13
Total Snippets: 6
Total lines: 394
SP Snippets: 2
SP lines: 178
PKB Snippets: 4
PKB lines: 216
QPS Snippets: 0
QPS lines: 0
